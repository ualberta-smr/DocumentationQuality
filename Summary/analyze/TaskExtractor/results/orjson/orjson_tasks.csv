"Paragraph","Tasks"
"orjson is a fast, correct JSON library for Python. It
benchmarks as the fastest Python
library for JSON and is more correct than the standard json library or other
third-party libraries. It serializes
dataclass,
datetime,
numpy, and
UUID instances natively.","serialize dataclass
serialize datetime
serialize numpy
serialize UUID instances"
"orjson supports CPython 3.7, 3.8, 3.9, and 3.10. It distributes x86_64/amd64
and aarch64/armv8 wheels for Linux and macOS. It distributes x86_64/amd64 wheels
for Windows. orjson does not support PyPy. Releases follow semantic
versioning and serializing a new object type without an opt-in flag is
considered a breaking change.","support cpython"
"To install a wheel from PyPI:","install wheel from pypi"
"This is an example of serializing, with options specified, and deserializing:","serialize  with options
deserialize  with options"
"orjson version 3 serializes more types than version 2. Subclasses of str,
int, dict, and list are now serialized. This is faster and more similar
to the standard library. It can be disabled with
orjson.OPT_PASSTHROUGH_SUBCLASS.dataclasses.dataclass instances
are now serialized by default and cannot be customized in a
default function unless option=orjson.OPT_PASSTHROUGH_DATACLASS is
specified. uuid.UUID instances are serialized by default.
For any type that is now serialized,
implementations in a default function and options enabling them can be
removed but do not need to be. There was no change in deserialization.","serialize more types than version
serialize subclasses of str
serialize dataclasses.dataclass instances
specify option = orjson.OPT_PASSTHROUGH_DATACLASS
serialize uuid.UUID instances
remove implementations in default function
remove implementations in options
remove implementations for type"
"To migrate from the standard library, the largest difference is that
orjson.dumps returns bytes and json.dumps returns a str. Users with
dict objects using non-str keys should specify
option=orjson.OPT_NON_STR_KEYS. sort_keys is replaced by
option=orjson.OPT_SORT_KEYS. indent is replaced by
option=orjson.OPT_INDENT_2 and other levels of indentation are not
supported.","use non
replace sort_keys
replace indent"
"dumps() serializes Python objects to JSON.","serialize Python objects to JSON"
"It natively serializes
str, dict, list, tuple, int, float, bool,
dataclasses.dataclass, typing.TypedDict, datetime.datetime,
datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and
None instances. It supports arbitrary types through default. It
serializes subclasses of str, int, dict, list,
dataclasses.dataclass, and enum.Enum. It does not serialize subclasses
of tuple to avoid serializing namedtuple objects as arrays. To avoid
serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.","serialize none
serialize str
serialize dict
serialize list
serialize tuple
serialize int
serialize float
serialize bool
serialize dataclasses.dataclass
serialize typing.TypedDict
serialize datetime.datetime
serialize datetime.date
serialize datetime.time
serialize uuid.UUID
serialize numpy.ndarray
support arbitrary types through default
serialize subclasses of str
serialize namedtuple objects as arrays
specify option orjson.OPT_PASSTHROUGH_SUBCLASS"
"It raises JSONEncodeError on an unsupported type. This exception message
describes the invalid object with the error message
Type is not JSON serializable: .... To fix this, specify
default.","raise JSONEncodeError on unsupported type
specify default"
"It raises JSONEncodeError on a str that contains invalid UTF-8.","raise JSONEncodeError on str UTF-8"
"It raises JSONEncodeError on an integer that exceeds 64 bits by default or,
with OPT_STRICT_INTEGER, 53 bits.","raise JSONEncodeError on integer"
"It raises JSONEncodeError if a dict has a key of a type other than str,
unless OPT_NON_STR_KEYS is specified.","raise JSONEncodeError
specify OPT_NON_STR_KEYS"
"It raises JSONEncodeError if the output of default recurses to handling by
default more than 254 levels deep.","raise JSONEncodeError"
"It raises JSONEncodeError on circular references.","raise JSONEncodeError on circular references"
"It raises JSONEncodeError  if a tzinfo on a datetime object is
unsupported.","raise JSONEncodeError"
"To serialize a subclass or arbitrary types, specify default as a
callable that returns a supported type. default may be a function,
lambda, or callable class instance. To specify that a type was not
handled by default, raise an exception such as TypeError.","serialize subclass arbitrary types specify default as callable
raise exception such_as TypeError"
"The default callable may return an object that itself
must be handled by default up to 254 times before an exception
is raised.","raise exception"
"It is important that default raise an exception if a type cannot be handled.
Python otherwise implicitly returns None, which appears to the caller
like a legitimate value and is serialized:","raise exception
serialize none"
"To modify how data is serialized, specify option. Each option is an integer
constant in orjson. To specify multiple options, mask them together, e.g.,
option=orjson.OPT_STRICT_INTEGER | orjson.OPT_NAIVE_UTC.","specify option
serialize data
specify multiple options"
"This measures serializing the github.json fixture as compact (52KiB) or
pretty (64KiB):","serialize github.json fixture"
"rapidjson is blank because it does not support pretty printing. This can be
reproduced using the pyindent script.","use pyindent script"
"Serialize datetime.datetime objects without a tzinfo as UTC. This
has no effect on datetime.datetime objects that have tzinfo set.","serialize datetime.datetime objects without tzinfo"
"Serialize dict keys of type other than str. This allows dict keys
to be one of str, int, float, bool, None, datetime.datetime,
datetime.date, datetime.time, enum.Enum, and uuid.UUID. For comparison,
the standard library serializes str, int, float, bool or None by
default. orjson benchmarks as being faster at serializing non-str keys
than other libraries. This option is slower for str keys than the default.","serialize none by default
serialize none for comparison
serialize str by default
serialize str for comparison
serialize int by default
serialize int for comparison
serialize float by default
serialize float for comparison
serialize bool by default
serialize bool for comparison
serialize non"
"These types are generally serialized how they would be as
values, e.g., datetime.datetime is still an RFC 3339 string and respects
options affecting it. The exception is that int serialization does not
respect OPT_STRICT_INTEGER.","serialize types"
"This option has the risk of creating duplicate keys. This is because non-str
objects may serialize to the same str as an existing key, e.g.,
{""1"": true, 1: false}. The last key to be inserted to the dict will be
serialized last and a JSON deserializer will presumably take the last
occurrence of a key (in the above, false). The first value will be lost.","serialize  to same str
insert  to dict
serialize last key"
"This measures serializing 589KiB of JSON comprising a list of 100 dict
in which each dict has both 365 randomly-sorted int keys representing epoch
timestamps as well as one str key and the value for each key is a
single integer. In ""str keys"", the keys were converted to str before
serialization, and orjson still specifes option=orjson.OPT_NON_STR_KEYS
(which is always somewhat slower).","serialize 589KiB of JSON
convert keys in str keys"
"ujson is blank for sorting because it segfaults. json is blank because it
raises TypeError on attempting to sort before converting all keys to str.
rapidjson is blank because it does not support non-str keys. This can
be reproduced using the pynonstr script.","raise TypeError on attempting
convert keys to str
sort  before converting
use pynonstr script"
"Passthrough dataclasses.dataclass instances to default. This allows
customizing their output but is much slower.","customize output"
"Passthrough datetime.datetime, datetime.date, and datetime.time instances
to default. This allows serializing datetimes to a custom format, e.g.,
HTTP dates:","serialize datetimes to custom format"
"This does not affect datetimes in dict keys if using OPT_NON_STR_KEYS.","use OPT_NON_STR_KEYS"
"This does not affect serializing subclasses as dict keys if using
OPT_NON_STR_KEYS.","use OPT_NON_STR_KEYS"
"This is deprecated and has no effect in version 3. In version 2 this was
required to serialize  dataclasses.dataclass instances. For more, see
dataclass.","serialize dataclasses.dataclass instances"
"Serialize numpy.ndarray instances. For more, see
numpy.","serialize numpy.ndarray instances"
"This is deprecated and has no effect in version 3. In version 2 this was
required to serialize uuid.UUID instances. For more, see
UUID.","serialize uuid.UUID instances"
"Serialize dict keys in sorted order. The default is to serialize in an
unspecified order. This is equivalent to sort_keys=True in the standard
library.","serialize dict keys"
"This measures serializing the twitter.json fixture unsorted and sorted:","serialize twitter.json fixture"
"The benchmark can be reproduced using the pysort script.","use pysort script"
"dataclass also serialize as maps but this has no effect on them.","serialize  as maps"
"Serialize a UTC timezone on datetime.datetime instances as Z instead
of +00:00.","serialize UTC timezone on datetime.datetime instances"
"loads() deserializes JSON to Python objects. It deserializes to dict,
list, int, float, str, bool, and None objects.","deserialize JSON to Python objects
deserialize  to none objects
deserialize  to dict bool"
"bytes, bytearray, memoryview, and str input are accepted. If the input
exists as a memoryview, bytearray, or bytes object, it is recommended to
pass these directly rather than creating an unnecessary str object. This has
lower memory usage and lower latency.","pass  than creating"
"It raises JSONDecodeError if given an invalid type or invalid
JSON. This includes if the input contains NaN, Infinity, or -Infinity,
which the standard library allows, but is not valid JSON.","raise JSONDecodeError"
"orjson serializes instances of dataclasses.dataclass natively. It serializes
instances 40-50x as fast as other libraries and avoids a severe slowdown seen
in other libraries compared to serializing dict.","serialize instances of dataclasses.dataclass natively
serialize instances"
"It is supported to pass all variants of dataclasses, including dataclasses
using __slots__, frozen dataclasses, those with optional or default
attributes, and subclasses. There is a performance benefit to not
using __slots__.","pass variants of dataclasses
use subclasses
use __slots__
support  including dataclasses"
"This measures serializing 555KiB of JSON, orjson natively and other libraries
using default to serialize the output of dataclasses.asdict(). This can be
reproduced using the pydataclass script.","serialize 555KiB of JSON natively
serialize 555KiB of other libraries
use default
serialize output of dataclasses.asdict()
use pydataclass script"
"Dataclasses are serialized as maps, with every attribute serialized and in
the order given on class definition:","serialize dataclasses with attribute
serialize dataclasses as maps"
"Users may wish to control how dataclass instances are serialized, e.g.,
to not serialize an attribute or to change the name of an
attribute when serialized. orjson may implement support using the
metadata mapping on field attributes,
e.g., field(metadata={""json_serialize"": False}), if use cases are clear.","serialize dataclass instances
use metadata mapping on field attributes"
"orjson serializes datetime.datetime objects to
RFC 3339 format,
e.g., ""1970-01-01T00:00:00+00:00"". This is a subset of ISO 8601 and
compatible with isoformat() in the standard library.","serialize datetime.datetime objects to RFC"
"datetime.datetime supports instances with a tzinfo that is None,
datetime.timezone.utc, a timezone instance from the python3.9+ zoneinfo
module, or a timezone instance from the third-party pendulum, pytz, or
dateutil/arrow libraries.","support instances with tzinfo"
"It is faster to have orjson serialize datetime objects than to do so
before calling dumps(). If using an unsupported type such as
pendulum.datetime, use default.","call dumps()
use unsupported type such_as pendulum.datetime
use default"
"To disable serialization of datetime objects specify the option
orjson.OPT_PASSTHROUGH_DATETIME.","specify option orjson.OPT_PASSTHROUGH_DATETIME"
"To use ""Z"" suffix instead of ""+00:00"" to indicate UTC (""Zulu"") time, use the option
orjson.OPT_UTC_Z.","use z suffix
use option orjson.OPT_UTC_Z"
"Enums with members that are not supported types can be serialized using
default:","use default
serialize types"
"orjson serializes and deserializes double precision floats with no loss of
precision and consistent rounding. The same behavior is observed in rapidjson,
simplejson, and json. ujson 1.35 was inaccurate in both serialization and
deserialization, i.e., it modifies the data, and the recent 2.0 release is
accurate.","modify data"
"orjson serializes and deserializes 64-bit integers by default. The range
supported is a signed 64-bit integer's minimum (-9223372036854775807) to
an unsigned 64-bit integer's maximum (18446744073709551615). This
is widely compatible, but there are implementations
that only support 53-bits for integers, e.g.,
web browsers. For those implementations, dumps() can be configured to
raise a JSONEncodeError on values exceeding the 53-bit range.","serialize 64-bit integers by default
deserialize 64-bit integers by default
support 53-bits web browsers
support implementations
raise JSONEncodeError on values
configure dumps() for implementations"
"orjson natively serializes numpy.ndarray and individual numpy.float64,
numpy.float32, numpy.int64, numpy.int32, numpy.int8, numpy.uint64,
numpy.uint32, numpy.uint8, numpy.uintp, or numpy.intp, and
numpy.datetime64 instances.","serialize numpy.ndarray individual numpy.float64
serialize numpy.float32 numpy.uintp
serialize numpy.intp
serialize numpy.datetime64 instances"
"orjson is faster than all compared libraries at serializing
numpy instances. Serializing numpy data requires specifying
option=orjson.OPT_SERIALIZE_NUMPY.","serialize numpy instances"
"numpy.datetime64 instances are serialized as RFC 3339 strings and
datetime options affect them.","serialize numpy.datetime64 instances as RFC"
"If an array is not a contiguous C array, contains an supported datatype,
or contains a numpy.datetime64 using an unsupported representation
(e.g., picoseconds), orjson falls through to default. In default,
obj.tolist() can be specified. If an array is malformed, which
is not expected, orjson.JSONEncodeError is raised.","use unsupported representation
specify obj.tolist() in default
raise orjson.JSONEncodeError"
"This measures serializing 92MiB of JSON from an numpy.ndarray with
dimensions of (50000, 100) and numpy.float64 values:","serialize 92MiB of JSON
serialize 92MiB from numpy.ndarray"
"This measures serializing 100MiB of JSON from an numpy.ndarray with
dimensions of (100000, 100) and numpy.int32 values:","serialize 100MiB of JSON
serialize 100MiB from numpy.ndarray"
"This measures serializing 105MiB of JSON from an numpy.ndarray with
dimensions of (100000, 200) and numpy.bool values:","serialize 105MiB of JSON
serialize 105MiB from numpy.ndarray"
"In these benchmarks, orjson serializes natively, ujson is blank because it
does not support a default parameter, and the other libraries serialize
ndarray.tolist() via default. The RSS column measures peak memory
usage during serialization. This can be reproduced using the pynumpy script.","serialize ndarray.tolist() via default
use pynumpy script"
"orjson does not have an installation or compilation dependency on numpy. The
implementation is independent, reading numpy.ndarray using
PyArrayInterface.","use PyArrayInterface"
"orjson is strict about UTF-8 conformance. This is stricter than the standard
library's json module, which will serialize and deserialize UTF-16 surrogates,
e.g., ""\ud800"", that are invalid UTF-8.","serialize UTF-16 surrogates
serialize json module
deserialize json module"
"If orjson.dumps() is given a str that does not contain valid UTF-8,
orjson.JSONEncodeError is raised. If loads() receives invalid UTF-8,
orjson.JSONDecodeError is raised.","raise orjson.JSONEncodeError
raise orjson.JSONDecodeError"
"To make a best effort at deserializing bad input, first decode bytes using
the replace or lossy argument for errors:","deserialize bad input
use replace lossy argument for errors"
"orjson serializes uuid.UUID instances to
RFC 4122 format, e.g.,
""f81d4fae-7dec-11d0-a765-00a0c91e6bf6"".","serialize uuid.UUID instances to RFC"
"The library has comprehensive tests. There are tests against fixtures in the
JSONTestSuite and
nativejson-benchmark
repositories. It is tested to not crash against the
Big List of Naughty Strings.
It is tested to not leak memory. It is tested to not crash
against and not accept invalid UTF-8. There are integration tests
exercising the library's use in web servers (gunicorn using multiprocess/forked
workers) and when
multithreaded. It also uses some tests from the ultrajson library.","use tests from ultrajson library"
"This shows that all libraries deserialize valid JSON but only orjson
correctly rejects the given invalid JSON fixtures. Errors are largely due to
accepting invalid strings and numbers.","deserialize valid JSON"
"The graph above can be reproduced using the pycorrectness script.","use pycorrectness script"
"This measures, in the first column, RSS after importing a library and reading
the fixture, and in the second column, increases in RSS after repeatedly
calling loads() on the fixture.","import library
read fixture
call loads() on fixture"
"The above was measured using Python 3.8.3 on Linux (x86_64) with
orjson 3.3.0, ujson 3.0.0, python-rapidson 0.9.1, and simplejson 3.17.2.","use Python 3.8.3 with python-rapidson 0.9.1
use Python 3.8.3 with simplejson 3.17.2
use Python 3.8.3 with orjson 3.3.0
use Python 3.8.3 with ujson 3.0.0
use Python 3.8.3 on Linux"
"The latency results can be reproduced using the pybench and graph
scripts. The memory results can be reproduced using the pymem script.","use pybench graph scripts
use pymem script"
"Probably pip needs to be upgraded to version 20.3 or later to support
the latest manylinux_x_y or universal2 wheel formats.","support latest manylinux_x_y
support universal2 wheel formats"
"The project's own CI tests against nightly-2021-08-17 and stable 1.54. It
is prudent to pin the nightly version because that channel can introduce
breaking changes.","introduce breaking changes"
"orjson's tests are included in the source distribution on PyPI. The
requirements to run the tests are specified in test/requirements.txt. The
tests should be run as part of the build. It can be run with
pytest -q test.","include tests in source distribution
run tests
specify requirements in test/requirements.txt
run tests
run  with pytest"
"orjson was written by ijl <ijl@mailbox.org>, copyright 2018 - 2021, licensed
under both the Apache 2 and MIT licenses.","write orjson"
