Paragraph,Example,Page
"Another way to run TokensRegex rules is to use the TokensRegexAnnotator. For instance you might want to run a full StanfordCoreNLP pipeline, but run named entity recogntion with TokensRegex rules. This can be achieved with the tokensregex annotator.","java -Xmx2g edu.stanford.nlp.pipeline.StanfordCoreNLP -annotators tokenize,ssplit,pos,lemma,tokensregex -tokensregex.rules basic_ner.rules -file example.txt -outputFormat text",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
"If you run this command, it will run the TokensRegex rules of basic_ner.rules as part of the pipeline when the tokensregex annotator runs.","package edu.stanford.nlp.examples;

import edu.stanford.nlp.ling.*;
import edu.stanford.nlp.pipeline.*;
import edu.stanford.nlp.util.*;
import java.util.List;
import java.util.Properties;

public class TokensRegexAnnotatorDemo {

  // key for matched expressions
  public static class MyMatchedExpressionAnnotation implements CoreAnnotation<List<CoreMap>> {
    @Override
    public Class<List<CoreMap>> getType() {
      return ErasureUtils.<Class<List<CoreMap>>> uncheckedCast(String.class);
    }
  }

  public static void main(String[] args) throws ClassNotFoundException {
    // set properties
    Properties props = new Properties();
    props.setProperty(""annotators"", ""tokenize,ssplit,pos,lemma,tokensregex"");
    props.setProperty(""tokensregex.rules"", ""basic_ner.rules"");
    props.setProperty(""tokensregex.matchedExpressionsAnnotationKey"",
        ""edu.stanford.nlp.examples.TokensRegexAnnotatorDemo$MyMatchedExpressionAnnotation"");
    // build pipeline
    StanfordCoreNLP pipeline = new StanfordCoreNLP(props);
    // annotate
    Annotation ann = new Annotation(""There will be a big announcement by Apple Inc today at 5:00pm.  "" +
        ""She has worked at Miller Corp. for 5 years."");
    pipeline.annotate(ann);
    // show results
    System.out.println(""---"");
    System.out.println(""tokens\n"");
    for (CoreMap sentence : ann.get(CoreAnnotations.SentencesAnnotation.class)) {
      for (CoreLabel token : sentence.get(CoreAnnotations.TokensAnnotation.class)) {
        System.out.println(token.word() + ""\t"" + token.ner());
      }
      System.out.println("""");
    }
    System.out.println(""---"");
    System.out.println(""matched expressions\n"");
    for (CoreMap me : ann.get(MyMatchedExpressionAnnotation.class)) {
      System.out.println(me);
    }
  }
}",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
The most common type of rule is the “tokens” rule. This rule type searches for patterns over a list of tokens.,"{ ruleType: ""tokens"", pattern: ([{word:""I""}] [{word:/like|love/} & {tag:""VBP""}] ([{word:""pizza""}])), action: Annotate($1, ner, ""FOOD""), result: ""PIZZA"" }",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
"To show more functionality, we will also add the constraint that the non-ending tokens in the pattern have to have the part of speech tag “NNP”.","# make all patterns case-sensitive
ENV.defaultStringMatchFlags = 0
ENV.defaultStringPatternFlags = 0

# these Java classes will be used by the rules
ner = { type: ""CLASS"", value: ""edu.stanford.nlp.ling.CoreAnnotations$NamedEntityTagAnnotation"" }
tokens = { type: ""CLASS"", value: ""edu.stanford.nlp.ling.CoreAnnotations$TokensAnnotation"" }

# define some regexes over tokens
$COMPANY_BEGINNING = ""/[A-Z][A-Za-z]+/""
$COMPANY_ENDING = ""/(Corp|Inc)\.?/""

# rule for recognizing company names
{ ruleType: ""tokens"", pattern: ([{word:$COMPANY_BEGINNING} & {tag:""NNP""}]+ [{word:$COMPANY_ENDING}]), action: Annotate($0, ner, ""COMPANY""), result: ""COMPANY_RESULT"" }",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
If you run this TokensRegex pipeline on this file basic_ner.txt:,"She has worked at Miller Corp. for 5 years.
There will be a big announcement by Apple Inc today at 5:00pm.
He works for apple inc in cupertino.",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
And run this Java command:,"java -Xmx2g edu.stanford.nlp.examples.TokensRegexDemo -annotators tokenize,ssplit,pos -rulesFiles basic_ner.rules -inputText basic_ner.txt",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
"Note: in this command we are only running tokenize,ssplit,pos so the CoreLabels will have “null” for the NER token unless our rules find patterns in the input sentences. Also remember that the Java code specifies to create sentences based on newlines, so the input file is interpreted as one-sentence-per-line.","---
sentence number: 0
sentence text: She has worked at Miller Corp. for 5 years.
She		PRP	null
has		VBZ	null
worked		VBN	null
at		IN	null
Miller		NNP	COMPANY
Corp.		NNP	COMPANY
for		IN	null
5		CD	null
years		NNS	null
.		.	null

matched expression: Miller Corp.
matched expression value: STRING(COMPANY_RESULT)
matched expression char offsets: (18,30)
matched expression tokens:[Miller-5, Corp.-6]
---
sentence number: 1
sentence text: There will be a big announcement by Apple Inc today at 5:00pm.
There		EX	null
will		MD	null
be		VB	null
a		DT	null
big		JJ	null
announcement		NN	null
by		IN	null
Apple		NNP	COMPANY
Inc		NNP	COMPANY
today		NN	null
at		IN	null
5:00		CD	null
pm		NN	null
.		.	null

matched expression: Apple Inc
matched expression value: STRING(COMPANY_RESULT)
matched expression char offsets: (80,89)
matched expression tokens:[Apple-8, Inc-9]
---
sentence number: 2
sentence text: He works for apple inc in cupertino.
He		PRP	null
works		VBZ	null
for		IN	null
apple		NN	null
inc		NN	null
in		IN	null
cupertino		NN	null
.		.	null",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
"In the second phase, we will build on named entity tags that were applied in the first phase. Every time we see a sequence of JOB_TITLE_MODIFIER’s ending in a JOB_TITLE_BASE we will mark all of those tokens as a COMPLETE_JOB_TITLE.","# uncomment to make all patterns case-insensitive in the rules file
# ENV.defaultStringMatchFlags = 66
# ENV.defaultStringPatternFlags = 66

# these Java classes will be used by the rules
ner = { type: ""CLASS"", value: ""edu.stanford.nlp.ling.CoreAnnotations$NamedEntityTagAnnotation"" }
tokens = { type: ""CLASS"", value: ""edu.stanford.nlp.ling.CoreAnnotations$TokensAnnotation"" }

# variables for complex regexes
$JOB_TITLE_BASES = ""/president|secretary|general/""
$JOB_TITLE_MODIFIERS = ""/vice|assistant|deputy/""

# first phase identifies components of job titles
# a TokensRegex pipeline can run various stages
# to specify a particular stage, set ENV.defaults[""stage""] to the stage number
ENV.defaults[""stage""] = 1

# tokens match phase
{ ruleType: ""tokens"", pattern: ([{word:$JOB_TITLE_MODIFIERS}]+), action: Annotate($0, ner, ""JOB_TITLE_MODIFIER"") }
{ ruleType: ""tokens"", pattern: ([{word:$JOB_TITLE_BASES}]), action: Annotate($0, ner, ""JOB_TITLE_BASE"") }

# second phase identifies complete job titles from components found in first phase
ENV.defaults[""stage""] = 2
{ ruleType: ""tokens"", pattern: ([{ner: ""JOB_TITLE_MODIFIER""}]+ [{ner: ""JOB_TITLE_BASE""}]), 
  action: Annotate($0, ner, ""COMPLETE_JOB_TITLE""), result: ""FOUND_COMPLETE_JOB_TITLE""}

# third phase is a filter phase, and it removes matched expressions that the filter matches
ENV.defaults[""stage""] = 3
# clean up component named entity tags from stage 1
{ ruleType: ""tokens"", pattern: ([{ner:""JOB_TITLE_MODIFIER""} | {ner:""JOB_TITLE_BASE""}]+), action: Annotate($0, ner, ""O"") }
# filter out the matched expression ""deputy vice president""
{ ruleType: ""filter"", pattern: ([{word:""deputy""}] [{word:""vice""}] [{word:""president""}]) }",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
You can run this for yourself with this command:,"java -Xmx2g edu.stanford.nlp.examples.TokensRegexDemo -annotators tokenize,ssplit,pos,lemma,ner -rulesFiles multi_step_ner.rules -inputText multi_step_ner.txt",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
If you run it on this example file multi_step_ner.txt,"He is the vice president.
He is the assistant vice president.
He is the deputy vice president.
He is the president.
He is the President.",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
You should get this output:,"---
sentence number: 0
sentence text: He is the vice president.
He		PRP	O
is		VBZ	O
the		DT	O
vice		NN	COMPLETE_JOB_TITLE
president		NN	COMPLETE_JOB_TITLE
.		.	O

matched expression: vice president
matched expression value: STRING(FOUND_COMPLETE_JOB_TITLE)
matched expression char offsets: (10,24)
matched expression tokens:[vice-4, president-5]
---
sentence number: 1
sentence text: He is the assistant vice president.
He		PRP	O
is		VBZ	O
the		DT	O
assistant		JJ	COMPLETE_JOB_TITLE
vice		NN	COMPLETE_JOB_TITLE
president		NN	COMPLETE_JOB_TITLE
.		.	O

matched expression: assistant vice president
matched expression value: STRING(FOUND_COMPLETE_JOB_TITLE)
matched expression char offsets: (36,60)
matched expression tokens:[assistant-4, vice-5, president-6]
---
sentence number: 2
sentence text: He is the deputy vice president.
He		PRP	O
is		VBZ	O
the		DT	O
deputy		NN	COMPLETE_JOB_TITLE
vice		NN	COMPLETE_JOB_TITLE
president		NN	COMPLETE_JOB_TITLE
.		.	O
---
sentence number: 3
sentence text: He is the president.
He		PRP	O
is		VBZ	O
the		DT	O
president		NN	O
.		.	O
---
sentence number: 4
sentence text: He is the President.
He		PRP	O
is		VBZ	O
the		DT	O
President		NNP	O
.		.	O",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
"If the pattern is found, we will get a MatchedExpression which will contain a list of tokens. This could be useful if you wanted to find quoted text and then work on the tokens of the quote.","# example rule matching over text instead of tokens
# this is a Java regular expression that matches a quotation mark followed by characters ending with a quotation mark
# it returns a value of the String ""QUOTE"" to the MatchedExpression
{ text: /"".*""/ => ""QUOTE"" }",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
If you run this command:,"java -Xmx2g edu.stanford.nlp.examples.TokensRegexDemo -annotators tokenize,ssplit,pos,lemma,ner -rulesFiles basic_quote_extraction.rules -inputText basic_quote_extraction.txt",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
If you run this command:,"John said, ""I thought the pizza was great!""",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
You should get this output:,"---
sentence number: 0
sentence text: John said, ""I thought the pizza was great!""
John		NNP	PERSON
said		VBD	O
,		,	O
``		``	O
I		PRP	O
thought		VBD	O
the		DT	O
pizza		NN	O
was		VBD	O
great		JJ	O
!		.	O
''		''	O

matched expression: ""I thought the pizza was great!""
matched expression value: STRING(QUOTE)
matched expression char offsets: (11,43)
matched expression tokens:[``-4, I-5, thought-6, the-7, pizza-8, was-9, great-10, !-11, ''-12]",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
If you run this command:,"java -Xmx4g edu.stanford.nlp.examples.TokensRegexDemo -annotators tokenize,ssplit,pos,lemma,ner -rulesFiles basic_relation.rules -inputText basic_relation.txt",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
If you run this command:,"Joe Smith works for Google.
Jane Smith is employed by Apple.",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
You should get this output:,"---
sentence number: 0
sentence text: Joe Smith works for Google.
Joe		NNP	PERSON
Smith		NNP	PERSON
works		VBZ	O
for		IN	O
Google		NNP	ORGANIZATION
.		.	O

matched expression: Joe Smith works for Google
matched expression value: STRING((Joe Smith,works_for,Google))
matched expression char offsets: (0,26)
matched expression tokens:[Joe-1, Smith-2, works-3, for-4, Google-5]
---
sentence number: 1
sentence text: Jane Smith is employed by Apple.
Jane		NNP	PERSON
Smith		NNP	PERSON
is		VBZ	O
employed		VBN	O
by		IN	O
Apple		NNP	ORGANIZATION
.		.	O

matched expression: Jane Smith is employed by Apple
matched expression value: STRING((Jane Smith,works_for,Apple))
matched expression char offsets: (28,59)
matched expression tokens:[Jane-1, Smith-2, is-3, employed-4, by-5, Apple-6]",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
The composite rules are run over and over again until nothing changes. Matched expressions are replaced with an aggregate token which represents the whole matched expression.,"# initial 
# (7 tokens) [""("", ""5"", ""+"", ""5"", "")"", ""+"", ""5""]
(5 + 5) + 5
# first run of composite rules, after first rule 
# ""5 + 5"" is matched and replaced with aggregate_token[""5 + 5"", 10]
# (5 tokens) [""("", aggregrate_token[""5 + 5"", 10], "")"", ""+"", ""5""]
(aggregate_token[""5 + 5"", 10]) + 5
# first run of composite rules, after second rule
# ""(aggregate_token[""5 + 5"", 10])"" is matched, given value of 10 which is same as internal expression
# (3 tokens) [aggregate_token[""(aggregate_token[""5 + 5"", 10])"", 10], ""+"", ""5""]
aggregate_token[""(aggregate_token[""5 + 5"", 10])"", 10] + 5
# second run of composite rules, after first rule
# aggregate_token[""(aggregate_token[""5 + 5"", 10])"", 10] + 5 is matched, given value of 15
# (1 token) [aggregate_token[""aggregate_token[""(aggregate_token[""5 + 5"", 10])"", 10] + 5"", 15]]
aggregate_token[""aggregate_token[""(aggregate_token[""5 + 5"", 10])"", 10] + 5"", 15]
# second run of composite rules, after second rule
# (1 token) [aggregate_token[""aggregate_token[""(aggregate_token[""5 + 5"", 10])"", 10] + 5"", 15]]
aggregate_token[""aggregate_token[""(aggregate_token[""5 + 5"", 10])"", 10] + 5"", 15]
# third run of composite rules, after first rule
# (1 token) [aggregate_token[""aggregate_token[""(aggregate_token[""5 + 5"", 10])"", 10] + 5"", 15]]
aggregate_token[""aggregate_token[""(aggregate_token[""5 + 5"", 10])"", 10] + 5"", 15]
# third run of composite rules, after second rule
# (1 token) [aggregate_token[""aggregate_token[""(aggregate_token[""5 + 5"", 10])"", 10] + 5"", 15]]
aggregate_token[""aggregate_token[""(aggregate_token[""5 + 5"", 10])"", 10] + 5"", 15]
# no change detected after third run of all composite rules, so the composite phase ends",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
The composite rules are run over and over again until nothing changes. Matched expressions are replaced with an aggregate token which represents the whole matched expression.,"orig = { type: ""CLASS"", value: ""edu.stanford.nlp.ling.CoreAnnotations$OriginalTextAnnotation"" }
numtokens = { type: ""CLASS"", value: ""edu.stanford.nlp.ling.CoreAnnotations$NumerizedTokensAnnotation"" }
numcomptype = { type: ""CLASS"", value: ""edu.stanford.nlp.ling.CoreAnnotations$NumericCompositeTypeAnnotation"" }
numcompvalue = { type: ""CLASS"", value: ""edu.stanford.nlp.ling.CoreAnnotations$NumericCompositeValueAnnotation"" }

mytokens = { type: ""CLASS"", value: ""edu.stanford.nlp.examples.TokensRegexDemo$MyTokensAnnotation"" }
type = { type: ""CLASS"", value: ""edu.stanford.nlp.examples.TokensRegexDemo$MyTypeAnnotation"" }
value = { type: ""CLASS"", value: ""edu.stanford.nlp.examples.TokensRegexDemo$MyValueAnnotation"" }

ENV.defaultResultAnnotationKey = ( type, value )
ENV.defaultNestedResultsAnnotationKey = mytokens
ENV.defaults[""stage.limitIters""] = 0

// Numbers
{ ruleType: ""tokens"", pattern: ( [ numcomptype:""NUMBER"" ] ), result: ( ""EXPR"", $0[0].numcompvalue ) }

// Operators
{ pattern: ( ""+"" ),            result: ( ""OP"", ""Add"" ),      priority: 1}
{ pattern: ( /plus/ ),         result: ( ""OP"", ""Add"" ),      priority: 1}
{ pattern: ( ""-"" ),            result: ( ""OP"", ""Subtract"" ), priority: 1}
{ pattern: ( /minus/ ),        result: ( ""OP"", ""Subtract"" ), priority: 1}
{ pattern: ( ""*"" ),            result: ( ""OP"", ""Multiply"" ), priority: 2}
{ pattern: ( /times/ ),        result: ( ""OP"", ""Multiply"" ), priority: 2}
{ pattern: ( ""/"" ),            result: ( ""OP"", ""Divide"" ),   priority: 2}
{ pattern: ( /divided/ /by/ ), result: ( ""OP"", ""Divide"" ),   priority: 2}
{ pattern: ( ""^"" ),            result: ( ""OP"", ""Pow"" ),      priority: 3}

$OP = ( [ type:""OP"" ] )
$EXPR = ( [ type:""EXPR"" ] )

{ ruleType: ""composite"", pattern: ( ($EXPR) ($OP) ($EXPR) ), result: (""EXPR"", Call($2[0].value, $1[0].value, $3[0].value)) }

{ ruleType: ""composite"", pattern: ( [orig:""(""] ($EXPR) [orig:"")""] ), result: (""EXPR"", $1[0].value) }",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
If you run on this example sentence: math_expression.txt,(5 + 5) + 5,https://stanfordnlp.github.io/CoreNLP/tokensregex.html
If you run on this example sentence: math_expression.txt,"java -Xmx2g edu.stanford.nlp.examples.TokensRegexDemo -annotators tokenize,ssplit,pos,lemma,ner -rulesFiles math_expressions.rules -inputText math_expressions.txt",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
You should get this output:,"---
sentence number: 0
sentence text: (5 + 5) + 5
-LRB-		-LRB-	O
5		CD	NUMBER
+		CC	O
5		CD	NUMBER
-RRB-		-RRB-	O
+		CC	O
5		CD	NUMBER

matched expression: -LRB-5 + 5-RRB- + 5
matched expression value: LIST([STRING(EXPR), NUMBER(15)])
matched expression char offsets: (0,11)
matched expression tokens:[-LRB--1, 5-2, +-3, 5-4, -RRB--5, +-6, 5-7]",https://stanfordnlp.github.io/CoreNLP/tokensregex.html
