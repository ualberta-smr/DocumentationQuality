To install a wheel from PyPI:,"pip install --upgrade ""pip>=20.3"" # manylinux_x_y, universal2 wheel support
pip install --upgrade orjson","pip install --upgrade ""pip>=20.3"" # manylinux_x_y, universal2 wheel support pip install --upgrade orjson",99
"To serialize a subclass or arbitrary types, specify default as a callable that returns a supported type. default may be a function, lambda, or callable class instance. To specify that a type was not handled by default, raise an exception such as TypeError.",">>> import orjson, decimal
>>>
def default(obj):
    if isinstance(obj, decimal.decimal):
        return str(obj)
    raise typeerror

>>> orjson.dumps(decimal.decimal(""0.0842389659712649442845""))
jsonencodeerror: type is not json serializable: decimal.decimal
>>> orjson.dumps(decimal.decimal(""0.0842389659712649442845""), default=default)
b'""0.0842389659712649442845""'
>>> orjson.dumps({1, 2}, default=default)
orjson.jsonencodeerror: type is not json serializable: set",">>> import orjson, decimal >>> def default(obj): if isinstance(obj, decimal.decimal): return str(obj) raise typeerror >>> orjson.dumps(decimal.decimal(""0.0842389659712649442845"")) jsonencodeerror: type is not json serializable: decimal.decimal >>> orjson.dumps(decimal.decimal(""0.0842389659712649442845""), default=default) b'""0.0842389659712649442845""' >>> orjson.dumps({1, 2}, default=default) orjson.jsonencodeerror: type is not json serializable: set",97
"It is important that default raise an exception if a type cannot be handled. Python otherwise implicitly returns None, which appears to the caller like a legitimate value and is serialized:",">>> import orjson, json, rapidjson
>>>
def default(obj):
    if isinstance(obj, decimal.decimal):
        return str(obj)

>>> orjson.dumps({""set"":{1, 2}}, default=default)
b'{""set"":null}'
>>> json.dumps({""set"":{1, 2}}, default=default)
'{""set"":null}'
>>> rapidjson.dumps({""set"":{1, 2}}, default=default)
'{""set"":null}'",">>> import orjson, json, rapidjson >>> def default(obj): if isinstance(obj, decimal.decimal): return str(obj) >>> orjson.dumps({""set"":{1, 2}}, default=default) b'{""set"":null}' >>> json.dumps({""set"":{1, 2}}, default=default) '{""set"":null}' >>> rapidjson.dumps({""set"":{1, 2}}, default=default) '{""set"":null}'",96
Pretty-print output with an indent of two spaces. This is equivalent to indent=2 in the standard library. Pretty printing is slower and the output larger. orjson is the fastest compared library at pretty printing and has much less of a slowdown to pretty print than the standard library does. This option is compatible with all other options.,">>> import orjson
>>> orjson.dumps({""a"": ""b"", ""c"": {""d"": true}, ""e"": [1, 2]})
b'{""a"":""b"",""c"":{""d"":true},""e"":[1,2]}'
>>> orjson.dumps(
    {""a"": ""b"", ""c"": {""d"": true}, ""e"": [1, 2]},
    option=orjson.opt_indent_2
)
b'{\n  ""a"": ""b"",\n  ""c"": {\n    ""d"": true\n  },\n  ""e"": [\n    1,\n    2\n  ]\n}'",">>> import orjson >>> orjson.dumps({""a"": ""b"", ""c"": {""d"": true}, ""e"": [1, 2]}) b'{""a"":""b"",""c"":{""d"":true},""e"":[1,2]}' >>> orjson.dumps( {""a"": ""b"", ""c"": {""d"": true}, ""e"": [1, 2]}, option=orjson.opt_indent_2 ) b'{\n ""a"": ""b"",\n ""c"": {\n ""d"": true\n },\n ""e"": [\n 1,\n 2\n ]\n}'",97
Pretty-print output with an indent of two spaces. This is equivalent to indent=2 in the standard library. Pretty printing is slower and the output larger. orjson is the fastest compared library at pretty printing and has much less of a slowdown to pretty print than the standard library does. This option is compatible with all other options.,">>> import orjson
>>> orjson.dumps({""a"": ""b"", ""c"": {""d"": true}, ""e"": [1, 2]})
b'{""a"":""b"",""c"":{""d"":true},""e"":[1,2]}'
>>> orjson.dumps(
    {""a"": ""b"", ""c"": {""d"": true}, ""e"": [1, 2]},
    option=orjson.opt_indent_2
)
b'{\n  ""a"": ""b"",\n  ""c"": {\n    ""d"": true\n  },\n  ""e"": [\n    1,\n    2\n  ]\n}'","{ ""a"": ""b"", ""c"": { ""d"": true }, ""e"": [ 1, 2 ] }",87
Pretty-print output with an indent of two spaces. This is equivalent to indent=2 in the standard library. Pretty printing is slower and the output larger. orjson is the fastest compared library at pretty printing and has much less of a slowdown to pretty print than the standard library does. This option is compatible with all other options.,">>> import orjson
>>> orjson.dumps({""a"": ""b"", ""c"": {""d"": true}, ""e"": [1, 2]})
b'{""a"":""b"",""c"":{""d"":true},""e"":[1,2]}'
>>> orjson.dumps(
    {""a"": ""b"", ""c"": {""d"": true}, ""e"": [1, 2]},
    option=orjson.opt_indent_2
)
b'{\n  ""a"": ""b"",\n  ""c"": {\n    ""d"": true\n  },\n  ""e"": [\n    1,\n    2\n  ]\n}'",">>> import orjson, datetime >>> orjson.dumps( {""other"": 1, datetime.date(1970, 1, 5): 2, datetime.date(1970, 1, 3): 3}, option=orjson.opt_non_str_keys | orjson.opt_sort_keys ) b'{""1970-01-03"":3,""1970-01-05"":2,""other"":1}'",45
orjson serializes enums natively. Options apply to their values.,">>> import enum, datetime, orjson
>>>
class datetimeenum(enum.enum):
    epoch = datetime.datetime(1970, 1, 1, 0, 0, 0)
>>> orjson.dumps(datetimeenum.epoch)
b'""1970-01-01t00:00:00""'
>>> orjson.dumps(datetimeenum.epoch, option=orjson.opt_naive_utc)
b'""1970-01-01t00:00:00+00:00""'",">>> import enum, datetime, orjson >>> class datetimeenum(enum.enum): epoch = datetime.datetime(1970, 1, 1, 0, 0, 0) >>> orjson.dumps(datetimeenum.epoch) b'""1970-01-01t00:00:00""' >>> orjson.dumps(datetimeenum.epoch, option=orjson.opt_naive_utc) b'""1970-01-01t00:00:00+00:00""'",97
Enums with members that are not supported types can be serialized using default:,">>> import enum, orjson
>>>
class custom:
    def __init__(self, val):
        self.val = val

def default(obj):
    if isinstance(obj, custom):
        return obj.val
    raise typeerror

class customenum(enum.enum):
    one = custom(1)

>>> orjson.dumps(customenum.one, default=default)
b'1'",">>> import enum, orjson >>> class custom: def __init__(self, val): self.val = val def default(obj): if isinstance(obj, custom): return obj.val raise typeerror class customenum(enum.enum): one = custom(1) >>> orjson.dumps(customenum.one, default=default) b'1'",95
"To make a best effort at deserializing bad input, first decode bytes using the replace or lossy argument for errors:",">>> import orjson
>>> orjson.loads(b'""\xed\xa0\x80""')
jsondecodeerror: str is not valid utf-8: surrogates not allowed
>>> orjson.loads(b'""\xed\xa0\x80""'.decode(""utf-8"", ""replace""))
'���'",">>> import orjson >>> orjson.loads(b'""\xed\xa0\x80""') jsondecodeerror: str is not valid utf-8: surrogates not allowed >>> orjson.loads(b'""\xed\xa0\x80""'.decode(""utf-8"", ""replace"")) '���'",98
