Paragraph,Ground truth tasks,Program tasks,Partial Ratio
To install a wheel from PyPI:,install wheel from pypi,install wheel from pypi,100
It raises JSONEncodeError on a str that contains invalid UTF-8.,raise jsonencodeerror on invalid utf-8 str,raise jsonencodeerror on str utf-8,79
It raises JSONEncodeError on circular references.,raise jsonencodeerror on circular references,raise jsonencodeerror on circular references,100
This does not affect datetimes in dict keys if using OPT_NON_STR_KEYS.,use opt_non_str_keys,use opt_non_str_keys,100
The benchmark can be reproduced using the pysort script.,use pysort script,use pysort script,100
orjson serializes enums natively. Options apply to their values.,apply to values,apply  to values,93
The graph above can be reproduced using the pycorrectness script.,use pycorrectness script,use pycorrectness script,100
"orjson supports CPython 3.7, 3.8, 3.9, and 3.10. It distributes x86_64/amd64 and aarch64/armv8 wheels for Linux and macOS. It distributes x86_64/amd64 wheels for Windows. orjson does not support PyPy. Releases follow semantic versioning and serializing a new object type without an opt-in flag is considered a breaking change.",serialize a new object
"orjson supports CPython 3.7, 3.8, 3.9, and 3.10. It distributes x86_64/amd64 and aarch64/armv8 wheels for Linux and macOS. It distributes x86_64/amd64 wheels for Windows. orjson does not support PyPy. Releases follow semantic versioning and serializing a new object type without an opt-in flag is considered a breaking change.",support cpython
"orjson version 3 serializes more types than version 2. Subclasses of str, int, dict, and list are now serialized. This is faster and more similar to the standard library. It can be disabled with orjson.OPT_PASSTHROUGH_SUBCLASS.dataclasses.dataclass instances are now serialized by default and cannot be customized in a default function unless option=orjson.OPT_PASSTHROUGH_DATACLASS is specified. uuid.UUID instances are serialized by default. For any type that is now serialized, implementations in a default function and options enabling them can be removed but do not need to be. There was no change in deserialization.",specify option=orjson.opt_passthrough_dataclass
"orjson version 3 serializes more types than version 2. Subclasses of str, int, dict, and list are now serialized. This is faster and more similar to the standard library. It can be disabled with orjson.OPT_PASSTHROUGH_SUBCLASS.dataclasses.dataclass instances are now serialized by default and cannot be customized in a default function unless option=orjson.OPT_PASSTHROUGH_DATACLASS is specified. uuid.UUID instances are serialized by default. For any type that is now serialized, implementations in a default function and options enabling them can be removed but do not need to be. There was no change in deserialization.",remove implementations in default function
"orjson version 3 serializes more types than version 2. Subclasses of str, int, dict, and list are now serialized. This is faster and more similar to the standard library. It can be disabled with orjson.OPT_PASSTHROUGH_SUBCLASS.dataclasses.dataclass instances are now serialized by default and cannot be customized in a default function unless option=orjson.OPT_PASSTHROUGH_DATACLASS is specified. uuid.UUID instances are serialized by default. For any type that is now serialized, implementations in a default function and options enabling them can be removed but do not need to be. There was no change in deserialization.",remove options enabling default functions
"orjson version 3 serializes more types than version 2. Subclasses of str, int, dict, and list are now serialized. This is faster and more similar to the standard library. It can be disabled with orjson.OPT_PASSTHROUGH_SUBCLASS.dataclasses.dataclass instances are now serialized by default and cannot be customized in a default function unless option=orjson.OPT_PASSTHROUGH_DATACLASS is specified. uuid.UUID instances are serialized by default. For any type that is now serialized, implementations in a default function and options enabling them can be removed but do not need to be. There was no change in deserialization.",remove implementations for type
"To migrate from the standard library, the largest difference is that orjson.dumps returns bytes and json.dumps returns a str. Users with dict objects using non-str keys should specify option=orjson.OPT_NON_STR_KEYS. sort_keys is replaced by option=orjson.OPT_SORT_KEYS. indent is replaced by option=orjson.OPT_INDENT_2 and other levels of indentation are not supported.",replace sort_keys
"To migrate from the standard library, the largest difference is that orjson.dumps returns bytes and json.dumps returns a str. Users with dict objects using non-str keys should specify option=orjson.OPT_NON_STR_KEYS. sort_keys is replaced by option=orjson.OPT_SORT_KEYS. indent is replaced by option=orjson.OPT_INDENT_2 and other levels of indentation are not supported.",specify option=orjson.opt_non_str_keys
"To migrate from the standard library, the largest difference is that orjson.dumps returns bytes and json.dumps returns a str. Users with dict objects using non-str keys should specify option=orjson.OPT_NON_STR_KEYS. sort_keys is replaced by option=orjson.OPT_SORT_KEYS. indent is replaced by option=orjson.OPT_INDENT_2 and other levels of indentation are not supported.",replace indent
"To migrate from the standard library, the largest difference is that orjson.dumps returns bytes and json.dumps returns a str. Users with dict objects using non-str keys should specify option=orjson.OPT_NON_STR_KEYS. sort_keys is replaced by option=orjson.OPT_SORT_KEYS. indent is replaced by option=orjson.OPT_INDENT_2 and other levels of indentation are not supported.",use non-str keys
"To migrate from the standard library, the largest difference is that orjson.dumps returns bytes and json.dumps returns a str. Users with dict objects using non-str keys should specify option=orjson.OPT_NON_STR_KEYS. sort_keys is replaced by option=orjson.OPT_SORT_KEYS. indent is replaced by option=orjson.OPT_INDENT_2 and other levels of indentation are not supported.",migrate library
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize str
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize dict
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize list
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize tuple
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize int
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize float
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize bool
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize dataclasses.dataclass
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize typing.typeddict
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize datetime.date
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize datetime.time
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize uuid.uuid
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize numpy.ndarray
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize none
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",serialize enum.enum
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",support arbitrary types through default
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",specify option orjson.opt_passthrough_subclass
"It raises JSONEncodeError on an unsupported type. This exception message describes the invalid object with the error message Type is not JSON serializable: .... To fix this, specify default.",raise jsonencodeerror on unsupported type
"It raises JSONEncodeError on an unsupported type. This exception message describes the invalid object with the error message Type is not JSON serializable: .... To fix this, specify default.",specify default
"It raises JSONEncodeError on an integer that exceeds 64 bits by default or, with OPT_STRICT_INTEGER, 53 bits.",raise jsonencodeerror on integer
"It raises JSONEncodeError if a dict has a key of a type other than str, unless OPT_NON_STR_KEYS is specified.",raise jsonencodeerror
"It raises JSONEncodeError if a dict has a key of a type other than str, unless OPT_NON_STR_KEYS is specified.",specify opt_non_str_keys
It raises JSONEncodeError if the output of default recurses to handling by default more than 254 levels deep.,raise jsonencodeerror
It raises JSONEncodeError if a tzinfo on a datetime object is unsupported.,raise jsonencodeerror
"To serialize a subclass or arbitrary types, specify default as a callable that returns a supported type. default may be a function, lambda, or callable class instance. To specify that a type was not handled by default, raise an exception such as TypeError.",serialize subclass
"To serialize a subclass or arbitrary types, specify default as a callable that returns a supported type. default may be a function, lambda, or callable class instance. To specify that a type was not handled by default, raise an exception such as TypeError.",serialize arbitrary types
"To serialize a subclass or arbitrary types, specify default as a callable that returns a supported type. default may be a function, lambda, or callable class instance. To specify that a type was not handled by default, raise an exception such as TypeError.",specify default
"To serialize a subclass or arbitrary types, specify default as a callable that returns a supported type. default may be a function, lambda, or callable class instance. To specify that a type was not handled by default, raise an exception such as TypeError.",return supported type
"To serialize a subclass or arbitrary types, specify default as a callable that returns a supported type. default may be a function, lambda, or callable class instance. To specify that a type was not handled by default, raise an exception such as TypeError.",raise exception such as typeerror
The default callable may return an object that itself must be handled by default up to 254 times before an exception is raised.,return object
The default callable may return an object that itself must be handled by default up to 254 times before an exception is raised.,raise exception
"It is important that default raise an exception if a type cannot be handled. Python otherwise implicitly returns None, which appears to the caller like a legitimate value and is serialized:",raise exception
"It is important that default raise an exception if a type cannot be handled. Python otherwise implicitly returns None, which appears to the caller like a legitimate value and is serialized:",return none
"To modify how data is serialized, specify option. Each option is an integer constant in orjson. To specify multiple options, mask them together, e.g., option=orjson.OPT_STRICT_INTEGER | orjson.OPT_NAIVE_UTC.",specify option
"To modify how data is serialized, specify option. Each option is an integer constant in orjson. To specify multiple options, mask them together, e.g., option=orjson.OPT_STRICT_INTEGER | orjson.OPT_NAIVE_UTC.",specify multiple options
"To modify how data is serialized, specify option. Each option is an integer constant in orjson. To specify multiple options, mask them together, e.g., option=orjson.OPT_STRICT_INTEGER | orjson.OPT_NAIVE_UTC.",modify data
rapidjson is blank because it does not support pretty printing. This can be reproduced using the pyindent script.,use pyindent script
ujson is blank for sorting because it segfaults. json is blank because it raises TypeError on attempting to sort before converting all keys to str. rapidjson is blank because it does not support non-str keys. This can be reproduced using the pynonstr script.,convert keys to str
ujson is blank for sorting because it segfaults. json is blank because it raises TypeError on attempting to sort before converting all keys to str. rapidjson is blank because it does not support non-str keys. This can be reproduced using the pynonstr script.,sort before converting
ujson is blank for sorting because it segfaults. json is blank because it raises TypeError on attempting to sort before converting all keys to str. rapidjson is blank because it does not support non-str keys. This can be reproduced using the pynonstr script.,use pynonstr script
Passthrough dataclasses.dataclass instances to default. This allows customizing their output but is much slower.,customize output
Passthrough dataclasses.dataclass instances to default. This allows customizing their output but is much slower.,passthrough dataclasses.dataclass
This does not affect serializing subclasses as dict keys if using OPT_NON_STR_KEYS.,use opt_non_str_keys
"bytes, bytearray, memoryview, and str input are accepted. If the input exists as a memoryview, bytearray, or bytes object, it is recommended to pass these directly rather than creating an unnecessary str object. This has lower memory usage and lower latency.",pass than create unnecessary str object
orjson maintains a cache of map keys for the duration of the process. This causes a net reduction in memory usage by avoiding duplicate strings. The keys must be at most 64 bytes to be cached and 512 entries are stored.,store entries
"It raises JSONDecodeError if given an invalid type or invalid JSON. This includes if the input contains NaN, Infinity, or -Infinity, which the standard library allows, but is not valid JSON.",raise jsondecodeerror
"It is supported to pass all variants of dataclasses, including dataclasses using __slots__, frozen dataclasses, those with optional or default attributes, and subclasses. There is a performance benefit to not using __slots__.",pass variants of dataclasses
"It is supported to pass all variants of dataclasses, including dataclasses using __slots__, frozen dataclasses, those with optional or default attributes, and subclasses. There is a performance benefit to not using __slots__.",use subclasses
"It is supported to pass all variants of dataclasses, including dataclasses using __slots__, frozen dataclasses, those with optional or default attributes, and subclasses. There is a performance benefit to not using __slots__.",use __slots__
"This measures serializing 555KiB of JSON, orjson natively and other libraries using default to serialize the output of dataclasses.asdict(). This can be reproduced using the pydataclass script.",serialize dataclasses.asdict()
"This measures serializing 555KiB of JSON, orjson natively and other libraries using default to serialize the output of dataclasses.asdict(). This can be reproduced using the pydataclass script.",use pydataclass script
"This measures serializing 555KiB of JSON, orjson natively and other libraries using default to serialize the output of dataclasses.asdict(). This can be reproduced using the pydataclass script.",use default
"datetime.datetime supports instances with a tzinfo that is None, datetime.timezone.utc, a timezone instance from the python3.9+ zoneinfo module, or a timezone instance from the third-party pendulum, pytz, or dateutil/arrow libraries.",support instances with tzinfo
"It is faster to have orjson serialize datetime objects than to do so before calling dumps(). If using an unsupported type such as pendulum.datetime, use default.",use unsupported type such as pendulum.datetime
"It is faster to have orjson serialize datetime objects than to do so before calling dumps(). If using an unsupported type such as pendulum.datetime, use default.",use default
To disable serialization of datetime objects specify the option orjson.OPT_PASSTHROUGH_DATETIME.,specify option orjson.opt_passthrough_datetime
Enums with members that are not supported types can be serialized using default:,use default
"orjson serializes and deserializes 64-bit integers by default. The range supported is a signed 64-bit integer's minimum (-9223372036854775807) to an unsigned 64-bit integer's maximum (18446744073709551615). This is widely compatible, but there are implementations that only support 53-bits for integers, e.g., web browsers. For those implementations, dumps() can be configured to raise a JSONEncodeError on values exceeding the 53-bit range.",support 53-bits
"orjson serializes and deserializes 64-bit integers by default. The range supported is a signed 64-bit integer's minimum (-9223372036854775807) to an unsigned 64-bit integer's maximum (18446744073709551615). This is widely compatible, but there are implementations that only support 53-bits for integers, e.g., web browsers. For those implementations, dumps() can be configured to raise a JSONEncodeError on values exceeding the 53-bit range.",raise jsonencodeerror on values
"orjson serializes and deserializes 64-bit integers by default. The range supported is a signed 64-bit integer's minimum (-9223372036854775807) to an unsigned 64-bit integer's maximum (18446744073709551615). This is widely compatible, but there are implementations that only support 53-bits for integers, e.g., web browsers. For those implementations, dumps() can be configured to raise a JSONEncodeError on values exceeding the 53-bit range.",configure dumps() for implementations
orjson is faster than all compared libraries at serializing numpy instances. Serializing numpy data requires specifying option=orjson.OPT_SERIALIZE_NUMPY.,compare orjson at serializing
orjson is faster than all compared libraries at serializing numpy instances. Serializing numpy data requires specifying option=orjson.OPT_SERIALIZE_NUMPY.,specify option=orjson.opt_serialize_numpy
"If an array is not a contiguous C array, contains an supported datatype, or contains a numpy.datetime64 using an unsupported representation (e.g., picoseconds), orjson falls through to default. In default, obj.tolist() can be specified. If an array is malformed, which is not expected, orjson.JSONEncodeError is raised.",use unsupported representation
"If an array is not a contiguous C array, contains an supported datatype, or contains a numpy.datetime64 using an unsupported representation (e.g., picoseconds), orjson falls through to default. In default, obj.tolist() can be specified. If an array is malformed, which is not expected, orjson.JSONEncodeError is raised.",specify obj.tolist() in default
"If an array is not a contiguous C array, contains an supported datatype, or contains a numpy.datetime64 using an unsupported representation (e.g., picoseconds), orjson falls through to default. In default, obj.tolist() can be specified. If an array is malformed, which is not expected, orjson.JSONEncodeError is raised.",raise orjson.jsonencodeerror
"In these benchmarks, orjson serializes natively, ujson is blank because it does not support a default parameter, and the other libraries serialize ndarray.tolist() via default. The RSS column measures peak memory usage during serialization. This can be reproduced using the pynumpy script.",use pynumpy script
"orjson does not have an installation or compilation dependency on numpy. The implementation is independent, reading numpy.ndarray using PyArrayInterface.",use pyarrayinterface
"If orjson.dumps() is given a str that does not contain valid UTF-8, orjson.JSONEncodeError is raised. If loads() receives invalid UTF-8, orjson.JSONDecodeError is raised.",raise orjson.jsonencodeerror
"If orjson.dumps() is given a str that does not contain valid UTF-8, orjson.JSONEncodeError is raised. If loads() receives invalid UTF-8, orjson.JSONDecodeError is raised.",raise orjson.jsondecodeerror
"To make a best effort at deserializing bad input, first decode bytes using the replace or lossy argument for errors:",deserialize input
"To make a best effort at deserializing bad input, first decode bytes using the replace or lossy argument for errors:",use replace or lossy argument for errors
The library has comprehensive tests. There are tests against fixtures in the JSONTestSuite and nativejson-benchmark repositories. It is tested to not crash against the Big List of Naughty Strings. It is tested to not leak memory. It is tested to not crash against and not accept invalid UTF-8. There are integration tests exercising the library's use in web servers (gunicorn using multiprocess/forked workers) and when multithreaded. It also uses some tests from the ultrajson library.,test to crash
orjson is the most correct of the compared libraries. This graph shows how each library handles a combined 342 JSON fixtures from the JSONTestSuite and nativejson-benchmark tests:,handle combined 342 json fixtures from nativejson-benchmark tests
orjson is the most correct of the compared libraries. This graph shows how each library handles a combined 342 JSON fixtures from the JSONTestSuite and nativejson-benchmark tests:,handle combined 342 json fixtures from jsontestsuite
"This measures, in the first column, RSS after importing a library and reading the fixture, and in the second column, increases in RSS after repeatedly calling loads() on the fixture.",import library
"This measures, in the first column, RSS after importing a library and reading the fixture, and in the second column, increases in RSS after repeatedly calling loads() on the fixture.",read fixture
"This measures, in the first column, RSS after importing a library and reading the fixture, and in the second column, increases in RSS after repeatedly calling loads() on the fixture.",call loads() on fixture
"The above was measured using Python 3.8.3 on Linux (x86_64) with orjson 3.3.0, ujson 3.0.0, python-rapidson 0.9.1, and simplejson 3.17.2.",use python 3.8.3 with orjson 3.3.0
"The above was measured using Python 3.8.3 on Linux (x86_64) with orjson 3.3.0, ujson 3.0.0, python-rapidson 0.9.1, and simplejson 3.17.2.",use python 3.8.3 with ujson 3.0.0
"The above was measured using Python 3.8.3 on Linux (x86_64) with orjson 3.3.0, ujson 3.0.0, python-rapidson 0.9.1, and simplejson 3.17.2.",use python 3.8.3 with python-rapidson 0.9.1
"The above was measured using Python 3.8.3 on Linux (x86_64) with orjson 3.3.0, ujson 3.0.0, python-rapidson 0.9.1, and simplejson 3.17.2.",use python 3.8.3 with simplejson 3.17.2
The latency results can be reproduced using the pybench and graph scripts. The memory results can be reproduced using the pymem script.,use pybench and graph scripts
The latency results can be reproduced using the pybench and graph scripts. The memory results can be reproduced using the pymem script.,use pymem script
Probably pip needs to be upgraded to version 20.3 or later to support the latest manylinux_x_y or universal2 wheel formats.,support latest manylinux_x_y
Probably pip needs to be upgraded to version 20.3 or later to support the latest manylinux_x_y or universal2 wheel formats.,support universal2 wheel formats
orjson's tests are included in the source distribution on PyPI. The requirements to run the tests are specified in test/requirements.txt. The tests should be run as part of the build. It can be run with pytest -q test.,run with pytest -q test
"orjson is a fast, correct JSON library for Python. It benchmarks as the fastest Python library for JSON and is more correct than the standard json library or other third-party libraries. It serializes dataclass, datetime, numpy, and UUID instances natively.",serialize dataclass
"orjson is a fast, correct JSON library for Python. It benchmarks as the fastest Python library for JSON and is more correct than the standard json library or other third-party libraries. It serializes dataclass, datetime, numpy, and UUID instances natively.",serialize datetime
"orjson is a fast, correct JSON library for Python. It benchmarks as the fastest Python library for JSON and is more correct than the standard json library or other third-party libraries. It serializes dataclass, datetime, numpy, and UUID instances natively.",serialize numpy
"orjson is a fast, correct JSON library for Python. It benchmarks as the fastest Python library for JSON and is more correct than the standard json library or other third-party libraries. It serializes dataclass, datetime, numpy, and UUID instances natively.",serialize uuid instances
"To build a wheel, see packaging.",build a wheel
dumps() serializes Python objects to JSON.,serialize python
Pretty-print output with an indent of two spaces. This is equivalent to indent=2 in the standard library. Pretty printing is slower and the output larger. orjson is the fastest compared library at pretty printing and has much less of a slowdown to pretty print than the standard library does. This option is compatible with all other options.,pretty-print output
This measures serializing the github.json fixture as compact (52KiB) or pretty (64KiB):,measure github.json fixture
"This measures serializing the citm_catalog.json fixture, more of a worst case due to the amount of nesting and newlines, as compact (489KiB) or pretty (1.1MiB):",measure citm_catalog.json fixture
Serialize datetime.datetime objects without a tzinfo as UTC. This has no effect on datetime.datetime objects that have tzinfo set.,serialize datetime.datetime objects
"Serialize dict keys of type other than str. This allows dict keys to be one of str, int, float, bool, None, datetime.datetime, datetime.date, datetime.time, enum.Enum, and uuid.UUID. For comparison, the standard library serializes str, int, float, bool or None by default. orjson benchmarks as being faster at serializing non-str keys than other libraries. This option is slower for str keys than the default.",serialize dict keys
"This measures serializing 589KiB of JSON comprising a list of 100 dict in which each dict has both 365 randomly-sorted int keys representing epoch timestamps as well as one str key and the value for each key is a single integer. In """"str keys"""", the keys were converted to str before serialization, and orjson still specifes option=orjson.OPT_NON_STR_KEYS (which is always somewhat slower).",convert keys to str
"This measures serializing 589KiB of JSON comprising a list of 100 dict in which each dict has both 365 randomly-sorted int keys representing epoch timestamps as well as one str key and the value for each key is a single integer. In """"str keys"""", the keys were converted to str before serialization, and orjson still specifes option=orjson.OPT_NON_STR_KEYS (which is always somewhat slower).",specify option=orjson.opt_non_str_keys
"Passthrough datetime.datetime, datetime.date, and datetime.time instances to default. This allows serializing datetimes to a custom format, e.g., HTTP dates:",passthrough datetime.datetime
"Passthrough datetime.datetime, datetime.date, and datetime.time instances to default. This allows serializing datetimes to a custom format, e.g., HTTP dates:",passthrough datetime.date
"Passthrough datetime.datetime, datetime.date, and datetime.time instances to default. This allows serializing datetimes to a custom format, e.g., HTTP dates:",passthrough datetime.time
"Passthrough datetime.datetime, datetime.date, and datetime.time instances to default. This allows serializing datetimes to a custom format, e.g., HTTP dates:",serialize datetime
"Serialize numpy.ndarray instances. For more, see numpy.",serialize numpy.ndarray
"This is deprecated and has no effect in version 3. In version 2 this was required to serialize uuid.UUID instances. For more, see UUID.",serialize uuid.uuid
Serialize dict keys in sorted order. The default is to serialize in an unspecified order. This is equivalent to sort_keys=True in the standard library.,serialize dict keys
Serialize dict keys in sorted order. The default is to serialize in an unspecified order. This is equivalent to sort_keys=True in the standard library.,sort dict keys
This can be used to ensure the order is deterministic for hashing or tests. It has a substantial performance penalty and is not recommended in general.,ensure deterministic order
This measures serializing the twitter.json fixture unsorted and sorted:,measures twitter.json fixture
This measures serializing the twitter.json fixture unsorted and sorted:,serialize twitter.json 
Serialize a UTC timezone on datetime.datetime instances as Z instead of +00:00.,serialize datetime.datetime
"loads() deserializes JSON to Python objects. It deserializes to dict, list, int, float, str, bool, and None objects.",deserialize json
"Dataclasses are serialized as maps, with every attribute serialized and in the order given on class definition:",serialize dataclasses
"Users may wish to control how dataclass instances are serialized, e.g., to not serialize an attribute or to change the name of an attribute when serialized. orjson may implement support using the metadata mapping on field attributes, e.g., field(metadata={""""json_serialize"""": False}), if use cases are clear.",control dataclass
"To use """"Z"""" suffix instead of """"+00:00"""" to indicate UTC (""""Zulu"""") time, use the option orjson.OPT_UTC_Z.",use option orjson.opt_utc_z
"To assume datetimes without timezone are UTC, se the option orjson.OPT_NAIVE_UTC.",use option orjson.opt_naive_utc
"orjson.dumps() serializes Nan, Infinity, and -Infinity, which are not compliant JSON, as null:",serialize nan
"orjson.dumps() serializes Nan, Infinity, and -Infinity, which are not compliant JSON, as null:",serialize infinity
"orjson.dumps() serializes Nan, Infinity, and -Infinity, which are not compliant JSON, as null:",serialize -infinity
"This measures serializing 92MiB of JSON from an numpy.ndarray with dimensions of (50000, 100) and numpy.float64 values:",serialize numpy.ndarray
"This measures serializing 100MiB of JSON from an numpy.ndarray with dimensions of (100000, 100) and numpy.int32 values:",serialize numpy.ndarray
"This measures serializing 105MiB of JSON from an numpy.ndarray with dimensions of (100000, 200) and numpy.bool values:",serialize numpy.ndarray
"To build on the stable channel, do not specify --features=unstable-simd.",build channel
"This measures serializing 589KiB of JSON comprising a list of 100 dict in which each dict has both 365 randomly-sorted int keys representing epoch timestamps as well as one str key and the value for each key is a single integer. In ""str keys"", the keys were converted to str before serialization, and orjson still specifes option=orjson.OPT_NON_STR_KEYS (which is always somewhat slower).",convert keys before serialization
"This measures serializing 589KiB of JSON comprising a list of 100 dict in which each dict has both 365 randomly-sorted int keys representing epoch timestamps as well as one str key and the value for each key is a single integer. In ""str keys"", the keys were converted to str before serialization, and orjson still specifes option=orjson.OPT_NON_STR_KEYS (which is always somewhat slower).",convert keys to str
"Users may wish to control how dataclass instances are serialized, e.g., to not serialize an attribute or to change the name of an attribute when serialized. orjson may implement support using the metadata mapping on field attributes, e.g., field(metadata={""json_serialize"": False}), if use cases are clear.",change name of attribute
"Users may wish to control how dataclass instances are serialized, e.g., to not serialize an attribute or to change the name of an attribute when serialized. orjson may implement support using the metadata mapping on field attributes, e.g., field(metadata={""json_serialize"": False}), if use cases are clear.",use metadata mapping on field attributes
"To use ""Z"" suffix instead of ""+00:00"" to indicate UTC (""Zulu"") time, use the option orjson.OPT_UTC_Z.",use z suffix
"To use ""Z"" suffix instead of ""+00:00"" to indicate UTC (""Zulu"") time, use the option orjson.OPT_UTC_Z.",use option orjson.opt_utc_z
"orjson supports CPython 3.7, 3.8, 3.9, and 3.10. It distributes x86_64/amd64
and aarch64/armv8 wheels for Linux and macOS. It distributes x86_64/amd64 wheels
for Windows. orjson does not support PyPy. Releases follow semantic
versioning and serializing a new object type without an opt-in flag is
considered a breaking change.",,support cpython
"orjson is licensed under both the Apache 2.0 and MIT licenses. The
repository and issue tracker is
github.com/ijl/orjson, and patches may be
submitted there. There is a
CHANGELOG
available in the repository.",,submit patches
"orjson version 3 serializes more types than version 2. Subclasses of str,
int, dict, and list are now serialized. This is faster and more similar
to the standard library. It can be disabled with
orjson.OPT_PASSTHROUGH_SUBCLASS.dataclasses.dataclass instances
are now serialized by default and cannot be customized in a
default function unless option=orjson.OPT_PASSTHROUGH_DATACLASS is
specified. uuid.UUID instances are serialized by default.
For any type that is now serialized,
implementations in a default function and options enabling them can be
removed but do not need to be. There was no change in deserialization.",,disable  with orjson.opt_passthrough_subclass
"orjson version 3 serializes more types than version 2. Subclasses of str,
int, dict, and list are now serialized. This is faster and more similar
to the standard library. It can be disabled with
orjson.OPT_PASSTHROUGH_SUBCLASS.dataclasses.dataclass instances
are now serialized by default and cannot be customized in a
default function unless option=orjson.OPT_PASSTHROUGH_DATACLASS is
specified. uuid.UUID instances are serialized by default.
For any type that is now serialized,
implementations in a default function and options enabling them can be
removed but do not need to be. There was no change in deserialization.",,specify option = orjson.opt_passthrough_dataclass
"orjson version 3 serializes more types than version 2. Subclasses of str,
int, dict, and list are now serialized. This is faster and more similar
to the standard library. It can be disabled with
orjson.OPT_PASSTHROUGH_SUBCLASS.dataclasses.dataclass instances
are now serialized by default and cannot be customized in a
default function unless option=orjson.OPT_PASSTHROUGH_DATACLASS is
specified. uuid.UUID instances are serialized by default.
For any type that is now serialized,
implementations in a default function and options enabling them can be
removed but do not need to be. There was no change in deserialization.",,remove implementations in default function
"orjson version 3 serializes more types than version 2. Subclasses of str,
int, dict, and list are now serialized. This is faster and more similar
to the standard library. It can be disabled with
orjson.OPT_PASSTHROUGH_SUBCLASS.dataclasses.dataclass instances
are now serialized by default and cannot be customized in a
default function unless option=orjson.OPT_PASSTHROUGH_DATACLASS is
specified. uuid.UUID instances are serialized by default.
For any type that is now serialized,
implementations in a default function and options enabling them can be
removed but do not need to be. There was no change in deserialization.",,remove implementations in options
"orjson version 3 serializes more types than version 2. Subclasses of str,
int, dict, and list are now serialized. This is faster and more similar
to the standard library. It can be disabled with
orjson.OPT_PASSTHROUGH_SUBCLASS.dataclasses.dataclass instances
are now serialized by default and cannot be customized in a
default function unless option=orjson.OPT_PASSTHROUGH_DATACLASS is
specified. uuid.UUID instances are serialized by default.
For any type that is now serialized,
implementations in a default function and options enabling them can be
removed but do not need to be. There was no change in deserialization.",,remove implementations for type
"To migrate from the standard library, the largest difference is that
orjson.dumps returns bytes and json.dumps returns a str. Users with
dict objects using non-str keys should specify
option=orjson.OPT_NON_STR_KEYS. sort_keys is replaced by
option=orjson.OPT_SORT_KEYS. indent is replaced by
option=orjson.OPT_INDENT_2 and other levels of indentation are not
supported.",,use non
"To migrate from the standard library, the largest difference is that
orjson.dumps returns bytes and json.dumps returns a str. Users with
dict objects using non-str keys should specify
option=orjson.OPT_NON_STR_KEYS. sort_keys is replaced by
option=orjson.OPT_SORT_KEYS. indent is replaced by
option=orjson.OPT_INDENT_2 and other levels of indentation are not
supported.",,replace sort_keys
"To migrate from the standard library, the largest difference is that
orjson.dumps returns bytes and json.dumps returns a str. Users with
dict objects using non-str keys should specify
option=orjson.OPT_NON_STR_KEYS. sort_keys is replaced by
option=orjson.OPT_SORT_KEYS. indent is replaced by
option=orjson.OPT_INDENT_2 and other levels of indentation are not
supported.",,replace indent
"It natively serializes
str, dict, list, tuple, int, float, bool,
dataclasses.dataclass, typing.TypedDict, datetime.datetime,
datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and
None instances. It supports arbitrary types through default. It
serializes subclasses of str, int, dict, list,
dataclasses.dataclass, and enum.Enum. It does not serialize subclasses
of tuple to avoid serializing namedtuple objects as arrays. To avoid
serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",,support arbitrary types through default
"It natively serializes
str, dict, list, tuple, int, float, bool,
dataclasses.dataclass, typing.TypedDict, datetime.datetime,
datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and
None instances. It supports arbitrary types through default. It
serializes subclasses of str, int, dict, list,
dataclasses.dataclass, and enum.Enum. It does not serialize subclasses
of tuple to avoid serializing namedtuple objects as arrays. To avoid
serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.",,specify option orjson.opt_passthrough_subclass
"It raises JSONEncodeError on an unsupported type. This exception message
describes the invalid object with the error message
Type is not JSON serializable: .... To fix this, specify
default.",,raise jsonencodeerror on unsupported type
"It raises JSONEncodeError on an unsupported type. This exception message
describes the invalid object with the error message
Type is not JSON serializable: .... To fix this, specify
default.",,specify default
"It raises JSONEncodeError on an integer that exceeds 64 bits by default or,
with OPT_STRICT_INTEGER, 53 bits.",,raise jsonencodeerror on integer
"It raises JSONEncodeError if a dict has a key of a type other than str,
unless OPT_NON_STR_KEYS is specified.",,raise jsonencodeerror
"It raises JSONEncodeError if a dict has a key of a type other than str,
unless OPT_NON_STR_KEYS is specified.",,specify opt_non_str_keys
"It raises JSONEncodeError if the output of default recurses to handling by
default more than 254 levels deep.",,raise jsonencodeerror
"It raises JSONEncodeError if the output of default recurses to handling by
default more than 254 levels deep.",,handle  by default
"It raises JSONEncodeError  if a tzinfo on a datetime object is
unsupported.",,raise jsonencodeerror
"To serialize a subclass or arbitrary types, specify default as a
callable that returns a supported type. default may be a function,
lambda, or callable class instance. To specify that a type was not
handled by default, raise an exception such as TypeError.",,return supported type
"To serialize a subclass or arbitrary types, specify default as a
callable that returns a supported type. default may be a function,
lambda, or callable class instance. To specify that a type was not
handled by default, raise an exception such as TypeError.",,return callable
"To serialize a subclass or arbitrary types, specify default as a
callable that returns a supported type. default may be a function,
lambda, or callable class instance. To specify that a type was not
handled by default, raise an exception such as TypeError.",,raise exception such_as typeerror
"The default callable may return an object that itself
must be handled by default up to 254 times before an exception
is raised.",,return object
"The default callable may return an object that itself
must be handled by default up to 254 times before an exception
is raised.",,raise exception
"It is important that default raise an exception if a type cannot be handled.
Python otherwise implicitly returns None, which appears to the caller
like a legitimate value and is serialized:",,raise exception
"It is important that default raise an exception if a type cannot be handled.
Python otherwise implicitly returns None, which appears to the caller
like a legitimate value and is serialized:",,return none
"To modify how data is serialized, specify option. Each option is an integer
constant in orjson. To specify multiple options, mask them together, e.g.,
option=orjson.OPT_STRICT_INTEGER | orjson.OPT_NAIVE_UTC.",,specify option
"To modify how data is serialized, specify option. Each option is an integer
constant in orjson. To specify multiple options, mask them together, e.g.,
option=orjson.OPT_STRICT_INTEGER | orjson.OPT_NAIVE_UTC.",,specify multiple options
"Pretty-print output with an indent of two spaces. This is equivalent to
indent=2 in the standard library. Pretty printing is slower and the output
larger. orjson is the fastest compared library at pretty printing and has
much less of a slowdown to pretty print than the standard library does. This
option is compatible with all other options.",,indent  in standard library
"rapidjson is blank because it does not support pretty printing. This can be
reproduced using the pyindent script.",,use pyindent script
"This option has the risk of creating duplicate keys. This is because non-str
objects may serialize to the same str as an existing key, e.g.,
{""1"": true, 1: false}. The last key to be inserted to the dict will be
serialized last and a JSON deserializer will presumably take the last
occurrence of a key (in the above, false). The first value will be lost.",,create duplicate keys
"This option has the risk of creating duplicate keys. This is because non-str
objects may serialize to the same str as an existing key, e.g.,
{""1"": true, 1: false}. The last key to be inserted to the dict will be
serialized last and a JSON deserializer will presumably take the last
occurrence of a key (in the above, false). The first value will be lost.",,insert  to dict
"This measures serializing 589KiB of JSON comprising a list of 100 dict
in which each dict has both 365 randomly-sorted int keys representing epoch
timestamps as well as one str key and the value for each key is a
single integer. In ""str keys"", the keys were converted to str before
serialization, and orjson still specifes option=orjson.OPT_NON_STR_KEYS
(which is always somewhat slower).",,convert keys in str keys
"ujson is blank for sorting because it segfaults. json is blank because it
raises TypeError on attempting to sort before converting all keys to str.
rapidjson is blank because it does not support non-str keys. This can
be reproduced using the pynonstr script.",,raise typeerror on attempting
"ujson is blank for sorting because it segfaults. json is blank because it
raises TypeError on attempting to sort before converting all keys to str.
rapidjson is blank because it does not support non-str keys. This can
be reproduced using the pynonstr script.",,convert keys to str
"ujson is blank for sorting because it segfaults. json is blank because it
raises TypeError on attempting to sort before converting all keys to str.
rapidjson is blank because it does not support non-str keys. This can
be reproduced using the pynonstr script.",,sort  before converting
"ujson is blank for sorting because it segfaults. json is blank because it
raises TypeError on attempting to sort before converting all keys to str.
rapidjson is blank because it does not support non-str keys. This can
be reproduced using the pynonstr script.",,use pynonstr script
"Passthrough dataclasses.dataclass instances to default. This allows
customizing their output but is much slower.",,customize output
"This does not affect serializing subclasses as dict keys if using
OPT_NON_STR_KEYS.",,use opt_non_str_keys
"bytes, bytearray, memoryview, and str input are accepted. If the input
exists as a memoryview, bytearray, or bytes object, it is recommended to
pass these directly rather than creating an unnecessary str object. This has
lower memory usage and lower latency.",,pass  than creating
"bytes, bytearray, memoryview, and str input are accepted. If the input
exists as a memoryview, bytearray, or bytes object, it is recommended to
pass these directly rather than creating an unnecessary str object. This has
lower memory usage and lower latency.",,create unnecessary str object
"orjson maintains a cache of map keys for the duration of the process. This
causes a net reduction in memory usage by avoiding duplicate strings. The
keys must be at most 64 bytes to be cached and 512 entries are stored.",,store entries
"It raises JSONDecodeError if given an invalid type or invalid
JSON. This includes if the input contains NaN, Infinity, or -Infinity,
which the standard library allows, but is not valid JSON.",,raise jsondecodeerror
"It is supported to pass all variants of dataclasses, including dataclasses
using __slots__, frozen dataclasses, those with optional or default
attributes, and subclasses. There is a performance benefit to not
using __slots__.",,pass variants of dataclasses
"It is supported to pass all variants of dataclasses, including dataclasses
using __slots__, frozen dataclasses, those with optional or default
attributes, and subclasses. There is a performance benefit to not
using __slots__.",,use subclasses
"It is supported to pass all variants of dataclasses, including dataclasses
using __slots__, frozen dataclasses, those with optional or default
attributes, and subclasses. There is a performance benefit to not
using __slots__.",,use __slots__
"It is supported to pass all variants of dataclasses, including dataclasses
using __slots__, frozen dataclasses, those with optional or default
attributes, and subclasses. There is a performance benefit to not
using __slots__.",,support  including dataclasses
"This measures serializing 555KiB of JSON, orjson natively and other libraries
using default to serialize the output of dataclasses.asdict(). This can be
reproduced using the pydataclass script.",,use default
"This measures serializing 555KiB of JSON, orjson natively and other libraries
using default to serialize the output of dataclasses.asdict(). This can be
reproduced using the pydataclass script.",,use pydataclass script
"Users may wish to control how dataclass instances are serialized, e.g.,
to not serialize an attribute or to change the name of an
attribute when serialized. orjson may implement support using the
metadata mapping on field attributes,
e.g., field(metadata={""json_serialize"": False}), if use cases are clear.",,change name of attribute
"Users may wish to control how dataclass instances are serialized, e.g.,
to not serialize an attribute or to change the name of an
attribute when serialized. orjson may implement support using the
metadata mapping on field attributes,
e.g., field(metadata={""json_serialize"": False}), if use cases are clear.",,implement support
"Users may wish to control how dataclass instances are serialized, e.g.,
to not serialize an attribute or to change the name of an
attribute when serialized. orjson may implement support using the
metadata mapping on field attributes,
e.g., field(metadata={""json_serialize"": False}), if use cases are clear.",,use metadata mapping on field attributes
"datetime.datetime supports instances with a tzinfo that is None,
datetime.timezone.utc, a timezone instance from the python3.9+ zoneinfo
module, or a timezone instance from the third-party pendulum, pytz, or
dateutil/arrow libraries.",,support instances with tzinfo
"It is faster to have orjson serialize datetime objects than to do so
before calling dumps(). If using an unsupported type such as
pendulum.datetime, use default.",,call dumps()
"It is faster to have orjson serialize datetime objects than to do so
before calling dumps(). If using an unsupported type such as
pendulum.datetime, use default.",,use unsupported type such_as pendulum.datetime
"It is faster to have orjson serialize datetime objects than to do so
before calling dumps(). If using an unsupported type such as
pendulum.datetime, use default.",,use default
"To disable serialization of datetime objects specify the option
orjson.OPT_PASSTHROUGH_DATETIME.",,specify option orjson.opt_passthrough_datetime
"To use ""Z"" suffix instead of ""+00:00"" to indicate UTC (""Zulu"") time, use the option
orjson.OPT_UTC_Z.",,use z suffix
"To use ""Z"" suffix instead of ""+00:00"" to indicate UTC (""Zulu"") time, use the option
orjson.OPT_UTC_Z.",,use option orjson.opt_utc_z
"Enums with members that are not supported types can be serialized using
default:",,use default
"orjson serializes and deserializes double precision floats with no loss of
precision and consistent rounding. The same behavior is observed in rapidjson,
simplejson, and json. ujson 1.35 was inaccurate in both serialization and
deserialization, i.e., it modifies the data, and the recent 2.0 release is
accurate.",,modify data
"orjson serializes and deserializes 64-bit integers by default. The range
supported is a signed 64-bit integer's minimum (-9223372036854775807) to
an unsigned 64-bit integer's maximum (18446744073709551615). This
is widely compatible, but there are implementations
that only support 53-bits for integers, e.g.,
web browsers. For those implementations, dumps() can be configured to
raise a JSONEncodeError on values exceeding the 53-bit range.",,support 53-bits web browsers
"orjson serializes and deserializes 64-bit integers by default. The range
supported is a signed 64-bit integer's minimum (-9223372036854775807) to
an unsigned 64-bit integer's maximum (18446744073709551615). This
is widely compatible, but there are implementations
that only support 53-bits for integers, e.g.,
web browsers. For those implementations, dumps() can be configured to
raise a JSONEncodeError on values exceeding the 53-bit range.",,support implementations
"orjson serializes and deserializes 64-bit integers by default. The range
supported is a signed 64-bit integer's minimum (-9223372036854775807) to
an unsigned 64-bit integer's maximum (18446744073709551615). This
is widely compatible, but there are implementations
that only support 53-bits for integers, e.g.,
web browsers. For those implementations, dumps() can be configured to
raise a JSONEncodeError on values exceeding the 53-bit range.",,raise jsonencodeerror on values
"orjson serializes and deserializes 64-bit integers by default. The range
supported is a signed 64-bit integer's minimum (-9223372036854775807) to
an unsigned 64-bit integer's maximum (18446744073709551615). This
is widely compatible, but there are implementations
that only support 53-bits for integers, e.g.,
web browsers. For those implementations, dumps() can be configured to
raise a JSONEncodeError on values exceeding the 53-bit range.",,configure dumps() for implementations
"orjson is faster than all compared libraries at serializing
numpy instances. Serializing numpy data requires specifying
option=orjson.OPT_SERIALIZE_NUMPY.",,compare libraries at serializing
"orjson is faster than all compared libraries at serializing
numpy instances. Serializing numpy data requires specifying
option=orjson.OPT_SERIALIZE_NUMPY.",,compare orjson at serializing
"If an array is not a contiguous C array, contains an supported datatype,
or contains a numpy.datetime64 using an unsupported representation
(e.g., picoseconds), orjson falls through to default. In default,
obj.tolist() can be specified. If an array is malformed, which
is not expected, orjson.JSONEncodeError is raised.",,use unsupported representation
"If an array is not a contiguous C array, contains an supported datatype,
or contains a numpy.datetime64 using an unsupported representation
(e.g., picoseconds), orjson falls through to default. In default,
obj.tolist() can be specified. If an array is malformed, which
is not expected, orjson.JSONEncodeError is raised.",,specify obj.tolist() in default
"If an array is not a contiguous C array, contains an supported datatype,
or contains a numpy.datetime64 using an unsupported representation
(e.g., picoseconds), orjson falls through to default. In default,
obj.tolist() can be specified. If an array is malformed, which
is not expected, orjson.JSONEncodeError is raised.",,raise orjson.jsonencodeerror
"In these benchmarks, orjson serializes natively, ujson is blank because it
does not support a default parameter, and the other libraries serialize
ndarray.tolist() via default. The RSS column measures peak memory
usage during serialization. This can be reproduced using the pynumpy script.",,use pynumpy script
"orjson does not have an installation or compilation dependency on numpy. The
implementation is independent, reading numpy.ndarray using
PyArrayInterface.",,use pyarrayinterface
"If orjson.dumps() is given a str that does not contain valid UTF-8,
orjson.JSONEncodeError is raised. If loads() receives invalid UTF-8,
orjson.JSONDecodeError is raised.",,raise orjson.jsonencodeerror
"If orjson.dumps() is given a str that does not contain valid UTF-8,
orjson.JSONEncodeError is raised. If loads() receives invalid UTF-8,
orjson.JSONDecodeError is raised.",,raise orjson.jsondecodeerror
"To make a best effort at deserializing bad input, first decode bytes using
the replace or lossy argument for errors:",,use replace lossy argument for errors
"The library has comprehensive tests. There are tests against fixtures in the
JSONTestSuite and
nativejson-benchmark
repositories. It is tested to not crash against the
Big List of Naughty Strings.
It is tested to not leak memory. It is tested to not crash
against and not accept invalid UTF-8. There are integration tests
exercising the library's use in web servers (gunicorn using multiprocess/forked
workers) and when
multithreaded. It also uses some tests from the ultrajson library.",,test  to crash
"The library has comprehensive tests. There are tests against fixtures in the
JSONTestSuite and
nativejson-benchmark
repositories. It is tested to not crash against the
Big List of Naughty Strings.
It is tested to not leak memory. It is tested to not crash
against and not accept invalid UTF-8. There are integration tests
exercising the library's use in web servers (gunicorn using multiprocess/forked
workers) and when
multithreaded. It also uses some tests from the ultrajson library.",,use tests from ultrajson library
"orjson is the most correct of the compared libraries. This graph shows how each
library handles a combined 342 JSON fixtures from the
JSONTestSuite and
nativejson-benchmark tests:",,compare libraries
"orjson is the most correct of the compared libraries. This graph shows how each
library handles a combined 342 JSON fixtures from the
JSONTestSuite and
nativejson-benchmark tests:",,handle combined 342 json fixtures from nativejson-benchmark tests
"orjson is the most correct of the compared libraries. This graph shows how each
library handles a combined 342 JSON fixtures from the
JSONTestSuite and
nativejson-benchmark tests:",,handle combined 342 json fixtures from jsontestsuite
"This measures, in the first column, RSS after importing a library and reading
the fixture, and in the second column, increases in RSS after repeatedly
calling loads() on the fixture.",,import library
"This measures, in the first column, RSS after importing a library and reading
the fixture, and in the second column, increases in RSS after repeatedly
calling loads() on the fixture.",,read fixture
"This measures, in the first column, RSS after importing a library and reading
the fixture, and in the second column, increases in RSS after repeatedly
calling loads() on the fixture.",,call loads() on fixture
"The above was measured using Python 3.8.3 on Linux (x86_64) with
orjson 3.3.0, ujson 3.0.0, python-rapidson 0.9.1, and simplejson 3.17.2.",,use python 3.8.3 with python-rapidson 0.9.1
"The above was measured using Python 3.8.3 on Linux (x86_64) with
orjson 3.3.0, ujson 3.0.0, python-rapidson 0.9.1, and simplejson 3.17.2.",,use python 3.8.3 with simplejson 3.17.2
"The above was measured using Python 3.8.3 on Linux (x86_64) with
orjson 3.3.0, ujson 3.0.0, python-rapidson 0.9.1, and simplejson 3.17.2.",,use python 3.8.3 with orjson 3.3.0
"The above was measured using Python 3.8.3 on Linux (x86_64) with
orjson 3.3.0, ujson 3.0.0, python-rapidson 0.9.1, and simplejson 3.17.2.",,use python 3.8.3 with ujson 3.0.0
"The above was measured using Python 3.8.3 on Linux (x86_64) with
orjson 3.3.0, ujson 3.0.0, python-rapidson 0.9.1, and simplejson 3.17.2.",,use python 3.8.3 on linux
"The latency results can be reproduced using the pybench and graph
scripts. The memory results can be reproduced using the pymem script.",,use pybench graph scripts
"The latency results can be reproduced using the pybench and graph
scripts. The memory results can be reproduced using the pymem script.",,use pymem script
"Probably pip needs to be upgraded to version 20.3 or later to support
the latest manylinux_x_y or universal2 wheel formats.",,support latest manylinux_x_y
"Probably pip needs to be upgraded to version 20.3 or later to support
the latest manylinux_x_y or universal2 wheel formats.",,support universal2 wheel formats
"The project's own CI tests against nightly-2021-10-01 and stable 1.54. It
is prudent to pin the nightly version because that channel can introduce
breaking changes.",,test  against nightly-2021-10-01 stable 1.54
"The project's own CI tests against nightly-2021-10-01 and stable 1.54. It
is prudent to pin the nightly version because that channel can introduce
breaking changes.",,introduce breaking changes
"orjson is tested for amd64 and aarch64 on Linux and amd64 on macOS and
Windows. It may not work on 32-bit targets.",,test orjson on linux
"orjson is tested for amd64 and aarch64 on Linux and amd64 on macOS and
Windows. It may not work on 32-bit targets.",,test orjson on amd64
"orjson is tested for amd64 and aarch64 on Linux and amd64 on macOS and
Windows. It may not work on 32-bit targets.",,test orjson on macos
"orjson is tested for amd64 and aarch64 on Linux and amd64 on macOS and
Windows. It may not work on 32-bit targets.",,test orjson on windows
"orjson's tests are included in the source distribution on PyPI. The
requirements to run the tests are specified in test/requirements.txt. The
tests should be run as part of the build. It can be run with
pytest -q test.",,include tests in source distribution
"orjson's tests are included in the source distribution on PyPI. The
requirements to run the tests are specified in test/requirements.txt. The
tests should be run as part of the build. It can be run with
pytest -q test.",,run tests
"orjson's tests are included in the source distribution on PyPI. The
requirements to run the tests are specified in test/requirements.txt. The
tests should be run as part of the build. It can be run with
pytest -q test.",,specify requirements in test/requirements.txt
"orjson's tests are included in the source distribution on PyPI. The
requirements to run the tests are specified in test/requirements.txt. The
tests should be run as part of the build. It can be run with
pytest -q test.",,run tests
"orjson's tests are included in the source distribution on PyPI. The
requirements to run the tests are specified in test/requirements.txt. The
tests should be run as part of the build. It can be run with
pytest -q test.",,run  with pytest
"orjson was written by ijl <ijl@mailbox.org>, copyright 2018 - 2021, licensed
under both the Apache 2 and MIT licenses.",,write orjson
