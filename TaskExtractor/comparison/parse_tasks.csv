Paragraph,Ground truth tasks,Program tasks,Partial Ratio
An iterator that generates parse trees for the sentence.,generate parse trees,generate iterator,71
When possible this list is sorted from most likely to least likely.,sort list,sort list,100
A BllipParser object using the parser and reranker,use parser,use parser,100
A BllipParser object using the parser and reranker,use reranker,use parser,70
A BllipParser object using the parser and reranker,use reranker,use reranker,100
An iterator that generates parse trees for the sentence,generate parse trees,generate iterator,71
An iterator that generates parse trees for the sentence,generate parse trees,generate iterator,71
"If chart or grammar are changed, then the cache is flushed.",flush cache,change chart,36
"If chart or grammar are changed, then the cache is flushed.",flush cache,change grammar,27
"If chart or grammar are changed, then the cache is flushed.",flush cache,flush cache,100
"Add a new edge to the chart, using a pointer to the previous edge.",add new edge to chart,add new edge to chart,100
"Add a new edge to the chart, using a pointer to the previous edge.",use pointer to previous edge,add new edge to chart,38
"Add a new edge to the chart, using a pointer to the previous edge.",use pointer to previous edge,use pointer to previous edge,100
Return the leaf value of the word at the given index.,return leaf value of word,return leaf value of word,100
Return the number of edges contained in this chart.,return number of edges,return number of edges,100
An iterator that generates parse trees for the sentence.,generate parse trees,generate iterator,71
When possible this list is sorted from most likely to least likely.,sort list,sort list,100
Return the chart rule used to generate the most recent edge.,generate recent edge,generate recent edge,100
An iterator that generates parse trees for the sentence.,generate parse trees,generate iterator,71
When possible this list is sorted from most likely to least likely.,sort list,sort list,100
Load a given chart into the chart parser.,loag given chart into chart parser,load given chart into chart parser,97
Change the grammar used by the parser.,change grammar,use  by parser,29
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",redirect corenlp output,redirect corenlp output,100
The text might contain several sentences which will be split by CoreNLP.,split several sentences,split several sentences,100
Return the node with the given address.,return node with given address,return node with given address,100
Convert the data in a nodelist into a networkx labeled directed graph.,convert data into networkx,convert data in nodelist graph,73
Convert the data in a nodelist into a networkx labeled directed graph.,convert data in nodelist,convert data in nodelist graph,100
Return a dot representation suitable for using with Graphviz.,use with graphviz,use  with graphviz,94
grammar – The Grammar used to generate sentences.,generate sentences,generate sentences,100
start – The Nonterminal from which to start generate sentences.,generate sentences,generate sentences,100
This function generates the maltparser command use at the terminal.,generate maltparser command use at terminal,generate maltparser command use at terminal,100
A module to find pre-trained MaltParser model.,find pre-trained maltparser model,find pre-trained maltparser model,100
A module to find MaltParser .jar file and its dependencies.,find maltparser,find maltparser,100
graph (DependencyGraph) – A dependency graph to assign scores to.,assign scores,assign scores,100
An iterator that generates parse trees for the sentence.,generate iterator,generate iterator,100
When possible this list is sorted from most likely to least likely.,sort list,sort list,100
When possible this list is sorted from most likely to least likely.,sort list,sort list,100
When possible this list is sorted from most likely to least likely.,sort list,sort list,100
An iterator that generates parse trees for the sentence.,generate parse trees,generate iterator,71
When possible this list is sorted from most likely to least likely.,sort list,sort list,100
An iterator that generates parse trees for the sentence.,generate parse trees,generate iterator,71
When possible this list is sorted from most likely to least likely.,sort list,sort list,100
Set of arcs: for storing partially built dependency tree,store build dependency tree,store built dependency tree,96
A module to convert a single POS tagged sentence into CONLL format.,convert single pos,convert single pos,100
An iterator that generates parse trees for the sentence.,generate parse trees,generate iterator,71
When possible this list is sorted from most likely to least likely.,sort list,sort list,100
"A processing class for deriving trees that represent possible structures for a sequence of tokens. These tree structures are known as “parses”. Typically, parsers are used to derive syntax trees for sentences. But parsers can also be used to derive other kinds of tree structure, such as morphological trees and discourse structures.",use parser
Interface for parsing with BLLIP Parser. BllipParser objects can be constructed with the BllipParser.from_unified_model_dir class method or manually using the BllipParser constructor.,use bllipparser constructor
Interface for parsing with BLLIP Parser. BllipParser objects can be constructed with the BllipParser.from_unified_model_dir class method or manually using the BllipParser constructor.,use bllipparser objects
Create a BllipParser object from a unified parsing model directory. Unified parsing model directories are a standardized way of storing BLLIP parser and reranker models together on disk. See bllipparser.RerankingParser.get_unified_model_parameters() for more information about unified model directories.,create bllipparser object from unified parsing model directory
Create a BllipParser object from a unified parsing model directory. Unified parsing model directories are a standardized way of storing BLLIP parser and reranker models together on disk. See bllipparser.RerankingParser.get_unified_model_parameters() for more information about unified model directories.,store bllip parser on disk
Create a BllipParser object from a unified parsing model directory. Unified parsing model directories are a standardized way of storing BLLIP parser and reranker models together on disk. See bllipparser.RerankingParser.get_unified_model_parameters() for more information about unified model directories.,store reranker models on disk
"Use BLLIP to parse a sentence. Takes a sentence as a list of (word, tag) tuples; the sentence must have already been tokenized and tagged. BLLIP will attempt to use the tags provided but may use others if it can’t come up with a complete parse subject to those constraints. You may also specify a tag as None to leave a token’s tag unconstrained.",use bllip
"Use BLLIP to parse a sentence. Takes a sentence as a list of (word, tag) tuples; the sentence must have already been tokenized and tagged. BLLIP will attempt to use the tags provided but may use others if it can’t come up with a complete parse subject to those constraints. You may also specify a tag as None to leave a token’s tag unconstrained.",specify tag as none
"Data classes and parser implementations for “chart parsers”, which use dynamic programming to efficiently parse a text. A chart parser derives parse trees for a text by iteratively adding “edges” to a “chart.” Each edge represents a hypothesis about the tree structure for a subsequence of the text. The chart is a “blackboard” for composing and combining these hypotheses.",add edges to chart
"Data classes and parser implementations for “chart parsers”, which use dynamic programming to efficiently parse a text. A chart parser derives parse trees for a text by iteratively adding “edges” to a “chart.” Each edge represents a hypothesis about the tree structure for a subsequence of the text. The chart is a “blackboard” for composing and combining these hypotheses.",compose hypotheses
"Data classes and parser implementations for “chart parsers”, which use dynamic programming to efficiently parse a text. A chart parser derives parse trees for a text by iteratively adding “edges” to a “chart.” Each edge represents a hypothesis about the tree structure for a subsequence of the text. The chart is a “blackboard” for composing and combining these hypotheses.",combine hypotheses
"Data classes and parser implementations for “chart parsers”, which use dynamic programming to efficiently parse a text. A chart parser derives parse trees for a text by iteratively adding “edges” to a “chart.” Each edge represents a hypothesis about the tree structure for a subsequence of the text. The chart is a “blackboard” for composing and combining these hypotheses.",use chart parsers
"When a chart parser begins parsing a text, it creates a new (empty) chart, spanning the text. It then incrementally adds new edges to the chart. A set of “chart rules” specifies the conditions under which new edges should be added to the chart. Once the chart reaches a stage where none of the chart rules adds any new edges, parsing is complete.",create new chart
"When a chart parser begins parsing a text, it creates a new (empty) chart, spanning the text. It then incrementally adds new edges to the chart. A set of “chart rules” specifies the conditions under which new edges should be added to the chart. Once the chart reaches a stage where none of the chart rules adds any new edges, parsing is complete.",add new edges to chart
"When a chart parser begins parsing a text, it creates a new (empty) chart, spanning the text. It then incrementally adds new edges to the chart. A set of “chart rules” specifies the conditions under which new edges should be added to the chart. Once the chart reaches a stage where none of the chart rules adds any new edges, parsing is complete.",specify conditions
"When a chart parser begins parsing a text, it creates a new (empty) chart, spanning the text. It then incrementally adds new edges to the chart. A set of “chart rules” specifies the conditions under which new edges should be added to the chart. Once the chart reaches a stage where none of the chart rules adds any new edges, parsing is complete.",add new edges to chart
"When a chart parser begins parsing a text, it creates a new (empty) chart, spanning the text. It then incrementally adds new edges to the chart. A set of “chart rules” specifies the conditions under which new edges should be added to the chart. Once the chart reaches a stage where none of the chart rules adds any new edges, parsing is complete.",add conditions to chart
"When a chart parser begins parsing a text, it creates a new (empty) chart, spanning the text. It then incrementally adds new edges to the chart. A set of “chart rules” specifies the conditions under which new edges should be added to the chart. Once the chart reaches a stage where none of the chart rules adds any new edges, parsing is complete.",add new edges
"Charts are encoded with the Chart class, and edges are encoded with the TreeEdge and LeafEdge classes. The chart parser module defines three chart parsers:",encode charts with chart class
"Charts are encoded with the Chart class, and edges are encoded with the TreeEdge and LeafEdge classes. The chart parser module defines three chart parsers:",encode edges with treeedge leafedge classes
"Charts are encoded with the Chart class, and edges are encoded with the TreeEdge and LeafEdge classes. The chart parser module defines three chart parsers:",define chart parsers
"ChartParser is a simple and flexible chart parser. Given a set of chart rules, it will apply those rules to the chart until no more edges are added.",apply rules to chart
SteppingChartParser is a subclass of ChartParser that can be used to step through the parsing process.,use subclass of chartparser
"A default implementation for __str__, which returns a name based on the rule’s class name.",return name
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges at time
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return a generator that will add all edges licensed by this rule, given the edges that are currently in the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",return generator
"Return a generator that will add all edges licensed by this rule, given the edges that are currently in the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges
"Return a generator that will add all edges licensed by this rule, given the edges that are currently in the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
A ChartParser using a bottom-up parsing strategy. See ChartParser for more information.,use bottom-up parsing strategy
A ChartParser using a bottom-up left-corner parsing strategy. This strategy is often more efficient than standard bottom-up. See ChartParser for more information.,use bottom-up left-corner parsing strategy
"This is like BottomUpPredictRule, but it also applies the FundamentalRule to the resulting edge.",apply fundamentalrule to resulting edge
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges at time
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges at time
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"A cached version of TopDownPredictRule. After the first time this rule is applied to an edge with a given end and next, it will not generate any more edges for edges with that end and next.",apply rule with next
"A cached version of TopDownPredictRule. After the first time this rule is applied to an edge with a given end and next, it will not generate any more edges for edges with that end and next.",apply rule with given end
"A cached version of TopDownPredictRule. After the first time this rule is applied to an edge with a given end and next, it will not generate any more edges for edges with that end and next.",apply rule to edge
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges at time
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"A blackboard for hypotheses about the syntactic constituents of a sentence. A chart contains a set of edges, and each edge encodes a single hypothesis about the structure of some portion of the sentence.",encode single hypotheses about structure
"The select method can be used to select a specific collection of edges. For example chart.select(is_complete=True, start=0) yields all complete edges whose start indices are 0. To ensure the efficiency of these selection operations, Chart dynamically creates and maintains an index for each set of attributes that have been selected on.",select specific collection of edges
"The select method can be used to select a specific collection of edges. For example chart.select(is_complete=True, start=0) yields all complete edges whose start indices are 0. To ensure the efficiency of these selection operations, Chart dynamically creates and maintains an index for each set of attributes that have been selected on.",use select method
"The select method can be used to select a specific collection of edges. For example chart.select(is_complete=True, start=0) yields all complete edges whose start indices are 0. To ensure the efficiency of these selection operations, Chart dynamically creates and maintains an index for each set of attributes that have been selected on.",create index for set
Return the set of child pointer lists for the given edge. Each child pointer list is a list of edges that have been used to form this edge.,list fo given edge
Return the set of child pointer lists for the given edge. Each child pointer list is a list of edges that have been used to form this edge.,use edges
Return a list of all edges in this chart. New edges that are added to the chart after the call to edges() will not be contained in this list.,return list of edges in chart
"Add a new edge to the chart, and return True if this operation modified the chart. In particular, return true iff the chart did not already contain edge, or if it did not already associate child_pointer_lists with edge.",add new edge to chart
"Add a new edge to the chart, and return True if this operation modified the chart. In particular, return true iff the chart did not already contain edge, or if it did not already associate child_pointer_lists with edge.",modify chart
child_pointer_lists (sequence of tuple(EdgeI)) – A sequence of lists of the edges that were used to form this edge. This list is used to reconstruct the trees (or partial trees) that are associated with edge.,use sequence of lists
Return an iterator over the edges in this chart. It is not guaranteed that new edges which are added to the chart before the iterator is exhausted will also be generated.,return iterator over chart
Return a pretty-printed string representation of a given edge in this chart.,return pretty-printed string representation of given edge
Return a pretty-printed string representation of this chart’s leaves. This string can be used as a header for calls to pretty_format_edge.,use string to pretty_format_edge
Return an iterator over the edges in this chart. Any new edges that are added to the chart before the iterator is exahusted will also be generated. restrictions can be used to restrict the set of edges that will be generated.,return iterator over chart
span – Only generate edges e where e.span()==span,generate edges e
start – Only generate edges e where e.start()==start,generate edges e
end – Only generate edges e where e.end()==end,generate edges e
length – Only generate edges e where e.length()==length,generate edges e
lhs – Only generate edges e where e.lhs()==lhs,generate edges e
rhs – Only generate edges e where e.rhs()==rhs,generate edges e
nextsym – Only generate edges e where e.nextsym()==nextsym,generate edges e
dot – Only generate edges e where e.dot()==dot,generate edges e
is_complete – Only generate edges e where e.is_complete()==is_complete,generate edges e
is_incomplete – Only generate edges e where e.is_incomplete()==is_incomplete,generate edges e
Return an iterator of the tree structures that are associated with edge.,return iterator of tree structures
"If edge is incomplete, then the unexpanded children will be encoded as childless subtrees, whose node value is the corresponding terminal or nonterminal.",encoide unexpanded children as childless subtrees
"If two trees share a common subtree, then the same Tree may be used to encode that subtree in both trees. If you need to eliminate this subtree sharing, then create a deep copy of each tree.",encode subtree in trees
"If two trees share a common subtree, then the same Tree may be used to encode that subtree in both trees. If you need to eliminate this subtree sharing, then create a deep copy of each tree.",create deep copy of tree
"A generic chart parser. A “strategy”, or list of ChartRuleI instances, is used to decide what edges to add to the chart. In particular, ChartParser uses the following algorithm to parse texts:",use strategy of chartrulei instances
"A generic chart parser. A “strategy”, or list of ChartRuleI instances, is used to decide what edges to add to the chart. In particular, ChartParser uses the following algorithm to parse texts:",add to chart
Return the final parse Chart from which all possible parse trees can be extracted.,return final parse chart
"A rule that specifies what new edges are licensed by any given set of existing edges. Each chart rule expects a fixed number of edges, as indicated by the class variable NUM_EDGES. In particular:",specify rule of existing edges
"A chart rule with NUM_EDGES=0 specifies what new edges are licensed, regardless of existing edges.",specify regardless of existing edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return a generator that will add all edges licensed by this rule, given the edges that are currently in the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add all edges licensed by this rule, given the edges that are currently in the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
"A left-hand side, specifying what kind of structure is hypothesized.",specify kind of structure
"A right-hand side, specifying the contents of the hypothesized structure.",specify contents of hypothesized structure
"An edge is incomplete if its structure is partially consistent with the sentence. For every incomplete edge, the span specifies a possible prefix for the edge’s structure.",specify possible prefix for incomplete edge
"Return this edge’s dot position, which indicates how much of the hypothesized structure is consistent with the sentence. In particular, self.rhs[:dot] is consistent with tokens[self.start():self.end()].",return dot position
"Return this edge’s left-hand side, which specifies what kind of structure is hypothesized by this edge.",return left-hand side
"Return this edge’s left-hand side, which specifies what kind of structure is hypothesized by this edge.",specify kind of structure
Return the element of this edge’s right-hand side that immediately follows its dot.,return element of right-hand side
"Return this edge’s right-hand side, which specifies the content of the structure hypothesized by this edge.",return right-hand side
"Return this edge’s right-hand side, which specifies the content of the structure hypothesized by this edge.",specify content of structure
"Return a tuple (s, e), where tokens[s:e] is the portion of the sentence that is consistent with this edge’s structure.",return tuple (s
"Return a tuple (s, e), where tokens[s:e] is the portion of the sentence that is consistent with this edge’s structure.",e)
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return this edge’s dot position, which indicates how much of the hypothesized structure is consistent with the sentence. In particular, self.rhs[:dot] is consistent with tokens[self.start():self.end()].",return dot position
"Return this edge’s left-hand side, which specifies what kind of structure is hypothesized by this edge.",return left-hand side
"Return this edge’s left-hand side, which specifies what kind of structure is hypothesized by this edge.",specify kind of structure
Return the element of this edge’s right-hand side that immediately follows its dot.,return element of right-hand side
"Return this edge’s right-hand side, which specifies the content of the structure hypothesized by this edge.",return right-hand side
"Return this edge’s right-hand side, which specifies the content of the structure hypothesized by this edge.",specify content of structure
"Return a tuple (s, e), where tokens[s:e] is the portion of the sentence that is consistent with this edge’s structure.","return tuple (s, e)"
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"A ChartParser that allows you to step through the parsing process, adding a single edge at a time. It also allows you to change the parser’s strategy or grammar midway through parsing a text.",add single edge at time
"A ChartParser that allows you to step through the parsing process, adding a single edge at a time. It also allows you to change the parser’s strategy or grammar midway through parsing a text.",change strategy
"A ChartParser that allows you to step through the parsing process, adding a single edge at a time. It also allows you to change the parser’s strategy or grammar midway through parsing a text.",change grammar
The initialize method is used to start parsing a text. step adds a single edge to the chart. set_strategy changes the strategy used by the chart parser. parses returns the set of parses that has been found by the chart parser.,add single edge to chart
The initialize method is used to start parsing a text. step adds a single edge to the chart. set_strategy changes the strategy used by the chart parser. parses returns the set of parses that has been found by the chart parser.,change strategy
The initialize method is used to start parsing a text. step adds a single edge to the chart. set_strategy changes the strategy used by the chart parser. parses returns the set of parses that has been found by the chart parser.,return set of parses
"_restart – Records whether the parser’s strategy, grammar, or chart has been changed. If so, then step must restart the parsing algorithm.",change strategy
"_restart – Records whether the parser’s strategy, grammar, or chart has been changed. If so, then step must restart the parsing algorithm.",change chart
"_restart – Records whether the parser’s strategy, grammar, or chart has been changed. If so, then step must restart the parsing algorithm.",restart parsing algorithm
Change the strategy that the parser uses to decide which edges to add to the chart.,change strategy
Change the strategy that the parser uses to decide which edges to add to the chart.,add to chart
strategy (list(ChartRuleI)) – A list of rules that should be used to decide what edges to add to the chart.,add to chart
strategy (list(ChartRuleI)) – A list of rules that should be used to decide what edges to add to the chart.,use rules
"Return a generator that adds edges to the chart, one at a time. Each time the generator is resumed, it adds a single edge and yields that edge. If no more edges can be added, then it yields None.",add edges to chart
"Return a generator that adds edges to the chart, one at a time. Each time the generator is resumed, it adds a single edge and yields that edge. If no more edges can be added, then it yields None.",add single edge
"Return a generator that adds edges to the chart, one at a time. Each time the generator is resumed, it adds a single edge and yields that edge. If no more edges can be added, then it yields None.",add more edges
"If the parser’s strategy, grammar, or chart is changed, then the generator will continue adding edges using the new strategy, grammar, or chart.",use new strategy
"If the parser’s strategy, grammar, or chart is changed, then the generator will continue adding edges using the new strategy, grammar, or chart.",use grammar
"If the parser’s strategy, grammar, or chart is changed, then the generator will continue adding edges using the new strategy, grammar, or chart.",use chart
"If the parser’s strategy, grammar, or chart is changed, then the generator will continue adding edges using the new strategy, grammar, or chart.",change strategy
"If the parser’s strategy, grammar, or chart is changed, then the generator will continue adding edges using the new strategy, grammar, or chart.",change chart
A ChartParser using a top-down parsing strategy. See ChartParser for more information.,use top-down parsing strategy
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"A left-hand side, specifying the hypothesized tree’s node value.",specify hypothesized tree
"A right-hand side, specifying the hypothesized tree’s children. Each element of the right-hand side is either a terminal, specifying a token with that terminal as its leaf value; or a nonterminal, specifying a subtree with that nonterminal’s symbol as its node value.",specify hypothesized tree
"Return this edge’s dot position, which indicates how much of the hypothesized structure is consistent with the sentence. In particular, self.rhs[:dot] is consistent with tokens[self.start():self.end()].",return dot position
"Return this edge’s left-hand side, which specifies what kind of structure is hypothesized by this edge.",return left-hand side
"Return this edge’s left-hand side, which specifies what kind of structure is hypothesized by this edge.",specify kind of structure
"Return a new TreeEdge formed from this edge. The new edge’s dot position is increased by 1, and its end index will be replaced by new_end.",replace end index
Return the element of this edge’s right-hand side that immediately follows its dot.,return element of right-hand side
"Return this edge’s right-hand side, which specifies the content of the structure hypothesized by this edge.",return right-hand side
"Return this edge’s right-hand side, which specifies the content of the structure hypothesized by this edge.",specify content of structure
"Return a tuple (s, e), where tokens[s:e] is the portion of the sentence that is consistent with this edge’s structure.","return tuple (s, e)"
Tools for reading and writing dependency trees. The input is assumed to be in Malt-TAB format (http://stp.lingfil.uu.se/~nivre/research/MaltXML.html).,read dependency trees
Tools for reading and writing dependency trees. The input is assumed to be in Malt-TAB format (http://stp.lingfil.uu.se/~nivre/research/MaltXML.html).,write dependency trees 
Adds an arc from the node specified by head_address to the node specified by the mod address.,add arc from node
Adds an arc from the node specified by head_address to the node specified by the mod address.,specify to node
Fully connects all non-root nodes. All nodes are set to be dependents of the root node.,set nodes
Returns the number of left children under the node specified by the given address.,return number of left children
Returns the number of left children under the node specified by the given address.,return number under node
"rather than 1 (as produced by, e.g., zpar) :param str cell_separator: the cell separator. If not provided, cells are split by whitespace. :param str top_relation_label: the label by which the top relation is identified, for examlple, ROOT, null or TOP.",split cells
Removes the node with the given address. References to this node in others will still exist.,remove node with given address
Returns the number of right children under the node specified by the given address.,return number of right children
Returns the number of right children under the node specified by the given address.,return number under node
"Starting with the root node, build a dependency tree using the NLTK Tree constructor. Dependency labels are omitted.",use nltk tree constructor
"Starting with the root node, build a dependency tree using the NLTK Tree constructor. Dependency labels are omitted.",omit dependency labels
A demonstration of how to read a string representation of a CoNLL format dependency tree.,read string representation of conll
A demonstration of the result of reading a dependency version of the first sentence of the Penn Treebank.,read dependency version of first sentence
"Data classes and parser implementations for incremental chart parsers, which use dynamic programming to efficiently parse a text. A “chart parser” derives parse trees for a text by iteratively adding “edges” to a “chart”. Each “edge” represents a hypothesis about the tree structure for a subsequence of the text. The “chart” is a “blackboard” for composing and combining these hypotheses.",use incremental chart parsers
"Data classes and parser implementations for incremental chart parsers, which use dynamic programming to efficiently parse a text. A “chart parser” derives parse trees for a text by iteratively adding “edges” to a “chart”. Each “edge” represents a hypothesis about the tree structure for a subsequence of the text. The “chart” is a “blackboard” for composing and combining these hypotheses.",add edges to chart
"Data classes and parser implementations for incremental chart parsers, which use dynamic programming to efficiently parse a text. A “chart parser” derives parse trees for a text by iteratively adding “edges” to a “chart”. Each “edge” represents a hypothesis about the tree structure for a subsequence of the text. The “chart” is a “blackboard” for composing and combining these hypotheses.",compose hypothesis
"Data classes and parser implementations for incremental chart parsers, which use dynamic programming to efficiently parse a text. A “chart parser” derives parse trees for a text by iteratively adding “edges” to a “chart”. Each “edge” represents a hypothesis about the tree structure for a subsequence of the text. The “chart” is a “blackboard” for composing and combining these hypotheses.",combine hypotheses
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify new edge
Returns an iterator over the edges in this chart. See Chart.select for more information about the restrictions on the edges.,return iterator over edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
Return a list of all edges in this chart. New edges that are added to the chart after the call to edges() will not be contained in this list.,return list of edges in chart
Return an iterator over the edges in this chart. It is not guaranteed that new edges which are added to the chart before the iterator is exhausted will also be generated.,return iterator over chart
Return an iterator over the edges in this chart. Any new edges that are added to the chart before the iterator is exahusted will also be generated. restrictions can be used to restrict the set of edges that will be generated.,return iterator over edges
Return an iterator over the edges in this chart. Any new edges that are added to the chart before the iterator is exahusted will also be generated. restrictions can be used to restrict the set of edges that will be generated.,use restrictions
span – Only generate edges e where e.span()==span,generate edges e
start – Only generate edges e where e.start()==start,generate edges e
end – Only generate edges e where e.end()==end,generate edges e
length – Only generate edges e where e.length()==length,generate edges e
lhs – Only generate edges e where e.lhs()==lhs,generate edges e
rhs – Only generate edges e where e.rhs()==rhs,generate edges e
nextsym – Only generate edges e where e.nextsym()==nextsym,generate edges e
dot – Only generate edges e where e.dot()==dot,generate edges e
is_complete – Only generate edges e where e.is_complete()==is_complete,generate edges e
is_incomplete – Only generate edges e where e.is_incomplete()==is_incomplete,generate edges e
Return the final parse Chart from which all possible parse trees can be extracted.,return final parse chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
Class for measuring labelled and unlabelled attachment score for dependency parsing. Note that the evaluation ignores punctuation.,ignore punctuation
Extension of chart parsing implementation to handle grammars with feature structures as nodes.,handle grammars with feature structures
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
Returns an iterator over the edges in this chart. See Chart.select for more information about the restrictions on the edges.,return iterator over edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"A specialized version of the completer / single edge fundamental rule that operates on nonterminals whose symbols are ``FeatStructNonterminal``s. Rather than simply comparing the nonterminals for equality, they are unified.",compare nonterminals for equality
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"A specialized version of the (cached) top down predict rule that operates on nonterminals whose symbols are ``FeatStructNonterminal``s. Rather than simply comparing the nonterminals for equality, they are unified.",compare nonterminals for equality
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
A specialized tree edge that allows shared variable bindings between nonterminals on the left-hand side and right-hand side.,share variable bindings between nonterminals
"Each FeatureTreeEdge contains a set of bindings, i.e., a dictionary mapping from variables to values. If the edge is not complete, then these bindings are simply stored. However, if the edge is complete, then the constructor applies these bindings to every nonterminal in the edge whose symbol implements the interface SubstituteBindingsI.",apply  bindings to nonterminal
"A specialized chart that ‘instantiates’ variables whose names start with ‘@’, by replacing them with unique new variables. In particular, whenever a complete edge is added to the chart, any variables in the edge’s lhs whose names start with ‘@’ will be replaced by unique new ``Variable``s.",replace with unique new variables
"Add a new edge to the chart, and return True if this operation modified the chart. In particular, return true iff the chart did not already contain edge, or if it did not already associate child_pointer_lists with edge.",add new edge to chart
"Add a new edge to the chart, and return True if this operation modified the chart. In particular, return true iff the chart did not already contain edge, or if it did not already associate child_pointer_lists with edge.",modify chart
child_pointer_lists (sequence of tuple(EdgeI)) – A sequence of lists of the edges that were used to form this edge. This list is used to reconstruct the trees (or partial trees) that are associated with edge.,use sequence of lists
"If the edge is a FeatureTreeEdge, and it is complete, then instantiate all variables whose names start with ‘@’, by replacing them with unique new variables.",instantiate variables
"If the edge is a FeatureTreeEdge, and it is complete, then instantiate all variables whose names start with ‘@’, by replacing them with unique new variables.",replace with unique new variables
A class for dependency parsing with MaltParser. The input is the paths to: - a maltparser directory - (optionally) the path to a pre-trained MaltParser .mco model file - (optionally) the tagger to use for POS tagging before parsing - (optionally) additional Java arguments,use for pos
"Use MaltParser to parse multiple sentences. Takes a list of sentences, where each sentence is a list of words. Each sentence will be automatically tagged with this MaltParser instance’s tagger.",use maltparser
"Use MaltParser to parse multiple POS tagged sentences. Takes multiple sentences where each sentence is a list of (word, tag) tuples. The sentences must have already been tokenized and tagged.",use maltparser
"scored. :rtype: A three-dimensional list of numbers. :return: The score is returned in a multidimensional(3) list, such that the outer-dimension refers to the head, and the inner-dimension refers to the dependencies. For instance, scores[0][1] would reference the list of scores corresponding to arcs from node 0 to node 1. The node’s ‘address’ field can be used to determine its number identification.",reference list of scores
"scored. :rtype: A three-dimensional list of numbers. :return: The score is returned in a multidimensional(3) list, such that the outer-dimension refers to the head, and the inner-dimension refers to the dependencies. For instance, scores[0][1] would reference the list of scores corresponding to arcs from node 0 to node 1. The node’s ‘address’ field can be used to determine its number identification.",determine number identification
"When used in conjunction with a MaxEntClassifier, each score would correspond to the confidence of a particular edge being classified with the positive training examples.",use with maxentclassifier
"A scorer for calculated the weights on the edges of a weighted dependency graph. This is used by a ProbabilisticNonprojectiveParser to initialize the edge weights of a DependencyGraph. While typically this would be done by training a binary classifier, any class that can return a multidimensional list representation of the edge weights can implement this interface. As such, it has no necessary fields.",calculate weights on edges
"A scorer for calculated the weights on the edges of a weighted dependency graph. This is used by a ProbabilisticNonprojectiveParser to initialize the edge weights of a DependencyGraph. While typically this would be done by training a binary classifier, any class that can return a multidimensional list representation of the edge weights can implement this interface. As such, it has no necessary fields.",initialize edge weights of dependencygraph
"A scorer for calculated the weights on the edges of a weighted dependency graph. This is used by a ProbabilisticNonprojectiveParser to initialize the edge weights of a DependencyGraph. While typically this would be done by training a binary classifier, any class that can return a multidimensional list representation of the edge weights can implement this interface. As such, it has no necessary fields.",return multidimensional list representation of edge weights
"scored. :rtype: A three-dimensional list of numbers. :return: The score is returned in a multidimensional(3) list, such that the outer-dimension refers to the head, and the inner-dimension refers to the dependencies. For instance, scores[0][1] would reference the list of scores corresponding to arcs from node 0 to node 1. The node’s ‘address’ field can be used to determine its number identification.",reference list of scores
"scored. :rtype: A three-dimensional list of numbers. :return: The score is returned in a multidimensional(3) list, such that the outer-dimension refers to the head, and the inner-dimension refers to the dependencies. For instance, scores[0][1] would reference the list of scores corresponding to arcs from node 0 to node 1. The node’s ‘address’ field can be used to determine its number identification.",determine number identification
"When used in conjunction with a MaxEntClassifier, each score would correspond to the confidence of a particular edge being classified with the positive training examples.",use with maxentclassifier
"A dependency scorer built around a MaxEnt classifier. In this particular class that classifier is a NaiveBayesClassifier. It uses head-word, head-tag, child-word, and child-tag features for classification.",use child-tag features
"Converts the graph into a feature-based representation of each edge, and then assigns a score to each based on the confidence of the classifier in assigning it to the positive label. Scores are returned in a multidimensional list.",convert graph into feature-based representation
"Converts the graph into a feature-based representation of each edge, and then assigns a score to each based on the confidence of the classifier in assigning it to the positive label. Scores are returned in a multidimensional list.",assign score
"Converts the graph into a feature-based representation of each edge, and then assigns a score to each based on the confidence of the classifier in assigning it to the positive label. Scores are returned in a multidimensional list.",assign positive label
"Converts the graph into a feature-based representation of each edge, and then assigns a score to each based on the confidence of the classifier in assigning it to the positive label. Scores are returned in a multidimensional list.",return scores in multidimensional list
"Trains a NaiveBayesClassifier using the edges present in graphs list as positive examples, the edges not present as negative examples. Uses a feature vector of head-word, head-tag, child-word, and child-tag.",use edges present list as positive examples
"Trains a NaiveBayesClassifier using the edges present in graphs list as positive examples, the edges not present as negative examples. Uses a feature vector of head-word, head-tag, child-word, and child-tag.",train naivebayesclassifier
"A non-projective, rule-based, dependency parser. This parser will return the set of all possible non-projective parses based on the word-to-word relations defined in the parser’s dependency grammar, and will allow the branches of the parse tree to cross in order to capture a variety of linguistic phenomena that a projective parser will not.",return set of possible non-projective parses
"Parses the input tokens with respect to the parser’s grammar. Parsing is accomplished by representing the search-space of possible parses as a fully-connected directed graph. Arcs that would lead to ungrammatical parses are removed and a lattice is constructed of length n, where n is the number of input tokens, to represent all possible grammatical traversals. All possible paths through the lattice are then enumerated to produce the set of non-projective parses.",produce set of non-projective parses
"Nonprojective dependencies allows for “crossing branches” in the parse tree which is necessary for representing particular linguistic phenomena, or even typical parses in some languages. This parser follows the MST parsing algorithm, outlined in McDonald(2005), which likens the search for the best non-projective parse to finding the maximum spanning tree in a weighted directed graph.",find maximum spanning tree in weighted directed graph
Returns the source of the best incoming arc to the node with address: node_index,return source of best incoming arc
"Takes a list of nodes that have been identified to belong to a cycle, and collapses them into on larger node. The arcs of all nodes in the graph must be updated to account for this.",identify nodes
"Takes a list of nodes that have been identified to belong to a cycle, and collapses them into on larger node. The arcs of all nodes in the graph must be updated to account for this.",collapse list of nodes
When updating scores the score of the highest-weighted incoming arc is subtracted upon collapse. This returns the correct amount to subtract from that edge.,update scores
"As nodes are collapsed into others, they are replaced by the new node in the graph, but it’s still necessary to keep track of what these original nodes were. This takes a list of node addresses and replaces any collapsed node addresses with their original addresses.",replace collapsed node addresses with original addresses
Assigns a score to every edge in the DependencyGraph graph. These scores are generated via the parser’s scorer which was assigned during the training process.,assign score to edge
Assigns a score to every edge in the DependencyGraph graph. These scores are generated via the parser’s scorer which was assigned during the training process.,generate scores via scorer
Assigns a score to every edge in the DependencyGraph graph. These scores are generated via the parser’s scorer which was assigned during the training process.,assign scorer during training process
Parses a list of tokens in accordance to the MST parsing algorithm for non-projective dependency parses. Assumes that the tokens to be parsed have already been tagged and those tags are provided. Various scoring methods can be used by implementing the DependencyScorerI interface and passing it to the training algorithm.,parse list of tokens
Parses a list of tokens in accordance to the MST parsing algorithm for non-projective dependency parses. Assumes that the tokens to be parsed have already been tagged and those tags are provided. Various scoring methods can be used by implementing the DependencyScorerI interface and passing it to the training algorithm.,provide tags
"Trains a DependencyScorerI from a set of DependencyGraph objects, and establishes this as the parser’s scorer. This is used to initialize the scores on a DependencyGraph during the parsing procedure.",initialize scores during parsing procedure
"Trains a DependencyScorerI from a set of DependencyGraph objects, and establishes this as the parser’s scorer. This is used to initialize the scores on a DependencyGraph during the parsing procedure.",initialize scores on dependencygraph
"BottomUpProbabilisticChartParser is an abstract class that implements a bottom-up chart parser for PCFG grammars. It maintains a queue of edges, and adds them to the chart one at a time. The ordering of this queue is based on the probabilities associated with the edges, allowing the parser to expand more likely edges before less likely ones. Each subclass implements a different queue ordering, producing different search strategies. Currently the following subclasses are defined:",implement bottom-up chart parser for pcfg grammars
"An abstract bottom-up parser for PCFG grammars that uses a Chart to record partial results. BottomUpProbabilisticChartParser maintains a queue of edges that can be added to the chart. This queue is initialized with edges for each token in the text that is being parsed. BottomUpProbabilisticChartParser inserts these edges into the chart one at a time, starting with the most likely edges, and proceeding to less likely edges. For each edge that is added to the chart, it may become possible to insert additional edges into the chart; these are added to the queue. This process continues until enough complete parses have been generated, or until the queue is empty.",initialize queue with edges
"An abstract bottom-up parser for PCFG grammars that uses a Chart to record partial results. BottomUpProbabilisticChartParser maintains a queue of edges that can be added to the chart. This queue is initialized with edges for each token in the text that is being parsed. BottomUpProbabilisticChartParser inserts these edges into the chart one at a time, starting with the most likely edges, and proceeding to less likely edges. For each edge that is added to the chart, it may become possible to insert additional edges into the chart; these are added to the queue. This process continues until enough complete parses have been generated, or until the queue is empty.",initialize queue in text
"An abstract bottom-up parser for PCFG grammars that uses a Chart to record partial results. BottomUpProbabilisticChartParser maintains a queue of edges that can be added to the chart. This queue is initialized with edges for each token in the text that is being parsed. BottomUpProbabilisticChartParser inserts these edges into the chart one at a time, starting with the most likely edges, and proceeding to less likely edges. For each edge that is added to the chart, it may become possible to insert additional edges into the chart; these are added to the queue. This process continues until enough complete parses have been generated, or until the queue is empty.",insert additional edges into chart
"An abstract bottom-up parser for PCFG grammars that uses a Chart to record partial results. BottomUpProbabilisticChartParser maintains a queue of edges that can be added to the chart. This queue is initialized with edges for each token in the text that is being parsed. BottomUpProbabilisticChartParser inserts these edges into the chart one at a time, starting with the most likely edges, and proceeding to less likely edges. For each edge that is added to the chart, it may become possible to insert additional edges into the chart; these are added to the queue. This process continues until enough complete parses have been generated, or until the queue is empty.",generate complete parses
The sorting order for the queue is not specified by BottomUpProbabilisticChartParser. Different sorting orders will result in different search strategies. The sorting order for the queue is defined by the method sort_queue; subclasses are required to provide a definition for this method.,define sorting order for queue
"Sort the given queue of Edge objects, placing the edge that should be tried first at the beginning of the queue. This method will be called after each Edge is added to the queue.",sort given queue of edge objects
"Sort the given queue of Edge objects, placing the edge that should be tried first at the beginning of the queue. This method will be called after each Edge is added to the queue.",add edge to queue
queue (list(Edge)) – The queue of Edge objects to sort. Each edge in this queue is an edge that could be added to the chart by the fundamental rule; but that has not yet been added.,add edge to chart
chart (Chart) – The chart being used to parse the text. This chart can be used to provide extra information for sorting the queue.,provide extra information for sorting
chart (Chart) – The chart being used to parse the text. This chart can be used to provide extra information for sorting the queue.,sort queue
Set the level of tracing output that should be generated when parsing a text.,set level of tracing
trace (int) – The trace level. A trace level of 0 will generate no tracing output; and higher trace levels will produce more verbose tracing output.,generate tracing output
trace (int) – The trace level. A trace level of 0 will generate no tracing output; and higher trace levels will produce more verbose tracing output.,produce more verbose
"A bottom-up parser for PCFG grammars that tries edges in descending order of the inside probabilities of their trees. The “inside probability” of a tree is simply the probability of the entire tree, ignoring its context. In particular, the inside probability of a tree generated by production p with children c[1], c[2], …, c[n] is P(p)P(c[1])P(c[2])…P(c[n]); and the inside probability of a token is 1 if it is present in the text, and 0 if it is absent.",ignore context
"Sort the given queue of edges, in descending order of the inside probabilities of the edges’ trees.",sort given queue of edges
chart (Chart) – The chart being used to parse the text. This chart can be used to provide extra information for sorting the queue.,provide extra information for sorting
chart (Chart) – The chart being used to parse the text. This chart can be used to provide extra information for sorting the queue.,sort queue
"Sort the given queue of Edge objects, placing the edge that should be tried first at the beginning of the queue. This method will be called after each Edge is added to the queue.",sort given queue of edge objects
"Sort the given queue of Edge objects, placing the edge that should be tried first at the beginning of the queue. This method will be called after each Edge is added to the queue.",add edge to queue
queue (list(Edge)) – The queue of Edge objects to sort. Each edge in this queue is an edge that could be added to the chart by the fundamental rule; but that has not yet been added.,add edge to chart
chart (Chart) – The chart being used to parse the text. This chart can be used to provide extra information for sorting the queue.,provide extra information for sorting
chart (Chart) – The chart being used to parse the text. This chart can be used to provide extra information for sorting the queue.,sort queue
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Sort the given queue of Edge objects, placing the edge that should be tried first at the beginning of the queue. This method will be called after each Edge is added to the queue.",sort given queue of edge objects
"Sort the given queue of Edge objects, placing the edge that should be tried first at the beginning of the queue. This method will be called after each Edge is added to the queue.",add edge to queue
queue (list(Edge)) – The queue of Edge objects to sort. Each edge in this queue is an edge that could be added to the chart by the fundamental rule; but that has not yet been added.,add edge to chart
chart (Chart) – The chart being used to parse the text. This chart can be used to provide extra information for sorting the queue.,provide extra information for sorting
chart (Chart) – The chart being used to parse the text. This chart can be used to provide extra information for sorting the queue.,sort queue
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add edges to chart
"Return a generator that will add edges licensed by this rule and the given edges to the chart, one at a time. Each time the generator is resumed, it will either add a new edge and yield that edge; or return.",add new edge
edges (list(EdgeI)) – A set of existing edges. The number of edges that should be passed to apply() is specified by the NUM_EDGES class variable.,specify number of edges
"Sort the given queue of Edge objects, placing the edge that should be tried first at the beginning of the queue. This method will be called after each Edge is added to the queue.",sort given queue of edge objects
"Sort the given queue of Edge objects, placing the edge that should be tried first at the beginning of the queue. This method will be called after each Edge is added to the queue.",add edge to queue
queue (list(Edge)) – The queue of Edge objects to sort. Each edge in this queue is an edge that could be added to the chart by the fundamental rule; but that has not yet been added.,add edge to chart
chart (Chart) – The chart being used to parse the text. This chart can be used to provide extra information for sorting the queue.,provide extra information for sorting
chart (Chart) – The chart being used to parse the text. This chart can be used to provide extra information for sorting the queue.,sort queue
"A cell from the parse chart formed when performing the CYK algorithm. Each cell keeps track of its x and y coordinates (though this will probably be discarded), and a list of spans serving as the cell’s entries.",perform cyk algorithm
Appends the given span to the list of spans representing the chart cell’s entries.,append given span to list
"This parser returns the most probable projective parse derived from the probabilistic dependency grammar derived from the train() method. The probabilistic model is an implementation of Eisner’s (1996) Model C, which conditions on head-word, head-tag, child-word, and child-tag. The decoding uses a bottom-up chart-based span concatenation algorithm that’s identical to the one utilized by the rule-based projective parser.",return probable projective parse
"This parser returns the most probable projective parse derived from the probabilistic dependency grammar derived from the train() method. The probabilistic model is an implementation of Eisner’s (1996) Model C, which conditions on head-word, head-tag, child-word, and child-tag. The decoding uses a bottom-up chart-based span concatenation algorithm that’s identical to the one utilized by the rule-based projective parser.",use bottom-up chart based span concatentation algorithm
Computes the probability of a dependency graph based on the parser’s probability model (defined by the parser’s statistical dependency grammar).,compute probability of dependency graph
"Concatenates the two spans in whichever way possible. This includes rightward concatenation (from the leftmost word of the leftmost span to the rightmost word of the rightmost span) and leftward concatenation (vice-versa) between adjacent spans. Unlike Eisner’s presentation of span concatenation, these spans do not share or pivot on a particular word/word-index.",concatenate spans
Parses the list of tokens subject to the projectivity constraint and the productions in the parser’s grammar. This uses a method similar to the span-concatenation algorithm defined in Eisner (1996). It returns the most probable parse derived from the parser’s probabilistic dependency grammar.,retrun probable parse
"A projective, rule-based, dependency parser. A ProjectiveDependencyParser is created with a DependencyGrammar, a set of productions specifying word-to-word dependency relations. The parse() method will then return the set of all parses, in tree representation, for a given input sequence of tokens. Each parse must meet the requirements of the both the grammar and the projectivity constraint which specifies that the branches of the dependency tree are not allowed to cross. Alternatively, this can be understood as stating that each parent node and its children in the parse tree form a continuous substring of the input sequence.",return set in tree representation
"A projective, rule-based, dependency parser. A ProjectiveDependencyParser is created with a DependencyGrammar, a set of productions specifying word-to-word dependency relations. The parse() method will then return the set of all parses, in tree representation, for a given input sequence of tokens. Each parse must meet the requirements of the both the grammar and the projectivity constraint which specifies that the branches of the dependency tree are not allowed to cross. Alternatively, this can be understood as stating that each parent node and its children in the parse tree form a continuous substring of the input sequence.",return set of parses
"A projective, rule-based, dependency parser. A ProjectiveDependencyParser is created with a DependencyGrammar, a set of productions specifying word-to-word dependency relations. The parse() method will then return the set of all parses, in tree representation, for a given input sequence of tokens. Each parse must meet the requirements of the both the grammar and the projectivity constraint which specifies that the branches of the dependency tree are not allowed to cross. Alternatively, this can be understood as stating that each parent node and its children in the parse tree form a continuous substring of the input sequence.",return set for given input sequence
"Concatenates the two spans in whichever way possible. This includes rightward concatenation (from the leftmost word of the leftmost span to the rightmost word of the rightmost span) and leftward concatenation (vice-versa) between adjacent spans. Unlike Eisner’s presentation of span concatenation, these spans do not share or pivot on a particular word/word-index.",concatenate spans
"Performs a projective dependency parse on the list of tokens using a chart-based, span-concatenation algorithm similar to Eisner (1996).",use chart-based span-concatenation algorithm
A demonstration showing the creation of a DependencyGrammar in which a specific number of modifiers is listed for a given head. This can further constrain the number of possible parses created by a ProjectiveDependencyParser.,list specific number of modifiers
A demo showing the training and use of a projective dependency parser.,use projective dependency parser
A demonstration showing the creation and use of a DependencyGrammar to perform a projective dependency parse.,use of dependencygrammer
A demonstration showing the creation and use of a DependencyGrammar to perform a projective dependency parse.,perform projective dependency parse
"A simple top-down CFG parser that parses texts by recursively expanding the fringe of a Tree, and matching it against a text.",expand fringe of tree
"A simple top-down CFG parser that parses texts by recursively expanding the fringe of a Tree, and matching it against a text.",match against text
"When the parser begins parsing a text, it constructs a tree containing only the start symbol, and a frontier containing the location of the tree’s root node. It then extends the tree to cover the text, using the following recursive procedure:",extend tree
"If the frontier is empty, and the text is covered by the tree, then return the tree as a possible parse.",return tree as possible parse
"If the first element of the frontier is a subtree, then use CFG productions to “expand” it. For each applicable production, add the expanded subtree’s children to the frontier, and recursively find all parses that can be generated by the new tree and frontier.",generate parses
"If the first element of the frontier is a token, then “match” it against the next token from the text. Remove the token from the frontier, and recursively find all parses that can be generated by the new tree and frontier.",find parses
"If the first element of the frontier is a token, then “match” it against the next token from the text. Remove the token from the frontier, and recursively find all parses that can be generated by the new tree and frontier.",generate parses
Set the level of tracing output that should be generated when parsing a text.,set level of tracing
trace (int) – The trace level. A trace level of 0 will generate no tracing output; and higher trace levels will produce more verbose tracing output.,generate tracing output
trace (int) – The trace level. A trace level of 0 will generate no tracing output; and higher trace levels will produce more verbose tracing output.,produce more verbose
"The initialize method is used to start parsing a text. expand expands the first element on the frontier using a single CFG production, and match matches the first element on the frontier against the next text token. backtrack undoes the most recent expand or match operation. step performs a single expand, match, or backtrack operation. parses returns the set of parses that have been found by the parser.",use single cfg production
"Return the parser to its state before the most recent match or expand operation. Calling undo repeatedly return the parser to successively earlier states. If no match or expand operations have been performed, undo will make no changes.",return parser before most recent match
"Expand the first element of the frontier. In particular, if the first element of the frontier is a subtree whose node type is equal to production’s left hand side, then add a child to that subtree for each element of production’s right hand side. If production is not specified, then use the first untried expandable production. If all expandable productions have been tried, do nothing.",expand first element of frontier 
"The production used to expand the frontier, if an expansion was performed. If no expansion was performed, return None.",expand frontier
"The production used to expand the frontier, if an expansion was performed. If no expansion was performed, return None.",perform expansion
"The token matched, if a match operation was performed. If no match was performed, return None",perform match operation
"Perform a single parsing operation. If an untried match is possible, then perform the match, and return the matched token. If an untried expansion is possible, then perform the expansion, and return the production that it is based on. If backtracking is possible, then backtrack, and return True. Otherwise, return None.",perform single parsing operation
"Perform a single parsing operation. If an untried match is possible, then perform the match, and return the matched token. If an untried expansion is possible, then perform the expansion, and return the production that it is based on. If backtracking is possible, then backtrack, and return True. Otherwise, return None.",perform match
"Perform a single parsing operation. If an untried match is possible, then perform the match, and return the matched token. If an untried expansion is possible, then perform the expansion, and return the production that it is based on. If backtracking is possible, then backtrack, and return True. Otherwise, return None.",return matched token
"Perform a single parsing operation. If an untried match is possible, then perform the match, and return the matched token. If an untried expansion is possible, then perform the expansion, and return the production that it is based on. If backtracking is possible, then backtrack, and return True. Otherwise, return None.",perform expansion
"Perform a single parsing operation. If an untried match is possible, then perform the match, and return the matched token. If an untried expansion is possible, then perform the expansion, and return the production that it is based on. If backtracking is possible, then backtrack, and return True. Otherwise, return None.",return production
"A simple bottom-up CFG parser that uses two operations, “shift” and “reduce”, to find a single parse for a text.",find single parse for text
"ShiftReduceParser attempts to extend the stack to cover the entire text, and to combine the stack elements into a single tree, producing a complete parse for the sentence.",extend stack 
"ShiftReduceParser attempts to extend the stack to cover the entire text, and to combine the stack elements into a single tree, producing a complete parse for the sentence.",combine stack elements into single tree
"ShiftReduceParser attempts to extend the stack to cover the entire text, and to combine the stack elements into a single tree, producing a complete parse for the sentence.",produce complete parse for sentence
Set the level of tracing output that should be generated when parsing a text.,set level of tracing
trace (int) – The trace level. A trace level of 0 will generate no tracing output; and higher trace levels will produce more verbose tracing output.,generate tracing output
trace (int) – The trace level. A trace level of 0 will generate no tracing output; and higher trace levels will produce more verbose tracing output.,produce more verbose
"A ShiftReduceParser that allows you to setp through the parsing process, performing a single operation at a time. It also allows you to change the parser’s grammar midway through parsing a text.",change grammar
"The initialize method is used to start parsing a text. shift performs a single shift operation, and reduce performs a single reduce operation. step will perform a single reduce operation if possible; otherwise, it will perform a single shift operation. parses returns the set of parses that have been found by the parser.",perform single shift operation
"Perform a single parsing operation. If a reduction is possible, then perform that reduction, and return the production that it is based on. Otherwise, if a shift is possible, then perform it, and return True. Otherwise, return False.",perform single parsing operation
"Perform a single parsing operation. If a reduction is possible, then perform that reduction, and return the production that it is based on. Otherwise, if a shift is possible, then perform it, and return True. Otherwise, return False.",perform reduction
False if no operation was performed; True if a shift was performed; and the CFG production used to reduce if a reduction was performed.,perform shift
"Return the parser to its state before the most recent shift or reduce operation. Calling undo repeatedly return the parser to successively earlier states. If no shift or reduce operations have been performed, undo will make no changes.",return parser before most recent shift
"Return the parser to its state before the most recent shift or reduce operation. Calling undo repeatedly return the parser to successively earlier states. If no shift or reduce operations have been performed, undo will make no changes.",return parser to state
"Use StanfordParser to parse multiple sentences. Takes multiple sentences as a list where each sentence is a list of words. Each sentence will be automatically tagged with this StanfordParser instance’s tagger. If whitespaces exists inside a token, then the token will be treated as separate tokens.",['use stanfordparser']
"Use StanfordParser to parse a sentence. Takes a sentence as a string; before parsing, it will be automatically tokenized and tagged by the Stanford Parser.",['use stanfordparser']
Use StanfordParser to parse multiple sentences. Takes multiple sentences as a list of strings. Each sentence will be automatically tokenized and tagged by the Stanford Parser.,['use stanfordparser']
"Use StanfordParser to parse a sentence. Takes a sentence as a list of (word, tag) tuples; the sentence must have already been tokenized and tagged.",['use stanfordparser']
"Use StanfordParser to parse multiple sentences. Takes multiple sentences where each sentence is a list of (word, tag) tuples. The sentences must have already been tokenized and tagged.",['use stanfordparser']
"Extract the set of features for the current configuration. Implement standard features as describe in Table 3.2 (page 31) in Dependency Parsing book by Sandra Kubler, Ryan McDonal, Joakim Nivre. Please note that these features are very basic. :return: list(str)",extract set of features
"This class defines a set of transition which is applied to a configuration to get another configuration Note that for different parsing algorithm, the transition is different.",apply set of transition
"This class defines a set of transition which is applied to a configuration to get another configuration Note that for different parsing algorithm, the transition is different.",apply set to configuration
:param depgraphs : list of DependencyGraph as the training data :type depgraphs : DependencyGraph :param modelfile : file name to save the trained model :type modelfile : str,save trained model
"The result information is followed by a colon, and then the sentence. Empty lines and lines beginning with a comment char are ignored.",ignore empty lines
"Load a grammar from a file, and build a parser based on that grammar. The parser depends on the grammar format, and might also depend on properties of the grammar itself.",build parser
"Load a grammar from a file, and build a parser based on that grammar. The parser depends on the grammar format, and might also depend on properties of the grammar itself.",load grammar from file
trace (int) – The level of tracing that should be used when parsing a text. 0 will generate no tracing output; and higher numbers will produce more verbose tracing output.,generate tracing output
trace (int) – The level of tracing that should be used when parsing a text. 0 will generate no tracing output; and higher numbers will produce more verbose tracing output.,produce more verbose
"chart_class – The class used for storing the chart; should be Chart or a subclass. Only used for CFGs and feature CFGs. If None, the chart class depends on the grammar format.",store chart
load_args – Keyword parameters used when loading the grammar. See data.load for more information.,load grammar
"A module to convert the a POS tagged document stream (i.e. list of list of tuples, a list of sentences) and yield lines in CONLL format. This module yields one line per word and two newlines for end of sentence.",convert pos
"A bottom-up PCFG parser that uses dynamic programming to find the single most likely parse for a text. The ViterbiParser parser parses texts by filling in a “most likely constituent table”. This table records the most probable tree representation for any given span and node value. In particular, it has an entry for every start index, end index, and node value, recording the most likely subtree that spans from the start index to the end index, and has the given node value.",find single likely parse for text
"A bottom-up PCFG parser that uses dynamic programming to find the single most likely parse for a text. The ViterbiParser parser parses texts by filling in a “most likely constituent table”. This table records the most probable tree representation for any given span and node value. In particular, it has an entry for every start index, end index, and node value, recording the most likely subtree that spans from the start index to the end index, and has the given node value.",fill in likely constituent table
"The ViterbiParser parser fills in this table incrementally. It starts by filling in all entries for constituents that span one element of text (i.e., entries where the end index is one greater than the start index). After it has filled in all table entries for constituents that span one element of text, it fills in the entries for constitutants that span two elements of text. It continues filling in the entries for constituents spanning larger and larger portions of the text, until the entire table has been filled. Finally, it returns the table entry for a constituent spanning the entire text, whose node value is the grammar’s start symbol.",retrun table entry for constituent
"In order to find the most likely constituent with a given span and node value, the ViterbiParser parser considers all productions that could produce that node value. For each production, it finds all children that collectively cover the span and have the node values specified by the production’s right hand side. If the probability of the tree formed by applying the production to the children is greater than the probability of the current entry in the table, then the table is updated with this new tree.",find likely consitituent with given span
"In order to find the most likely constituent with a given span and node value, the ViterbiParser parser considers all productions that could produce that node value. For each production, it finds all children that collectively cover the span and have the node values specified by the production’s right hand side. If the probability of the tree formed by applying the production to the children is greater than the probability of the current entry in the table, then the table is updated with this new tree.",find likely consitituent with node value
"In order to find the most likely constituent with a given span and node value, the ViterbiParser parser considers all productions that could produce that node value. For each production, it finds all children that collectively cover the span and have the node values specified by the production’s right hand side. If the probability of the tree formed by applying the production to the children is greater than the probability of the current entry in the table, then the table is updated with this new tree.",apply production to children
"In order to find the most likely constituent with a given span and node value, the ViterbiParser parser considers all productions that could produce that node value. For each production, it finds all children that collectively cover the span and have the node values specified by the production’s right hand side. If the probability of the tree formed by applying the production to the children is greater than the probability of the current entry in the table, then the table is updated with this new tree.",update table with new tree
Set the level of tracing output that should be generated when parsing a text.,set level of tracing
trace (int) – The trace level. A trace level of 0 will generate no tracing output; and higher trace levels will produce more verbose tracing output.,generate tracing output
trace (int) – The trace level. A trace level of 0 will generate no tracing output; and higher trace levels will produce more verbose tracing output.,produce more verbose
"nltk.parser.chart defines chart parsing, which uses dynamic programming to efficiently parse texts.",define chart parsing
"nltk.parser.probabilistic defines probabilistic parsing, which associates a probability with each parse.",define probabilistic parsing
Use BLLIP Parser to parse a sentence. Takes a sentence as a list of words; it will be automatically tagged with this BLLIP Parser instance’s tagger.,use bllip
Clear the chart.,clear chart
Return a list of the leaf values of each word in the chart’s sentence.,return list of leaf values
"Return an iterator of the complete tree structures that span the entire chart, and whose root node is root.",return iterator of tree structure
Return a pretty-printed string representation of this chart.,return pretty-print representation of chart
A chart rule with NUM_EDGES=1 specifies what new edges are licensed by a single existing edge.,specify by single edge
A chart rule with NUM_EDGES=2 specifies what new edges are licensed by a pair of existing edges.,specify by pair of edges
Return the end index of this edge’s span.,return end index
Return the length of this edge’s span.,return edge span length
Return the start index of this edge’s span.,return start index
Return the end index of this edge’s span.,return end index
Return the length of this edge’s span.,return edge span length
Return the start index of this edge’s span.,return start index
Return the end index of this edge’s span.,return end index
Return the length of this edge’s span.,return edge span length
Return the start index of this edge’s span.,return start index
"Takes a sentence as a string; before parsing, it will be automatically tokenized and tagged by the CoreNLP Parser.",tokenize sentences
"Takes a sentence as a string; before parsing, it will be automatically tokenized and tagged by the CoreNLP Parser.",tag sentence
Takes multiple sentences as a list of strings. Each sentence will be automatically tokenized and tagged.,tokenize sentences
Takes multiple sentences as a list of strings. Each sentence will be automatically tokenized and tagged.,tag sentence
Check whether there are cycles.,check cycles
Redirects arcs to any of the nodes in the originals list to the redirect node address.,redirect node arcs
"Extract dependency triples of the form: ((head word, head tag), rel, (dep word, dep tag))",extract dependency triples
Clear the chart.,clear chart
Return the Labeled Attachment Score (LAS) and Unlabeled Attachment Score (UAS),return labeled attachment score
Return the Labeled Attachment Score (LAS) and Unlabeled Attachment Score (UAS),return unlabeled attachment score
"Return an iterator of the complete tree structures that span the entire chart, and whose root node is root.",return iterator of tree structure
Return a copy of this edge’s bindings dictionary.,return edge bindings
Train MaltParser from a list of DependencyGraph objects,train maltparser
Train MaltParser from a file :param conll_file: str for the filename of the training input data :type conll_file: str,train maltparser
"Return a new TreeEdge formed from the given production. The new edge’s left-hand side and right-hand side will be taken from production; its span will be (index,index); and its dot position will be 0.",return treeedge
"A specialized version of the fundamental rule that operates on nonterminals whose symbols are FeatStructNonterminal``s.  Rather tha simply comparing the nonterminals for equality, they are unified.  Variable bindings from these unifications are collected and stored in the chart using a ``FeatureTreeEdge. When a complete edge is generated, these bindings are applied to all nonterminals in the edge.",compare nonterminals for equality
"A specialized version of the fundamental rule that operates on nonterminals whose symbols are FeatStructNonterminal``s.  Rather tha simply comparing the nonterminals for equality, they are unified.  Variable bindings from these unifications are collected and stored in the chart using a ``FeatureTreeEdge. When a complete edge is generated, these bindings are applied to all nonterminals in the edge.",store variable bindings from unifications
"A specialized version of the fundamental rule that operates on nonterminals whose symbols are FeatStructNonterminal``s.  Rather tha simply comparing the nonterminals for equality, they are unified.  Variable bindings from these unifications are collected and stored in the chart using a ``FeatureTreeEdge. When a complete edge is generated, these bindings are applied to all nonterminals in the edge.",apply bindings to nonterminals
"A processing class for deriving trees that represent possible
structures for a sequence of tokens.  These tree structures are
known as “parses”.  Typically, parsers are used to derive syntax
trees for sentences.  But parsers can also be used to derive other
kinds of tree structure, such as morphological trees and discourse
structures.",,use parsers
"A processing class for deriving trees that represent possible
structures for a sequence of tokens.  These tree structures are
known as “parses”.  Typically, parsers are used to derive syntax
trees for sentences.  But parsers can also be used to derive other
kinds of tree structure, such as morphological trees and discourse
structures.",,use parsers
The grammar used by this parser.,,use  by parser
"Interface for parsing with BLLIP Parser. BllipParser objects can be
constructed with the BllipParser.from_unified_model_dir class
method or manually using the BllipParser constructor.",,use bllipparser constructor
"Interface for parsing with BLLIP Parser. BllipParser objects can be
constructed with the BllipParser.from_unified_model_dir class
method or manually using the BllipParser constructor.",,use bllipparser objects
"Create a BllipParser object from a unified parsing model
directory. Unified parsing model directories are a standardized
way of storing BLLIP parser and reranker models together on disk.
See bllipparser.RerankingParser.get_unified_model_parameters()
for more information about unified model directories.",,create bllipparser object from unified parsing model directory
"Create a BllipParser object from a unified parsing model
directory. Unified parsing model directories are a standardized
way of storing BLLIP parser and reranker models together on disk.
See bllipparser.RerankingParser.get_unified_model_parameters()
for more information about unified model directories.",,store bllip parser on disk
"Create a BllipParser object from a unified parsing model
directory. Unified parsing model directories are a standardized
way of storing BLLIP parser and reranker models together on disk.
See bllipparser.RerankingParser.get_unified_model_parameters()
for more information about unified model directories.",,store reranker models on disk
"Use BLLIP to parse a sentence. Takes a sentence as a list of
(word, tag) tuples; the sentence must have already been tokenized
and tagged. BLLIP will attempt to use the tags provided but may
use others if it can’t come up with a complete parse subject
to those constraints. You may also specify a tag as None
to leave a token’s tag unconstrained.",,use bllip
"Use BLLIP to parse a sentence. Takes a sentence as a list of
(word, tag) tuples; the sentence must have already been tokenized
and tagged. BLLIP will attempt to use the tags provided but may
use others if it can’t come up with a complete parse subject
to those constraints. You may also specify a tag as None
to leave a token’s tag unconstrained.",,use others
"Use BLLIP to parse a sentence. Takes a sentence as a list of
(word, tag) tuples; the sentence must have already been tokenized
and tagged. BLLIP will attempt to use the tags provided but may
use others if it can’t come up with a complete parse subject
to those constraints. You may also specify a tag as None
to leave a token’s tag unconstrained.",,specify tag as none
"Data classes and parser implementations for “chart parsers”, which
use dynamic programming to efficiently parse a text.  A chart
parser derives parse trees for a text by iteratively adding “edges”
to a “chart.”  Each edge represents a hypothesis about the tree
structure for a subsequence of the text.  The chart is a
“blackboard” for composing and combining these hypotheses.",,use dynamic programming
"Data classes and parser implementations for “chart parsers”, which
use dynamic programming to efficiently parse a text.  A chart
parser derives parse trees for a text by iteratively adding “edges”
to a “chart.”  Each edge represents a hypothesis about the tree
structure for a subsequence of the text.  The chart is a
“blackboard” for composing and combining these hypotheses.",,use chart parsers
"Data classes and parser implementations for “chart parsers”, which
use dynamic programming to efficiently parse a text.  A chart
parser derives parse trees for a text by iteratively adding “edges”
to a “chart.”  Each edge represents a hypothesis about the tree
structure for a subsequence of the text.  The chart is a
“blackboard” for composing and combining these hypotheses.",,add edges to chart
"Data classes and parser implementations for “chart parsers”, which
use dynamic programming to efficiently parse a text.  A chart
parser derives parse trees for a text by iteratively adding “edges”
to a “chart.”  Each edge represents a hypothesis about the tree
structure for a subsequence of the text.  The chart is a
“blackboard” for composing and combining these hypotheses.",,compose hypotheses
"Data classes and parser implementations for “chart parsers”, which
use dynamic programming to efficiently parse a text.  A chart
parser derives parse trees for a text by iteratively adding “edges”
to a “chart.”  Each edge represents a hypothesis about the tree
structure for a subsequence of the text.  The chart is a
“blackboard” for composing and combining these hypotheses.",,combine hypotheses
"When a chart parser begins parsing a text, it creates a new (empty)
chart, spanning the text.  It then incrementally adds new edges to the
chart.  A set of “chart rules” specifies the conditions under which
new edges should be added to the chart.  Once the chart reaches a
stage where none of the chart rules adds any new edges, parsing is
complete.",,create new chart
"When a chart parser begins parsing a text, it creates a new (empty)
chart, spanning the text.  It then incrementally adds new edges to the
chart.  A set of “chart rules” specifies the conditions under which
new edges should be added to the chart.  Once the chart reaches a
stage where none of the chart rules adds any new edges, parsing is
complete.",,add new edges to chart
"When a chart parser begins parsing a text, it creates a new (empty)
chart, spanning the text.  It then incrementally adds new edges to the
chart.  A set of “chart rules” specifies the conditions under which
new edges should be added to the chart.  Once the chart reaches a
stage where none of the chart rules adds any new edges, parsing is
complete.",,specify conditions
"When a chart parser begins parsing a text, it creates a new (empty)
chart, spanning the text.  It then incrementally adds new edges to the
chart.  A set of “chart rules” specifies the conditions under which
new edges should be added to the chart.  Once the chart reaches a
stage where none of the chart rules adds any new edges, parsing is
complete.",,add new edges to chart
"When a chart parser begins parsing a text, it creates a new (empty)
chart, spanning the text.  It then incrementally adds new edges to the
chart.  A set of “chart rules” specifies the conditions under which
new edges should be added to the chart.  Once the chart reaches a
stage where none of the chart rules adds any new edges, parsing is
complete.",,add conditions to chart
"When a chart parser begins parsing a text, it creates a new (empty)
chart, spanning the text.  It then incrementally adds new edges to the
chart.  A set of “chart rules” specifies the conditions under which
new edges should be added to the chart.  Once the chart reaches a
stage where none of the chart rules adds any new edges, parsing is
complete.",,reach stage
"When a chart parser begins parsing a text, it creates a new (empty)
chart, spanning the text.  It then incrementally adds new edges to the
chart.  A set of “chart rules” specifies the conditions under which
new edges should be added to the chart.  Once the chart reaches a
stage where none of the chart rules adds any new edges, parsing is
complete.",,add new edges
"When a chart parser begins parsing a text, it creates a new (empty)
chart, spanning the text.  It then incrementally adds new edges to the
chart.  A set of “chart rules” specifies the conditions under which
new edges should be added to the chart.  Once the chart reaches a
stage where none of the chart rules adds any new edges, parsing is
complete.",,add stage
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",,encode charts with chart class
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",,encode edges with treeedge leafedge classes
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",,define chart parsers
"ChartParser is a simple and flexible chart parser.  Given a
set of chart rules, it will apply those rules to the chart until
no more edges are added.",,apply rules to chart
"ChartParser is a simple and flexible chart parser.  Given a
set of chart rules, it will apply those rules to the chart until
no more edges are added.",,add more edges
"SteppingChartParser is a subclass of ChartParser that can
be used to step through the parsing process.",,use subclass of chartparser
"A default implementation for __str__, which returns a
name based on the rule’s class name.",,return name
"A default implementation for __str__, which returns a
name based on the rule’s class name.",,return __str__
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Return a generator that will add all edges licensed by
this rule, given the edges that are currently in the
chart, one at a time.  Each time the generator is resumed,
it will either add a new edge and yield that edge; or return.",,return generator
"Return a generator that will add all edges licensed by
this rule, given the edges that are currently in the
chart, one at a time.  Each time the generator is resumed,
it will either add a new edge and yield that edge; or return.",,add edges
"Return a generator that will add all edges licensed by
this rule, given the edges that are currently in the
chart, one at a time.  Each time the generator is resumed,
it will either add a new edge and yield that edge; or return.",,add generator
"Return a generator that will add all edges licensed by
this rule, given the edges that are currently in the
chart, one at a time.  Each time the generator is resumed,
it will either add a new edge and yield that edge; or return.",,add new edge
"A ChartParser using a bottom-up parsing strategy.
See ChartParser for more information.",,use bottom-up parsing strategy
"A ChartParser using a bottom-up left-corner parsing strategy.
This strategy is often more efficient than standard bottom-up.
See ChartParser for more information.",,use bottom-up left-corner parsing strategy
"A rule licensing any edge corresponding to a production whose
right-hand side begins with a complete edge’s left-hand side.  In
particular, this rule specifies that [A -> alpha \*]
licenses the edge [B -> A \* beta] for each grammar
production B -> A beta.",,specify [ a
"This is like BottomUpPredictRule, but it also applies
the FundamentalRule to the resulting edge.",,apply fundamentalrule to resulting edge
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"A cached version of TopDownPredictRule.  After the first time
this rule is applied to an edge with a given end and next,
it will not generate any more edges for edges with that end and
next.",,apply rule after first time
"A cached version of TopDownPredictRule.  After the first time
this rule is applied to an edge with a given end and next,
it will not generate any more edges for edges with that end and
next.",,apply rule to edge
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"A blackboard for hypotheses about the syntactic constituents of a
sentence.  A chart contains a set of edges, and each edge encodes
a single hypothesis about the structure of some portion of the
sentence.",,encode single hypothesis about structure
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",,select specific collection of edges
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",,use select method
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",,complete edges
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",,create index for set
"Return the set of child pointer lists for the given edge.
Each child pointer list is a list of edges that have
been used to form this edge.",,list  for given edge
"Return the set of child pointer lists for the given edge.
Each child pointer list is a list of edges that have
been used to form this edge.",,use edges
"Return a list of all edges in this chart.  New edges
that are added to the chart after the call to edges()
will not be contained in this list.",,add new edges to chart
"Return a list of all edges in this chart.  New edges
that are added to the chart after the call to edges()
will not be contained in this list.",,add new edges to edges()
"Return a list of all edges in this chart.  New edges
that are added to the chart after the call to edges()
will not be contained in this list.",,add new edges after call
"Add a new edge to the chart, and return True if this operation
modified the chart.  In particular, return true iff the chart
did not already contain edge, or if it did not already associate
child_pointer_lists with edge.",,add new edge to chart
"Add a new edge to the chart, and return True if this operation
modified the chart.  In particular, return true iff the chart
did not already contain edge, or if it did not already associate
child_pointer_lists with edge.",,return true
"Add a new edge to the chart, and return True if this operation
modified the chart.  In particular, return true iff the chart
did not already contain edge, or if it did not already associate
child_pointer_lists with edge.",,modify chart
"child_pointer_lists (sequence of tuple(EdgeI)) – A sequence of lists of the edges that
were used to form this edge.  This list is used to reconstruct
the trees (or partial trees) that are associated with edge.",,use sequence of lists
"child_pointer_lists (sequence of tuple(EdgeI)) – A sequence of lists of the edges that
were used to form this edge.  This list is used to reconstruct
the trees (or partial trees) that are associated with edge.",,use list
"Return an iterator over the edges in this chart.  It is
not guaranteed that new edges which are added to the
chart before the iterator is exhausted will also be generated.",,add new edges to chart
"Return an iterator over the edges in this chart.  It is
not guaranteed that new edges which are added to the
chart before the iterator is exhausted will also be generated.",,generate new edges
"Return a pretty-printed string representation of a given edge
in this chart.",,return pretty-printed string representation of given edge
"Return a pretty-printed string representation of this
chart’s leaves.  This string can be used as a header
for calls to pretty_format_edge.",,use string as header
"Return a pretty-printed string representation of this
chart’s leaves.  This string can be used as a header
for calls to pretty_format_edge.",,use string to pretty_format_edge
"Return an iterator over the edges in this chart.  Any
new edges that are added to the chart before the iterator
is exahusted will also be generated.  restrictions
can be used to restrict the set of edges that will be
generated.",,add new edges to chart
"Return an iterator over the edges in this chart.  Any
new edges that are added to the chart before the iterator
is exahusted will also be generated.  restrictions
can be used to restrict the set of edges that will be
generated.",,generate new edges
"Return an iterator over the edges in this chart.  Any
new edges that are added to the chart before the iterator
is exahusted will also be generated.  restrictions
can be used to restrict the set of edges that will be
generated.",,use restrictions
"Return an iterator over the edges in this chart.  Any
new edges that are added to the chart before the iterator
is exahusted will also be generated.  restrictions
can be used to restrict the set of edges that will be
generated.",,generate edges
"Return an iterator of the tree structures that are associated
with edge.",,return iterator of tree structures
"If edge is incomplete, then the unexpanded children will be
encoded as childless subtrees, whose node value is the
corresponding terminal or nonterminal.",,encode unexpanded children as childless subtrees
"If two trees share a common subtree, then the same
Tree may be used to encode that subtree in
both trees.  If you need to eliminate this subtree
sharing, then create a deep copy of each tree.",,share common subtree
"If two trees share a common subtree, then the same
Tree may be used to encode that subtree in
both trees.  If you need to eliminate this subtree
sharing, then create a deep copy of each tree.",,encode subtree in trees
"If two trees share a common subtree, then the same
Tree may be used to encode that subtree in
both trees.  If you need to eliminate this subtree
sharing, then create a deep copy of each tree.",,use same tree
"If two trees share a common subtree, then the same
Tree may be used to encode that subtree in
both trees.  If you need to eliminate this subtree
sharing, then create a deep copy of each tree.",,create deep copy of tree
"A generic chart parser.  A “strategy”, or list of
ChartRuleI instances, is used to decide what edges to add to
the chart.  In particular, ChartParser uses the following
algorithm to parse texts:",,add  to chart
"A generic chart parser.  A “strategy”, or list of
ChartRuleI instances, is used to decide what edges to add to
the chart.  In particular, ChartParser uses the following
algorithm to parse texts:",,use strategy of chartrulei instances
"A generic chart parser.  A “strategy”, or list of
ChartRuleI instances, is used to decide what edges to add to
the chart.  In particular, ChartParser uses the following
algorithm to parse texts:",,use list of chartrulei instances
"A generic chart parser.  A “strategy”, or list of
ChartRuleI instances, is used to decide what edges to add to
the chart.  In particular, ChartParser uses the following
algorithm to parse texts:",,use following algorithm
"Return the final parse Chart from which all possible
parse trees can be extracted.",,return final parse chart
The grammar used by this parser.,,use  by parser
"A rule that specifies what new edges are licensed by any given set
of existing edges.  Each chart rule expects a fixed number of
edges, as indicated by the class variable NUM_EDGES.  In
particular:",,specify rule of existing edges
"A chart rule with NUM_EDGES=0 specifies what new edges are
licensed, regardless of existing edges.",,specify  regardless_of existing edges
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Return a generator that will add all edges licensed by
this rule, given the edges that are currently in the
chart, one at a time.  Each time the generator is resumed,
it will either add a new edge and yield that edge; or return.",,return generator
"Return a generator that will add all edges licensed by
this rule, given the edges that are currently in the
chart, one at a time.  Each time the generator is resumed,
it will either add a new edge and yield that edge; or return.",,add edges
"Return a generator that will add all edges licensed by
this rule, given the edges that are currently in the
chart, one at a time.  Each time the generator is resumed,
it will either add a new edge and yield that edge; or return.",,add generator
"Return a generator that will add all edges licensed by
this rule, given the edges that are currently in the
chart, one at a time.  Each time the generator is resumed,
it will either add a new edge and yield that edge; or return.",,add new edge
"A left-hand side, specifying what kind of structure is
hypothesized.",,specify kind of structure
"A right-hand side, specifying the contents of the
hypothesized structure.",,specify contents of hypothesized structure
"An edge is incomplete if its structure is partially
consistent with the sentence.  For every incomplete edge, the
span specifies a possible prefix for the edge’s structure.",,specify possible prefix for incomplete edge
"An edge is incomplete if its structure is partially
consistent with the sentence.  For every incomplete edge, the
span specifies a possible prefix for the edge’s structure.",,specify possible prefix for structure
"A TreeEdge records which trees have been found to
be (partially) consistent with the text.",,find trees
"The EdgeI interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.",,provide common interface to types
"Return this edge’s dot position, which indicates how much of
the hypothesized structure is consistent with the
sentence.  In particular, self.rhs[:dot] is consistent
with tokens[self.start():self.end()].",,return dot position
"Return this edge’s left-hand side, which specifies what kind
of structure is hypothesized by this edge.",,return left-hand side
"Return this edge’s left-hand side, which specifies what kind
of structure is hypothesized by this edge.",,specify kind of structure
"Return this edge’s left-hand side, which specifies what kind
of structure is hypothesized by this edge.",,specify left-hand side of structure
"Return the element of this edge’s right-hand side that
immediately follows its dot.",,return element of right-hand side
"Return this edge’s right-hand side, which specifies
the content of the structure hypothesized by this edge.",,return right-hand side
"Return this edge’s right-hand side, which specifies
the content of the structure hypothesized by this edge.",,specify content of structure
"Return this edge’s right-hand side, which specifies
the content of the structure hypothesized by this edge.",,specify right-hand side of structure
"Return a tuple (s, e), where tokens[s:e] is the
portion of the sentence that is consistent with this
edge’s structure.",,return tuple
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"A leaf, specifying the word’s content.",,specify word
"Return this edge’s dot position, which indicates how much of
the hypothesized structure is consistent with the
sentence.  In particular, self.rhs[:dot] is consistent
with tokens[self.start():self.end()].",,return dot position
"Return this edge’s left-hand side, which specifies what kind
of structure is hypothesized by this edge.",,return left-hand side
"Return this edge’s left-hand side, which specifies what kind
of structure is hypothesized by this edge.",,specify kind of structure
"Return this edge’s left-hand side, which specifies what kind
of structure is hypothesized by this edge.",,specify left-hand side of structure
"Return the element of this edge’s right-hand side that
immediately follows its dot.",,return element of right-hand side
"Return this edge’s right-hand side, which specifies
the content of the structure hypothesized by this edge.",,return right-hand side
"Return this edge’s right-hand side, which specifies
the content of the structure hypothesized by this edge.",,specify content of structure
"Return this edge’s right-hand side, which specifies
the content of the structure hypothesized by this edge.",,specify right-hand side of structure
"Return a tuple (s, e), where tokens[s:e] is the
portion of the sentence that is consistent with this
edge’s structure.",,return tuple
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"A rule that joins a given edge with adjacent edges in the chart,
to form combined edges.  In particular, this rule specifies that
either of the edges:",,specify  of edges
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"A ChartParser that allows you to step through the parsing
process, adding a single edge at a time.  It also allows you to
change the parser’s strategy or grammar midway through parsing a
text.",,add single edge at time
"A ChartParser that allows you to step through the parsing
process, adding a single edge at a time.  It also allows you to
change the parser’s strategy or grammar midway through parsing a
text.",,change strategy
"A ChartParser that allows you to step through the parsing
process, adding a single edge at a time.  It also allows you to
change the parser’s strategy or grammar midway through parsing a
text.",,change grammar
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",,use initialize method
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",,add single edge to chart
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",,change strategy
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",,return set of parses
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",,find parses
"_restart – Records whether the parser’s strategy, grammar,
or chart has been changed.  If so, then step must restart
the parsing algorithm.",,change strategy
"_restart – Records whether the parser’s strategy, grammar,
or chart has been changed.  If so, then step must restart
the parsing algorithm.",,change chart
"_restart – Records whether the parser’s strategy, grammar,
or chart has been changed.  If so, then step must restart
the parsing algorithm.",,restart parsing algorithm
Return the grammar used by this parser.,,use  by parser
"Change the strategy that the parser uses to decide which edges
to add to the chart.",,change strategy
"Change the strategy that the parser uses to decide which edges
to add to the chart.",,add  to chart
"strategy (list(ChartRuleI)) – A list of rules that should be used to decide
what edges to add to the chart.",,add  to chart
"strategy (list(ChartRuleI)) – A list of rules that should be used to decide
what edges to add to the chart.",,use rules
"Return a generator that adds edges to the chart, one at a
time.  Each time the generator is resumed, it adds a single
edge and yields that edge.  If no more edges can be added,
then it yields None.",,add edges to chart
"Return a generator that adds edges to the chart, one at a
time.  Each time the generator is resumed, it adds a single
edge and yields that edge.  If no more edges can be added,
then it yields None.",,add single edge
"Return a generator that adds edges to the chart, one at a
time.  Each time the generator is resumed, it adds a single
edge and yields that edge.  If no more edges can be added,
then it yields None.",,add more edges
"If the parser’s strategy, grammar, or chart is changed, then
the generator will continue adding edges using the new
strategy, grammar, or chart.",,add edges
"If the parser’s strategy, grammar, or chart is changed, then
the generator will continue adding edges using the new
strategy, grammar, or chart.",,use new strategy
"If the parser’s strategy, grammar, or chart is changed, then
the generator will continue adding edges using the new
strategy, grammar, or chart.",,use grammar
"If the parser’s strategy, grammar, or chart is changed, then
the generator will continue adding edges using the new
strategy, grammar, or chart.",,use chart
"If the parser’s strategy, grammar, or chart is changed, then
the generator will continue adding edges using the new
strategy, grammar, or chart.",,change strategy
"If the parser’s strategy, grammar, or chart is changed, then
the generator will continue adding edges using the new
strategy, grammar, or chart.",,change chart
"Note that this generator never terminates, since the grammar
or strategy might be changed to values that would add new
edges.  Instead, it yields None when no more edges can be
added with the current strategy and grammar.",,add new edges
"Note that this generator never terminates, since the grammar
or strategy might be changed to values that would add new
edges.  Instead, it yields None when no more edges can be
added with the current strategy and grammar.",,add values
"Note that this generator never terminates, since the grammar
or strategy might be changed to values that would add new
edges.  Instead, it yields None when no more edges can be
added with the current strategy and grammar.",,change grammar to values
"Note that this generator never terminates, since the grammar
or strategy might be changed to values that would add new
edges.  Instead, it yields None when no more edges can be
added with the current strategy and grammar.",,change strategy to values
"Note that this generator never terminates, since the grammar
or strategy might be changed to values that would add new
edges.  Instead, it yields None when no more edges can be
added with the current strategy and grammar.",,add more edges with current strategy
"Note that this generator never terminates, since the grammar
or strategy might be changed to values that would add new
edges.  Instead, it yields None when no more edges can be
added with the current strategy and grammar.",,add more edges with grammar
"A ChartParser using a top-down parsing strategy.
See ChartParser for more information.",,use top-down parsing strategy
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"A left-hand side, specifying the hypothesized tree’s node
value.",,specify hypothesized tree
"A right-hand side, specifying the hypothesized tree’s
children.  Each element of the right-hand side is either a
terminal, specifying a token with that terminal as its leaf
value; or a nonterminal, specifying a subtree with that
nonterminal’s symbol as its node value.",,specify hypothesized tree
"A right-hand side, specifying the hypothesized tree’s
children.  Each element of the right-hand side is either a
terminal, specifying a token with that terminal as its leaf
value; or a nonterminal, specifying a subtree with that
nonterminal’s symbol as its node value.",,specify  with terminal
"A right-hand side, specifying the hypothesized tree’s
children.  Each element of the right-hand side is either a
terminal, specifying a token with that terminal as its leaf
value; or a nonterminal, specifying a subtree with that
nonterminal’s symbol as its node value.",,specify  with nonterminal
"A right-hand side, specifying the hypothesized tree’s
children.  Each element of the right-hand side is either a
terminal, specifying a token with that terminal as its leaf
value; or a nonterminal, specifying a subtree with that
nonterminal’s symbol as its node value.",,specify subtree with symbol
"Return this edge’s dot position, which indicates how much of
the hypothesized structure is consistent with the
sentence.  In particular, self.rhs[:dot] is consistent
with tokens[self.start():self.end()].",,return dot position
"Return this edge’s left-hand side, which specifies what kind
of structure is hypothesized by this edge.",,return left-hand side
"Return this edge’s left-hand side, which specifies what kind
of structure is hypothesized by this edge.",,specify kind of structure
"Return this edge’s left-hand side, which specifies what kind
of structure is hypothesized by this edge.",,specify left-hand side of structure
"Return a new TreeEdge formed from this edge.
The new edge’s dot position is increased by 1,
and its end index will be replaced by new_end.",,replace end index
"Return the element of this edge’s right-hand side that
immediately follows its dot.",,return element of right-hand side
"Return this edge’s right-hand side, which specifies
the content of the structure hypothesized by this edge.",,return right-hand side
"Return this edge’s right-hand side, which specifies
the content of the structure hypothesized by this edge.",,specify content of structure
"Return this edge’s right-hand side, which specifies
the content of the structure hypothesized by this edge.",,specify right-hand side of structure
"Return a tuple (s, e), where tokens[s:e] is the
portion of the sentence that is consistent with this
edge’s structure.",,return tuple
"Tools for reading and writing dependency trees.
The input is assumed to be in Malt-TAB format
(http://stp.lingfil.uu.se/~nivre/research/MaltXML.html).",,read dependency trees
"Tools for reading and writing dependency trees.
The input is assumed to be in Malt-TAB format
(http://stp.lingfil.uu.se/~nivre/research/MaltXML.html).",,write dependency trees
"Adds an arc from the node specified by head_address to the
node specified by the mod address.",,add arc from node
"Adds an arc from the node specified by head_address to the
node specified by the mod address.",,specify  to node
"Fully connects all non-root nodes.  All nodes are set to be dependents
of the root node.",,set nodes
"Returns true if the graph contains a node with the given node
address, false otherwise.",,return true
"Returns the number of left children under the node specified
by the given address.",,return number of left children
"Returns the number of left children under the node specified
by the given address.",,return number under node
"rather than 1 (as produced by, e.g., zpar)
:param str cell_separator: the cell separator. If not provided, cells
are split by whitespace.
:param str top_relation_label: the label by which the top relation is
identified, for examlple, ROOT, null or TOP.",,split cells
"rather than 1 (as produced by, e.g., zpar)
:param str cell_separator: the cell separator. If not provided, cells
are split by whitespace.
:param str top_relation_label: the label by which the top relation is
identified, for examlple, ROOT, null or TOP.",,identify top relation for examlple
"rather than 1 (as produced by, e.g., zpar)
:param str cell_separator: the cell separator. If not provided, cells
are split by whitespace.
:param str top_relation_label: the label by which the top relation is
identified, for examlple, ROOT, null or TOP.",,identify top relation for root
"rather than 1 (as produced by, e.g., zpar)
:param str cell_separator: the cell separator. If not provided, cells
are split by whitespace.
:param str top_relation_label: the label by which the top relation is
identified, for examlple, ROOT, null or TOP.",,identify top relation for null
"rather than 1 (as produced by, e.g., zpar)
:param str cell_separator: the cell separator. If not provided, cells
are split by whitespace.
:param str top_relation_label: the label by which the top relation is
identified, for examlple, ROOT, null or TOP.",,identify top relation for top
"rather than 1 (as produced by, e.g., zpar)
:param str cell_separator: the cell separator. If not provided, cells
are split by whitespace.
:param str top_relation_label: the label by which the top relation is
identified, for examlple, ROOT, null or TOP.",,identify label for examlple
"rather than 1 (as produced by, e.g., zpar)
:param str cell_separator: the cell separator. If not provided, cells
are split by whitespace.
:param str top_relation_label: the label by which the top relation is
identified, for examlple, ROOT, null or TOP.",,identify label for root
"rather than 1 (as produced by, e.g., zpar)
:param str cell_separator: the cell separator. If not provided, cells
are split by whitespace.
:param str top_relation_label: the label by which the top relation is
identified, for examlple, ROOT, null or TOP.",,identify label for null
"rather than 1 (as produced by, e.g., zpar)
:param str cell_separator: the cell separator. If not provided, cells
are split by whitespace.
:param str top_relation_label: the label by which the top relation is
identified, for examlple, ROOT, null or TOP.",,identify label for top
"Removes the node with the given address.  References
to this node in others will still exist.",,remove node with given address
"Returns the number of right children under the node specified
by the given address.",,return number of right children
"Returns the number of right children under the node specified
by the given address.",,return number under node
"style (int) – the style to use for the format (3, 4, 10 columns)",,use  for format
"Starting with the root node, build a dependency tree using the NLTK
Tree constructor. Dependency labels are omitted.",,use nltk tree constructor
"Starting with the root node, build a dependency tree using the NLTK
Tree constructor. Dependency labels are omitted.",,omit dependency labels
"A demonstration of how to read a string representation of
a CoNLL format dependency tree.",,read string representation of conll format
"A demonstration of the result of reading a dependency
version of the first sentence of the Penn Treebank.",,read dependency version of first sentence
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",,use dynamic programming
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",,use incremental chart parsers
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",,add edges to chart
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",,compose hypotheses
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",,combine hypotheses
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Returns an iterator over the edges in this chart.
See Chart.select for more information about the
restrictions on the edges.",,return iterator over edges
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Return a list of all edges in this chart.  New edges
that are added to the chart after the call to edges()
will not be contained in this list.",,add new edges to chart
"Return a list of all edges in this chart.  New edges
that are added to the chart after the call to edges()
will not be contained in this list.",,add new edges to edges()
"Return a list of all edges in this chart.  New edges
that are added to the chart after the call to edges()
will not be contained in this list.",,add new edges after call
"Return an iterator over the edges in this chart.  It is
not guaranteed that new edges which are added to the
chart before the iterator is exhausted will also be generated.",,add new edges to chart
"Return an iterator over the edges in this chart.  It is
not guaranteed that new edges which are added to the
chart before the iterator is exhausted will also be generated.",,generate new edges
"Return an iterator over the edges in this chart.  Any
new edges that are added to the chart before the iterator
is exahusted will also be generated.  restrictions
can be used to restrict the set of edges that will be
generated.",,add new edges to chart
"Return an iterator over the edges in this chart.  Any
new edges that are added to the chart before the iterator
is exahusted will also be generated.  restrictions
can be used to restrict the set of edges that will be
generated.",,generate new edges
"Return an iterator over the edges in this chart.  Any
new edges that are added to the chart before the iterator
is exahusted will also be generated.  restrictions
can be used to restrict the set of edges that will be
generated.",,use restrictions
"Return an iterator over the edges in this chart.  Any
new edges that are added to the chart before the iterator
is exahusted will also be generated.  restrictions
can be used to restrict the set of edges that will be
generated.",,generate edges
"An incremental chart parser implementing Jay Earley’s
parsing algorithm:",,implement parsing algorithm
"Return the final parse Chart from which all possible
parse trees can be extracted.",,return final parse chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Class for measuring labelled and unlabelled attachment score for
dependency parsing. Note that the evaluation ignores punctuation.",,ignore punctuation
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",,handle grammars with feature structures
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Returns an iterator over the edges in this chart.
See Chart.select for more information about the
restrictions on the edges.",,return iterator over edges
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"A specialized version of the fundamental rule that operates on
nonterminals whose symbols are FeatStructNonterminal``s.  Rather
tha simply comparing the nonterminals for equality, they are
unified.  Variable bindings from these unifications are collected
and stored in the chart using a ``FeatureTreeEdge.  When a
complete edge is generated, these bindings are applied to all
nonterminals in the edge.",,compare nonterminals for equality
"A specialized version of the fundamental rule that operates on
nonterminals whose symbols are FeatStructNonterminal``s.  Rather
tha simply comparing the nonterminals for equality, they are
unified.  Variable bindings from these unifications are collected
and stored in the chart using a ``FeatureTreeEdge.  When a
complete edge is generated, these bindings are applied to all
nonterminals in the edge.",,use featuretreeedge
"A specialized version of the fundamental rule that operates on
nonterminals whose symbols are FeatStructNonterminal``s.  Rather
tha simply comparing the nonterminals for equality, they are
unified.  Variable bindings from these unifications are collected
and stored in the chart using a ``FeatureTreeEdge.  When a
complete edge is generated, these bindings are applied to all
nonterminals in the edge.",,store variable bindings from unifications
"A specialized version of the fundamental rule that operates on
nonterminals whose symbols are FeatStructNonterminal``s.  Rather
tha simply comparing the nonterminals for equality, they are
unified.  Variable bindings from these unifications are collected
and stored in the chart using a ``FeatureTreeEdge.  When a
complete edge is generated, these bindings are applied to all
nonterminals in the edge.",,apply bindings to nonterminals
"A specialized version of the fundamental rule that operates on
nonterminals whose symbols are FeatStructNonterminal``s.  Rather
tha simply comparing the nonterminals for equality, they are
unified.  Variable bindings from these unifications are collected
and stored in the chart using a ``FeatureTreeEdge.  When a
complete edge is generated, these bindings are applied to all
nonterminals in the edge.",,generate complete edge
assuming that B1 and B2 can be unified to generate B3.,,generate b3
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"A specialized version of the completer / single edge fundamental rule
that operates on nonterminals whose symbols are ``FeatStructNonterminal``s.
Rather than simply comparing the nonterminals for equality, they are
unified.",,compare nonterminals for equality
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"A specialized version of the (cached) top down predict rule that operates
on nonterminals whose symbols are ``FeatStructNonterminal``s.  Rather
than simply comparing the nonterminals for equality, they are
unified.",,compare nonterminals for equality
The top down expand rule states that:,,expand rule states
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"A specialized tree edge that allows shared variable bindings
between nonterminals on the left-hand side and right-hand side.",,share variable bindings between nonterminals
"A specialized tree edge that allows shared variable bindings
between nonterminals on the left-hand side and right-hand side.",,share variable bindings on right-hand side
"A specialized tree edge that allows shared variable bindings
between nonterminals on the left-hand side and right-hand side.",,share variable bindings on left-hand side
"Each FeatureTreeEdge contains a set of bindings, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface SubstituteBindingsI.",,set  of bindings
"Each FeatureTreeEdge contains a set of bindings, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface SubstituteBindingsI.",,store bindings
"Each FeatureTreeEdge contains a set of bindings, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface SubstituteBindingsI.",,apply bindings to nonterminal
"Each FeatureTreeEdge contains a set of bindings, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface SubstituteBindingsI.",,implement interface substitutebindingsi
"Each FeatureTreeEdge contains a set of bindings, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface SubstituteBindingsI.",,implement edge
"A new FeatureTreeEdge formed from this edge.
The new edge’s dot position is increased by 1,
and its end index will be replaced by new_end.",,replace end index
The set of variables used by this edge.,,use  by edge
"A specialized chart that ‘instantiates’ variables whose names
start with ‘@’, by replacing them with unique new variables.
In particular, whenever a complete edge is added to the chart, any
variables in the edge’s lhs whose names start with ‘@’ will be
replaced by unique new ``Variable``s.",,replace  with unique new variables
"A specialized chart that ‘instantiates’ variables whose names
start with ‘@’, by replacing them with unique new variables.
In particular, whenever a complete edge is added to the chart, any
variables in the edge’s lhs whose names start with ‘@’ will be
replaced by unique new ``Variable``s.",,add complete edge to chart
"A specialized chart that ‘instantiates’ variables whose names
start with ‘@’, by replacing them with unique new variables.
In particular, whenever a complete edge is added to the chart, any
variables in the edge’s lhs whose names start with ‘@’ will be
replaced by unique new ``Variable``s.",,replace variables in lhs
"Add a new edge to the chart, and return True if this operation
modified the chart.  In particular, return true iff the chart
did not already contain edge, or if it did not already associate
child_pointer_lists with edge.",,add new edge to chart
"Add a new edge to the chart, and return True if this operation
modified the chart.  In particular, return true iff the chart
did not already contain edge, or if it did not already associate
child_pointer_lists with edge.",,return true
"Add a new edge to the chart, and return True if this operation
modified the chart.  In particular, return true iff the chart
did not already contain edge, or if it did not already associate
child_pointer_lists with edge.",,modify chart
"child_pointer_lists (sequence of tuple(EdgeI)) – A sequence of lists of the edges that
were used to form this edge.  This list is used to reconstruct
the trees (or partial trees) that are associated with edge.",,use sequence of lists
"child_pointer_lists (sequence of tuple(EdgeI)) – A sequence of lists of the edges that
were used to form this edge.  This list is used to reconstruct
the trees (or partial trees) that are associated with edge.",,use list
"If the edge is a FeatureTreeEdge, and it is complete,
then instantiate all variables whose names start with ‘@’,
by replacing them with unique new variables.",,instantiate variables
"If the edge is a FeatureTreeEdge, and it is complete,
then instantiate all variables whose names start with ‘@’,
by replacing them with unique new variables.",,replace  with unique new variables
"A class for dependency parsing with MaltParser. The input is the paths to:
- a maltparser directory
- (optionally) the path to a pre-trained MaltParser .mco model file
- (optionally) the tagger to use for POS tagging before parsing
- (optionally) additional Java arguments",,use  for pos
"Use MaltParser to parse multiple sentences.
Takes a list of sentences, where each sentence is a list of words.
Each sentence will be automatically tagged with this
MaltParser instance’s tagger.",,use maltparser
"Use MaltParser to parse multiple POS tagged sentences. Takes multiple
sentences where each sentence is a list of (word, tag) tuples.
The sentences must have already been tokenized and tagged.",,use maltparser
"scored.
:rtype: A three-dimensional list of numbers.
:return: The score is returned in a multidimensional(3) list, such
that the outer-dimension refers to the head, and the
inner-dimension refers to the dependencies.  For instance,
scores[0][1] would reference the list of scores corresponding to
arcs from node 0 to node 1.  The node’s ‘address’ field can be used
to determine its number identification.",,return return in multidimensional(3) list
"scored.
:rtype: A three-dimensional list of numbers.
:return: The score is returned in a multidimensional(3) list, such
that the outer-dimension refers to the head, and the
inner-dimension refers to the dependencies.  For instance,
scores[0][1] would reference the list of scores corresponding to
arcs from node 0 to node 1.  The node’s ‘address’ field can be used
to determine its number identification.",,reference list of scores
"scored.
:rtype: A three-dimensional list of numbers.
:return: The score is returned in a multidimensional(3) list, such
that the outer-dimension refers to the head, and the
inner-dimension refers to the dependencies.  For instance,
scores[0][1] would reference the list of scores corresponding to
arcs from node 0 to node 1.  The node’s ‘address’ field can be used
to determine its number identification.",,determine number identification
"scored.
:rtype: A three-dimensional list of numbers.
:return: The score is returned in a multidimensional(3) list, such
that the outer-dimension refers to the head, and the
inner-dimension refers to the dependencies.  For instance,
scores[0][1] would reference the list of scores corresponding to
arcs from node 0 to node 1.  The node’s ‘address’ field can be used
to determine its number identification.",,use field
"When used in conjunction with a MaxEntClassifier, each score would
correspond to the confidence of a particular edge being classified
with the positive training examples.",,use  with maxentclassifier
"When used in conjunction with a MaxEntClassifier, each score would
correspond to the confidence of a particular edge being classified
with the positive training examples.",,use  in conjunction
"Typically the edges present in the graphs can be used as
positive training examples, and the edges not present as negative
examples.",,use graphs as positive training examples
"A scorer for calculated the weights on the edges of a weighted
dependency graph.  This is used by a
ProbabilisticNonprojectiveParser to initialize the edge
weights of a DependencyGraph.  While typically this would be done
by training a binary classifier, any class that can return a
multidimensional list representation of the edge weights can
implement this interface.  As such, it has no necessary
fields.",,calculate weights on edges
"A scorer for calculated the weights on the edges of a weighted
dependency graph.  This is used by a
ProbabilisticNonprojectiveParser to initialize the edge
weights of a DependencyGraph.  While typically this would be done
by training a binary classifier, any class that can return a
multidimensional list representation of the edge weights can
implement this interface.  As such, it has no necessary
fields.",,initialize edge weights of dependencygraph
"A scorer for calculated the weights on the edges of a weighted
dependency graph.  This is used by a
ProbabilisticNonprojectiveParser to initialize the edge
weights of a DependencyGraph.  While typically this would be done
by training a binary classifier, any class that can return a
multidimensional list representation of the edge weights can
implement this interface.  As such, it has no necessary
fields.",,return multidimensional list representation of edge weights
"A scorer for calculated the weights on the edges of a weighted
dependency graph.  This is used by a
ProbabilisticNonprojectiveParser to initialize the edge
weights of a DependencyGraph.  While typically this would be done
by training a binary classifier, any class that can return a
multidimensional list representation of the edge weights can
implement this interface.  As such, it has no necessary
fields.",,return class of edge weights
"A scorer for calculated the weights on the edges of a weighted
dependency graph.  This is used by a
ProbabilisticNonprojectiveParser to initialize the edge
weights of a DependencyGraph.  While typically this would be done
by training a binary classifier, any class that can return a
multidimensional list representation of the edge weights can
implement this interface.  As such, it has no necessary
fields.",,implement interface
"scored.
:rtype: A three-dimensional list of numbers.
:return: The score is returned in a multidimensional(3) list, such
that the outer-dimension refers to the head, and the
inner-dimension refers to the dependencies.  For instance,
scores[0][1] would reference the list of scores corresponding to
arcs from node 0 to node 1.  The node’s ‘address’ field can be used
to determine its number identification.",,return return in multidimensional(3) list
"scored.
:rtype: A three-dimensional list of numbers.
:return: The score is returned in a multidimensional(3) list, such
that the outer-dimension refers to the head, and the
inner-dimension refers to the dependencies.  For instance,
scores[0][1] would reference the list of scores corresponding to
arcs from node 0 to node 1.  The node’s ‘address’ field can be used
to determine its number identification.",,reference list of scores
"scored.
:rtype: A three-dimensional list of numbers.
:return: The score is returned in a multidimensional(3) list, such
that the outer-dimension refers to the head, and the
inner-dimension refers to the dependencies.  For instance,
scores[0][1] would reference the list of scores corresponding to
arcs from node 0 to node 1.  The node’s ‘address’ field can be used
to determine its number identification.",,determine number identification
"scored.
:rtype: A three-dimensional list of numbers.
:return: The score is returned in a multidimensional(3) list, such
that the outer-dimension refers to the head, and the
inner-dimension refers to the dependencies.  For instance,
scores[0][1] would reference the list of scores corresponding to
arcs from node 0 to node 1.  The node’s ‘address’ field can be used
to determine its number identification.",,use field
"When used in conjunction with a MaxEntClassifier, each score would
correspond to the confidence of a particular edge being classified
with the positive training examples.",,use  with maxentclassifier
"When used in conjunction with a MaxEntClassifier, each score would
correspond to the confidence of a particular edge being classified
with the positive training examples.",,use  in conjunction
"Typically the edges present in the graphs can be used as
positive training examples, and the edges not present as negative
examples.",,use graphs as positive training examples
"A dependency scorer built around a MaxEnt classifier.  In this
particular class that classifier is a NaiveBayesClassifier.
It uses head-word, head-tag, child-word, and child-tag features
for classification.",,use child-tag features
"Converts the graph into a feature-based representation of
each edge, and then assigns a score to each based on the
confidence of the classifier in assigning it to the
positive label.  Scores are returned in a multidimensional list.",,convert graph into feature-based representation
"Converts the graph into a feature-based representation of
each edge, and then assigns a score to each based on the
confidence of the classifier in assigning it to the
positive label.  Scores are returned in a multidimensional list.",,assign score
"Converts the graph into a feature-based representation of
each edge, and then assigns a score to each based on the
confidence of the classifier in assigning it to the
positive label.  Scores are returned in a multidimensional list.",,assign  to positive label
"Converts the graph into a feature-based representation of
each edge, and then assigns a score to each based on the
confidence of the classifier in assigning it to the
positive label.  Scores are returned in a multidimensional list.",,return scores in multidimensional list
"Trains a NaiveBayesClassifier using the edges present in
graphs list as positive examples, the edges not present as
negative examples.  Uses a feature vector of head-word,
head-tag, child-word, and child-tag.",,use edges present list as positive examples
"A non-projective, rule-based, dependency parser.  This parser
will return the set of all possible non-projective parses based on
the word-to-word relations defined in the parser’s dependency
grammar, and will allow the branches of the parse tree to cross
in order to capture a variety of linguistic phenomena that a
projective parser will not.",,return set of possible non-projective parses
"A non-projective, rule-based, dependency parser.  This parser
will return the set of all possible non-projective parses based on
the word-to-word relations defined in the parser’s dependency
grammar, and will allow the branches of the parse tree to cross
in order to capture a variety of linguistic phenomena that a
projective parser will not.",,define  in dependency grammar
"Parses the input tokens with respect to the parser’s grammar.  Parsing
is accomplished by representing the search-space of possible parses as
a fully-connected directed graph.  Arcs that would lead to ungrammatical
parses are removed and a lattice is constructed of length n, where n is
the number of input tokens, to represent all possible grammatical
traversals.  All possible paths through the lattice are then enumerated
to produce the set of non-projective parses.",,remove arcs
"Parses the input tokens with respect to the parser’s grammar.  Parsing
is accomplished by representing the search-space of possible parses as
a fully-connected directed graph.  Arcs that would lead to ungrammatical
parses are removed and a lattice is constructed of length n, where n is
the number of input tokens, to represent all possible grammatical
traversals.  All possible paths through the lattice are then enumerated
to produce the set of non-projective parses.",,produce set of non-projective parses
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",,find maximum spanning tree in weighted directed graph
"Returns the source of the best incoming arc to the
node with address: node_index",,return source of best incoming arc
"Takes a list of nodes that have been identified to belong to a cycle,
and collapses them into on larger node.  The arcs of all nodes in
the graph must be updated to account for this.",,identify nodes
"When updating scores the score of the highest-weighted incoming
arc is subtracted upon collapse.  This returns the correct
amount to subtract from that edge.",,update scores
"When updating scores the score of the highest-weighted incoming
arc is subtracted upon collapse.  This returns the correct
amount to subtract from that edge.",,return correct amount
"As nodes are collapsed into others, they are replaced
by the new node in the graph, but it’s still necessary
to keep track of what these original nodes were.  This
takes a list of node addresses and replaces any collapsed
node addresses with their original addresses.",,replace collapsed node addresses with original addresses
"Assigns a score to every edge in the DependencyGraph graph.
These scores are generated via the parser’s scorer which
was assigned during the training process.",,assign score to edge
"Assigns a score to every edge in the DependencyGraph graph.
These scores are generated via the parser’s scorer which
was assigned during the training process.",,generate scores via scorer
"Assigns a score to every edge in the DependencyGraph graph.
These scores are generated via the parser’s scorer which
was assigned during the training process.",,assign scorer during training process
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",,provide tags
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",,implement dependencyscoreri interface
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",,pass  to training algorithm
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",,use various scoring methods
"Trains a DependencyScorerI from a set of DependencyGraph objects,
and establishes this as the parser’s scorer.  This is used to
initialize the scores on a DependencyGraph during the parsing
procedure.",,initialize scores during parsing procedure
"Trains a DependencyScorerI from a set of DependencyGraph objects,
and establishes this as the parser’s scorer.  This is used to
initialize the scores on a DependencyGraph during the parsing
procedure.",,initialize scores on dependencygraph
"dependency_scorer (DependencyScorerI) – A scorer which implements the
DependencyScorerI interface.",,implement dependencyscoreri interface
"dependency_scorer (DependencyScorerI) – A scorer which implements the
DependencyScorerI interface.",,implement scorer
"Classes and interfaces for associating probabilities with tree
structures that represent the internal organization of a text.  The
probabilistic parser module defines BottomUpProbabilisticChartParser.",,define bottomupprobabilisticchartparser
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",,implement bottom-up chart parser for pcfg grammars
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",,implement abstract class for pcfg grammars
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",,expand likely edges
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",,implement different queue
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",,order different search strategies
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",,define following
"InsideChartParser searches edges in decreasing order of
their trees’ inside probabilities.",,search edges
RandomChartParser searches edges in random order.,,search edges
"LongestChartParser searches edges in decreasing order of their
location’s length.",,search edges
"An abstract bottom-up parser for PCFG grammars that uses a Chart to
record partial results.  BottomUpProbabilisticChartParser maintains
a queue of edges that can be added to the chart.  This queue is
initialized with edges for each token in the text that is being
parsed.  BottomUpProbabilisticChartParser inserts these edges into
the chart one at a time, starting with the most likely edges, and
proceeding to less likely edges.  For each edge that is added to
the chart, it may become possible to insert additional edges into
the chart; these are added to the queue.  This process continues
until enough complete parses have been generated, or until the
queue is empty.",,add edges to chart
"An abstract bottom-up parser for PCFG grammars that uses a Chart to
record partial results.  BottomUpProbabilisticChartParser maintains
a queue of edges that can be added to the chart.  This queue is
initialized with edges for each token in the text that is being
parsed.  BottomUpProbabilisticChartParser inserts these edges into
the chart one at a time, starting with the most likely edges, and
proceeding to less likely edges.  For each edge that is added to
the chart, it may become possible to insert additional edges into
the chart; these are added to the queue.  This process continues
until enough complete parses have been generated, or until the
queue is empty.",,initialize queue with edges
"An abstract bottom-up parser for PCFG grammars that uses a Chart to
record partial results.  BottomUpProbabilisticChartParser maintains
a queue of edges that can be added to the chart.  This queue is
initialized with edges for each token in the text that is being
parsed.  BottomUpProbabilisticChartParser inserts these edges into
the chart one at a time, starting with the most likely edges, and
proceeding to less likely edges.  For each edge that is added to
the chart, it may become possible to insert additional edges into
the chart; these are added to the queue.  This process continues
until enough complete parses have been generated, or until the
queue is empty.",,initialize queue in text
"An abstract bottom-up parser for PCFG grammars that uses a Chart to
record partial results.  BottomUpProbabilisticChartParser maintains
a queue of edges that can be added to the chart.  This queue is
initialized with edges for each token in the text that is being
parsed.  BottomUpProbabilisticChartParser inserts these edges into
the chart one at a time, starting with the most likely edges, and
proceeding to less likely edges.  For each edge that is added to
the chart, it may become possible to insert additional edges into
the chart; these are added to the queue.  This process continues
until enough complete parses have been generated, or until the
queue is empty.",,insert edges at time
"An abstract bottom-up parser for PCFG grammars that uses a Chart to
record partial results.  BottomUpProbabilisticChartParser maintains
a queue of edges that can be added to the chart.  This queue is
initialized with edges for each token in the text that is being
parsed.  BottomUpProbabilisticChartParser inserts these edges into
the chart one at a time, starting with the most likely edges, and
proceeding to less likely edges.  For each edge that is added to
the chart, it may become possible to insert additional edges into
the chart; these are added to the queue.  This process continues
until enough complete parses have been generated, or until the
queue is empty.",,insert additional edges into chart
"An abstract bottom-up parser for PCFG grammars that uses a Chart to
record partial results.  BottomUpProbabilisticChartParser maintains
a queue of edges that can be added to the chart.  This queue is
initialized with edges for each token in the text that is being
parsed.  BottomUpProbabilisticChartParser inserts these edges into
the chart one at a time, starting with the most likely edges, and
proceeding to less likely edges.  For each edge that is added to
the chart, it may become possible to insert additional edges into
the chart; these are added to the queue.  This process continues
until enough complete parses have been generated, or until the
queue is empty.",,add edge to chart
"An abstract bottom-up parser for PCFG grammars that uses a Chart to
record partial results.  BottomUpProbabilisticChartParser maintains
a queue of edges that can be added to the chart.  This queue is
initialized with edges for each token in the text that is being
parsed.  BottomUpProbabilisticChartParser inserts these edges into
the chart one at a time, starting with the most likely edges, and
proceeding to less likely edges.  For each edge that is added to
the chart, it may become possible to insert additional edges into
the chart; these are added to the queue.  This process continues
until enough complete parses have been generated, or until the
queue is empty.",,add  to queue
"An abstract bottom-up parser for PCFG grammars that uses a Chart to
record partial results.  BottomUpProbabilisticChartParser maintains
a queue of edges that can be added to the chart.  This queue is
initialized with edges for each token in the text that is being
parsed.  BottomUpProbabilisticChartParser inserts these edges into
the chart one at a time, starting with the most likely edges, and
proceeding to less likely edges.  For each edge that is added to
the chart, it may become possible to insert additional edges into
the chart; these are added to the queue.  This process continues
until enough complete parses have been generated, or until the
queue is empty.",,generate complete parses
"The sorting order for the queue is not specified by
BottomUpProbabilisticChartParser.  Different sorting orders will
result in different search strategies.  The sorting order for the
queue is defined by the method sort_queue; subclasses are required
to provide a definition for this method.",,provide definition for method
"The sorting order for the queue is not specified by
BottomUpProbabilisticChartParser.  Different sorting orders will
result in different search strategies.  The sorting order for the
queue is defined by the method sort_queue; subclasses are required
to provide a definition for this method.",,define sorting order for queue
"_trace – The level of tracing output that should be generated
when parsing a text.",,generate output
The grammar used by this parser.,,use  by parser
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,sort given queue of edge objects
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,place edge
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,add edge to queue
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,call method
"queue (list(Edge)) – The queue of Edge objects to sort.  Each edge in
this queue is an edge that could be added to the chart by
the fundamental rule; but that has not yet been added.",,add edge to chart
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,provide extra information for sorting
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,sort queue
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,use chart
"Set the level of tracing output that should be generated when
parsing a text.",,set level of tracing
"Set the level of tracing output that should be generated when
parsing a text.",,generate output
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",,generate tracing output
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",,produce more verbose
"A bottom-up parser for PCFG grammars that tries edges in descending
order of the inside probabilities of their trees.  The “inside
probability” of a tree is simply the
probability of the entire tree, ignoring its context.  In
particular, the inside probability of a tree generated by
production p with children c[1], c[2], …, c[n] is
P(p)P(c[1])P(c[2])…P(c[n]); and the inside
probability of a token is 1 if it is present in the text, and 0 if
it is absent.",,ignore context
"A bottom-up parser for PCFG grammars that tries edges in descending
order of the inside probabilities of their trees.  The “inside
probability” of a tree is simply the
probability of the entire tree, ignoring its context.  In
particular, the inside probability of a tree generated by
production p with children c[1], c[2], …, c[n] is
P(p)P(c[1])P(c[2])…P(c[n]); and the inside
probability of a token is 1 if it is present in the text, and 0 if
it is absent.",,generate  with children
"Sort the given queue of edges, in descending order of the
inside probabilities of the edges’ trees.",,sort given queue of edges
"queue (list(Edge)) – The queue of Edge objects to sort.  Each edge in
this queue is an edge that could be added to the chart by
the fundamental rule; but that has not yet been added.",,add edge to chart
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,provide extra information for sorting
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,sort queue
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,use chart
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,sort given queue of edge objects
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,place edge
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,add edge to queue
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,call method
"queue (list(Edge)) – The queue of Edge objects to sort.  Each edge in
this queue is an edge that could be added to the chart by
the fundamental rule; but that has not yet been added.",,add edge to chart
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,provide extra information for sorting
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,sort queue
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,use chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,sort given queue of edge objects
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,place edge
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,add edge to queue
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,call method
"queue (list(Edge)) – The queue of Edge objects to sort.  Each edge in
this queue is an edge that could be added to the chart by
the fundamental rule; but that has not yet been added.",,add edge to chart
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,provide extra information for sorting
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,sort queue
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,use chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges at time
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add edges to chart
"Return a generator that will add edges licensed by this rule
and the given edges to the chart, one at a time.  Each
time the generator is resumed, it will either add a new
edge and yield that edge; or return.",,add new edge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,pass edges to apply()
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",,specify number of edges
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,sort given queue of edge objects
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,place edge
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,add edge to queue
"Sort the given queue of Edge objects, placing the edge that should
be tried first at the beginning of the queue.  This method
will be called after each Edge is added to the queue.",,call method
"queue (list(Edge)) – The queue of Edge objects to sort.  Each edge in
this queue is an edge that could be added to the chart by
the fundamental rule; but that has not yet been added.",,add edge to chart
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,provide extra information for sorting
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,sort queue
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",,use chart
"A demonstration of the probabilistic parsers.  The user is
prompted to select which demo to run, and how many parses should
be found; and then each parser is run on the same demo, and a
summary of the results are displayed.",,run parser on same demo
"A demonstration of the probabilistic parsers.  The user is
prompted to select which demo to run, and how many parses should
be found; and then each parser is run on the same demo, and a
summary of the results are displayed.",,find parses
"A demonstration of the probabilistic parsers.  The user is
prompted to select which demo to run, and how many parses should
be found; and then each parser is run on the same demo, and a
summary of the results are displayed.",,display summary of results
"A cell from the parse chart formed when performing the CYK algorithm.
Each cell keeps track of its x and y coordinates (though this will probably
be discarded), and a list of spans serving as the cell’s entries.",,perform cyk algorithm
"Appends the given span to the list of spans
representing the chart cell’s entries.",,append given span to list
"This parser returns the most probable projective parse derived from the
probabilistic dependency grammar derived from the train() method.  The
probabilistic model is an implementation of Eisner’s (1996) Model C, which
conditions on head-word, head-tag, child-word, and child-tag.  The decoding
uses a bottom-up chart-based span concatenation algorithm that’s identical
to the one utilized by the rule-based projective parser.",,return probable projective parse
"This parser returns the most probable projective parse derived from the
probabilistic dependency grammar derived from the train() method.  The
probabilistic model is an implementation of Eisner’s (1996) Model C, which
conditions on head-word, head-tag, child-word, and child-tag.  The decoding
uses a bottom-up chart-based span concatenation algorithm that’s identical
to the one utilized by the rule-based projective parser.",,use bottom-up chart-based span concatenation algorithm
"Computes the probability of a dependency graph based
on the parser’s probability model (defined by the parser’s
statistical dependency grammar).",,compute probability of dependency graph
"Concatenates the two spans in whichever way possible.  This
includes rightward concatenation (from the leftmost word of the
leftmost span to the rightmost word of the rightmost span) and
leftward concatenation (vice-versa) between adjacent spans.  Unlike
Eisner’s presentation of span concatenation, these spans do not
share or pivot on a particular word/word-index.",,include rightward concatenation between adjacent spans
"Concatenates the two spans in whichever way possible.  This
includes rightward concatenation (from the leftmost word of the
leftmost span to the rightmost word of the rightmost span) and
leftward concatenation (vice-versa) between adjacent spans.  Unlike
Eisner’s presentation of span concatenation, these spans do not
share or pivot on a particular word/word-index.",,include leftward concatenation between adjacent spans
"Parses the list of tokens subject to the projectivity constraint
and the productions in the parser’s grammar.  This uses a method
similar to the span-concatenation algorithm defined in Eisner (1996).
It returns the most probable parse derived from the parser’s
probabilistic dependency grammar.",,define  in eisner
"Parses the list of tokens subject to the projectivity constraint
and the productions in the parser’s grammar.  This uses a method
similar to the span-concatenation algorithm defined in Eisner (1996).
It returns the most probable parse derived from the parser’s
probabilistic dependency grammar.",,return probable parse
"A projective, rule-based, dependency parser.  A ProjectiveDependencyParser
is created with a DependencyGrammar, a set of productions specifying
word-to-word dependency relations.  The parse() method will then
return the set of all parses, in tree representation, for a given input
sequence of tokens.  Each parse must meet the requirements of the both
the grammar and the projectivity constraint which specifies that the
branches of the dependency tree are not allowed to cross.  Alternatively,
this can be understood as stating that each parent node and its children
in the parse tree form a continuous substring of the input sequence.",,specify word-to-word dependency relations
"A projective, rule-based, dependency parser.  A ProjectiveDependencyParser
is created with a DependencyGrammar, a set of productions specifying
word-to-word dependency relations.  The parse() method will then
return the set of all parses, in tree representation, for a given input
sequence of tokens.  Each parse must meet the requirements of the both
the grammar and the projectivity constraint which specifies that the
branches of the dependency tree are not allowed to cross.  Alternatively,
this can be understood as stating that each parent node and its children
in the parse tree form a continuous substring of the input sequence.",,create projectivedependencyparser with dependencygrammar
"A projective, rule-based, dependency parser.  A ProjectiveDependencyParser
is created with a DependencyGrammar, a set of productions specifying
word-to-word dependency relations.  The parse() method will then
return the set of all parses, in tree representation, for a given input
sequence of tokens.  Each parse must meet the requirements of the both
the grammar and the projectivity constraint which specifies that the
branches of the dependency tree are not allowed to cross.  Alternatively,
this can be understood as stating that each parent node and its children
in the parse tree form a continuous substring of the input sequence.",,return set in tree representation
"A projective, rule-based, dependency parser.  A ProjectiveDependencyParser
is created with a DependencyGrammar, a set of productions specifying
word-to-word dependency relations.  The parse() method will then
return the set of all parses, in tree representation, for a given input
sequence of tokens.  Each parse must meet the requirements of the both
the grammar and the projectivity constraint which specifies that the
branches of the dependency tree are not allowed to cross.  Alternatively,
this can be understood as stating that each parent node and its children
in the parse tree form a continuous substring of the input sequence.",,return set of parses
"A projective, rule-based, dependency parser.  A ProjectiveDependencyParser
is created with a DependencyGrammar, a set of productions specifying
word-to-word dependency relations.  The parse() method will then
return the set of all parses, in tree representation, for a given input
sequence of tokens.  Each parse must meet the requirements of the both
the grammar and the projectivity constraint which specifies that the
branches of the dependency tree are not allowed to cross.  Alternatively,
this can be understood as stating that each parent node and its children
in the parse tree form a continuous substring of the input sequence.",,return set for given input sequence
"A projective, rule-based, dependency parser.  A ProjectiveDependencyParser
is created with a DependencyGrammar, a set of productions specifying
word-to-word dependency relations.  The parse() method will then
return the set of all parses, in tree representation, for a given input
sequence of tokens.  Each parse must meet the requirements of the both
the grammar and the projectivity constraint which specifies that the
branches of the dependency tree are not allowed to cross.  Alternatively,
this can be understood as stating that each parent node and its children
in the parse tree form a continuous substring of the input sequence.",,specify requirements of grammar
"A projective, rule-based, dependency parser.  A ProjectiveDependencyParser
is created with a DependencyGrammar, a set of productions specifying
word-to-word dependency relations.  The parse() method will then
return the set of all parses, in tree representation, for a given input
sequence of tokens.  Each parse must meet the requirements of the both
the grammar and the projectivity constraint which specifies that the
branches of the dependency tree are not allowed to cross.  Alternatively,
this can be understood as stating that each parent node and its children
in the parse tree form a continuous substring of the input sequence.",,specify requirements of projectivity constraint
"Concatenates the two spans in whichever way possible.  This
includes rightward concatenation (from the leftmost word of the
leftmost span to the rightmost word of the rightmost span) and
leftward concatenation (vice-versa) between adjacent spans.  Unlike
Eisner’s presentation of span concatenation, these spans do not
share or pivot on a particular word/word-index.",,include rightward concatenation between adjacent spans
"Concatenates the two spans in whichever way possible.  This
includes rightward concatenation (from the leftmost word of the
leftmost span to the rightmost word of the rightmost span) and
leftward concatenation (vice-versa) between adjacent spans.  Unlike
Eisner’s presentation of span concatenation, these spans do not
share or pivot on a particular word/word-index.",,include leftward concatenation between adjacent spans
"Performs a projective dependency parse on the list of tokens using
a chart-based, span-concatenation algorithm similar to Eisner (1996).",,use chart-based span-concatenation algorithm similar
"A demonstration showing the creation of a DependencyGrammar
in which a specific number of modifiers is listed for a given
head.  This can further constrain the number of possible parses
created by a ProjectiveDependencyParser.",,show creation of dependencygrammar
"A demonstration showing the creation of a DependencyGrammar
in which a specific number of modifiers is listed for a given
head.  This can further constrain the number of possible parses
created by a ProjectiveDependencyParser.",,list specific number of modifiers
"A demonstration showing the creation of a DependencyGrammar
in which a specific number of modifiers is listed for a given
head.  This can further constrain the number of possible parses
created by a ProjectiveDependencyParser.",,list specific number for given head
"A demonstration showing the creation of a DependencyGrammar
in which a specific number of modifiers is listed for a given
head.  This can further constrain the number of possible parses
created by a ProjectiveDependencyParser.",,list dependencygrammar of modifiers
"A demonstration showing the creation of a DependencyGrammar
in which a specific number of modifiers is listed for a given
head.  This can further constrain the number of possible parses
created by a ProjectiveDependencyParser.",,list dependencygrammar for given head
"A demo showing the training and use of a projective
dependency parser.",,show training of projective dependency parser
"A demo showing the training and use of a projective
dependency parser.",,show use of projective dependency parser
"A demonstration showing the creation and use of a
DependencyGrammar to perform a projective dependency
parse.",,show creation of dependencygrammar
"A demonstration showing the creation and use of a
DependencyGrammar to perform a projective dependency
parse.",,show use of dependencygrammar
"A demonstration showing the creation and use of a
DependencyGrammar to perform a projective dependency
parse.",,perform projective dependency parse
"A simple top-down CFG parser that parses texts by recursively
expanding the fringe of a Tree, and matching it against a
text.",,expand fringe of tree
"A simple top-down CFG parser that parses texts by recursively
expanding the fringe of a Tree, and matching it against a
text.",,match  against text
"RecursiveDescentParser uses a list of tree locations called a
“frontier” to remember which subtrees have not yet been expanded
and which leaves have not yet been matched against the text.  Each
tree location consists of a list of child indices specifying the
path from the root of the tree to a subtree or a leaf; see the
reference documentation for Tree for more information
about tree locations.",,call frontier
"RecursiveDescentParser uses a list of tree locations called a
“frontier” to remember which subtrees have not yet been expanded
and which leaves have not yet been matched against the text.  Each
tree location consists of a list of child indices specifying the
path from the root of the tree to a subtree or a leaf; see the
reference documentation for Tree for more information
about tree locations.",,specify path from root
"RecursiveDescentParser uses a list of tree locations called a
“frontier” to remember which subtrees have not yet been expanded
and which leaves have not yet been matched against the text.  Each
tree location consists of a list of child indices specifying the
path from the root of the tree to a subtree or a leaf; see the
reference documentation for Tree for more information
about tree locations.",,specify path to subtree
"RecursiveDescentParser uses a list of tree locations called a
“frontier” to remember which subtrees have not yet been expanded
and which leaves have not yet been matched against the text.  Each
tree location consists of a list of child indices specifying the
path from the root of the tree to a subtree or a leaf; see the
reference documentation for Tree for more information
about tree locations.",,specify path to leaf
"When the parser begins parsing a text, it constructs a tree
containing only the start symbol, and a frontier containing the
location of the tree’s root node.  It then extends the tree to
cover the text, using the following recursive procedure:",,extend tree
"When the parser begins parsing a text, it constructs a tree
containing only the start symbol, and a frontier containing the
location of the tree’s root node.  It then extends the tree to
cover the text, using the following recursive procedure:",,use following recursive procedure
"If the frontier is empty, and the text is covered by the tree,
then return the tree as a possible parse.",,return tree as possible parse
"If the frontier is empty, and the text is not covered by the
tree, then return no parses.",,return parses
"If the first element of the frontier is a subtree, then
use CFG productions to “expand” it.  For each applicable
production, add the expanded subtree’s children to the
frontier, and recursively find all parses that can be
generated by the new tree and frontier.",,add children for applicable production
"If the first element of the frontier is a subtree, then
use CFG productions to “expand” it.  For each applicable
production, add the expanded subtree’s children to the
frontier, and recursively find all parses that can be
generated by the new tree and frontier.",,add children to frontier
"If the first element of the frontier is a subtree, then
use CFG productions to “expand” it.  For each applicable
production, add the expanded subtree’s children to the
frontier, and recursively find all parses that can be
generated by the new tree and frontier.",,find parses
"If the first element of the frontier is a subtree, then
use CFG productions to “expand” it.  For each applicable
production, add the expanded subtree’s children to the
frontier, and recursively find all parses that can be
generated by the new tree and frontier.",,generate parses
"If the first element of the frontier is a token, then “match”
it against the next token from the text.  Remove the token
from the frontier, and recursively find all parses that can be
generated by the new tree and frontier.",,match  against next token
"If the first element of the frontier is a token, then “match”
it against the next token from the text.  Remove the token
from the frontier, and recursively find all parses that can be
generated by the new tree and frontier.",,remove  from frontier
"If the first element of the frontier is a token, then “match”
it against the next token from the text.  Remove the token
from the frontier, and recursively find all parses that can be
generated by the new tree and frontier.",,find parses
"If the first element of the frontier is a token, then “match”
it against the next token from the text.  Remove the token
from the frontier, and recursively find all parses that can be
generated by the new tree and frontier.",,generate parses
The grammar used by this parser.,,use  by parser
"Set the level of tracing output that should be generated when
parsing a text.",,set level of tracing
"Set the level of tracing output that should be generated when
parsing a text.",,generate output
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",,generate tracing output
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",,produce more verbose
"A RecursiveDescentParser that allows you to step through the
parsing process, performing a single operation at a time.",,perform single operation at time
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",,use initialize method
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",,expand first element on frontier
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",,use single cfg production
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",,match first element on frontier
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",,expand operation
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",,match operation
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",,perform single expand
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",,perform match
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",,perform backtrack operation
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",,return set of parses
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",,find parses
"_history – A list of (rtext, tree, frontier) tripples,
containing the previous states of the parser.  This history is
used to implement the backtrack operation.",,implement backtrack operation
"_history – A list of (rtext, tree, frontier) tripples,
containing the previous states of the parser.  This history is
used to implement the backtrack operation.",,use history
"_tried_e – A record of all productions that have been tried
for a given tree.  This record is used by expand to perform
the next untried production.",,perform next untried production
"_tried_e – A record of all productions that have been tried
for a given tree.  This record is used by expand to perform
the next untried production.",,use record
"_tried_m – A record of what tokens have been matched for a
given tree.  This record is used by step to decide whether
or not to match a token.",,match tokens for given tree
"_tried_m – A record of what tokens have been matched for a
given tree.  This record is used by step to decide whether
or not to match a token.",,use record
"Return the parser to its state before the most recent
match or expand operation.  Calling undo repeatedly return
the parser to successively earlier states.  If no match or
expand operations have been performed, undo will make no
changes.",,return parser before most recent match
"Return the parser to its state before the most recent
match or expand operation.  Calling undo repeatedly return
the parser to successively earlier states.  If no match or
expand operations have been performed, undo will make no
changes.",,return parser to state
"Return the parser to its state before the most recent
match or expand operation.  Calling undo repeatedly return
the parser to successively earlier states.  If no match or
expand operations have been performed, undo will make no
changes.",,expand operation
"Return the parser to its state before the most recent
match or expand operation.  Calling undo repeatedly return
the parser to successively earlier states.  If no match or
expand operations have been performed, undo will make no
changes.",,perform match expand operations
"Expand the first element of the frontier.  In particular, if
the first element of the frontier is a subtree whose node type
is equal to production’s left hand side, then add a child
to that subtree for each element of production’s right hand
side.  If production is not specified, then use the first
untried expandable production.  If all expandable productions
have been tried, do nothing.",,expand first element of frontier
"Expand the first element of the frontier.  In particular, if
the first element of the frontier is a subtree whose node type
is equal to production’s left hand side, then add a child
to that subtree for each element of production’s right hand
side.  If production is not specified, then use the first
untried expandable production.  If all expandable productions
have been tried, do nothing.",,add child to subtree
"Expand the first element of the frontier.  In particular, if
the first element of the frontier is a subtree whose node type
is equal to production’s left hand side, then add a child
to that subtree for each element of production’s right hand
side.  If production is not specified, then use the first
untried expandable production.  If all expandable productions
have been tried, do nothing.",,use first untried expandable production
"The production used to expand the frontier, if an
expansion was performed.  If no expansion was performed,
return None.",,expand frontier
"The production used to expand the frontier, if an
expansion was performed.  If no expansion was performed,
return None.",,perform expansion
"The production used to expand the frontier, if an
expansion was performed.  If no expansion was performed,
return None.",,return none
"The production used to expand the frontier, if an
expansion was performed.  If no expansion was performed,
return None.",,perform expansion
"Start parsing a given text.  This sets the parser’s tree to
the start symbol, its frontier to the root node, and its
remaining text to token['SUBTOKENS'].",,set tree to start symbol
"Start parsing a given text.  This sets the parser’s tree to
the start symbol, its frontier to the root node, and its
remaining text to token['SUBTOKENS'].",,set tree to ]
"Start parsing a given text.  This sets the parser’s tree to
the start symbol, its frontier to the root node, and its
remaining text to token['SUBTOKENS'].",,set tree to root node
"Start parsing a given text.  This sets the parser’s tree to
the start symbol, its frontier to the root node, and its
remaining text to token['SUBTOKENS'].",,set remaining text to start symbol
"Start parsing a given text.  This sets the parser’s tree to
the start symbol, its frontier to the root node, and its
remaining text to token['SUBTOKENS'].",,set remaining text to ]
"Start parsing a given text.  This sets the parser’s tree to
the start symbol, its frontier to the root node, and its
remaining text to token['SUBTOKENS'].",,set remaining text to root node
"Start parsing a given text.  This sets the parser’s tree to
the start symbol, its frontier to the root node, and its
remaining text to token['SUBTOKENS'].",,set frontier to start symbol
"Start parsing a given text.  This sets the parser’s tree to
the start symbol, its frontier to the root node, and its
remaining text to token['SUBTOKENS'].",,set frontier to ]
"Start parsing a given text.  This sets the parser’s tree to
the start symbol, its frontier to the root node, and its
remaining text to token['SUBTOKENS'].",,set frontier to root node
"The token matched, if a match operation was
performed.  If no match was performed, return None",,perform match operation
"The token matched, if a match operation was
performed.  If no match was performed, return None",,return none
"The token matched, if a match operation was
performed.  If no match was performed, return None",,perform match
"An iterator of the parses that have been found by this
parser so far.",,find parses
"Perform a single parsing operation.  If an untried match is
possible, then perform the match, and return the matched
token.  If an untried expansion is possible, then perform the
expansion, and return the production that it is based on.  If
backtracking is possible, then backtrack, and return True.
Otherwise, return None.",,perform single parsing operation
"Perform a single parsing operation.  If an untried match is
possible, then perform the match, and return the matched
token.  If an untried expansion is possible, then perform the
expansion, and return the production that it is based on.  If
backtracking is possible, then backtrack, and return True.
Otherwise, return None.",,perform match
"Perform a single parsing operation.  If an untried match is
possible, then perform the match, and return the matched
token.  If an untried expansion is possible, then perform the
expansion, and return the production that it is based on.  If
backtracking is possible, then backtrack, and return True.
Otherwise, return None.",,return matched token
"Perform a single parsing operation.  If an untried match is
possible, then perform the match, and return the matched
token.  If an untried expansion is possible, then perform the
expansion, and return the production that it is based on.  If
backtracking is possible, then backtrack, and return True.
Otherwise, return None.",,perform expansion
"Perform a single parsing operation.  If an untried match is
possible, then perform the match, and return the matched
token.  If an untried expansion is possible, then perform the
expansion, and return the production that it is based on.  If
backtracking is possible, then backtrack, and return True.
Otherwise, return None.",,return production
"Perform a single parsing operation.  If an untried match is
possible, then perform the match, and return the matched
token.  If an untried expansion is possible, then perform the
expansion, and return the production that it is based on.  If
backtracking is possible, then backtrack, and return True.
Otherwise, return None.",,return none
"None if no operation was performed; a token if a match
was performed; a production if an expansion was performed;
and True if a backtrack operation was performed.",,perform operation
"None if no operation was performed; a token if a match
was performed; a production if an expansion was performed;
and True if a backtrack operation was performed.",,perform match
"None if no operation was performed; a token if a match
was performed; a production if an expansion was performed;
and True if a backtrack operation was performed.",,perform expansion
"None if no operation was performed; a token if a match
was performed; a production if an expansion was performed;
and True if a backtrack operation was performed.",,perform backtrack operation
"A partial structure for the text that is
currently being parsed.  The elements specified by the
frontier have not yet been expanded or matched.",,match elements
"A simple bottom-up CFG parser that uses two operations, “shift”
and “reduce”, to find a single parse for a text.",,use operations
"A simple bottom-up CFG parser that uses two operations, “shift”
and “reduce”, to find a single parse for a text.",,use simple bottom-up cfg parser
"A simple bottom-up CFG parser that uses two operations, “shift”
and “reduce”, to find a single parse for a text.",,find single parse for text
"ShiftReduceParser maintains a stack, which records the
structure of a portion of the text.  This stack is a list of
strings and Trees that collectively cover a portion of
the text.  For example, while parsing the sentence “the dog saw
the man” with a typical grammar, ShiftReduceParser will produce
the following stack, which covers “the dog saw”:",,produce following stack
"ShiftReduceParser attempts to extend the stack to cover the
entire text, and to combine the stack elements into a single tree,
producing a complete parse for the sentence.",,extend stack
"ShiftReduceParser attempts to extend the stack to cover the
entire text, and to combine the stack elements into a single tree,
producing a complete parse for the sentence.",,combine stack elements into single tree
"ShiftReduceParser attempts to extend the stack to cover the
entire text, and to combine the stack elements into a single tree,
producing a complete parse for the sentence.",,produce complete parse for sentence
"Initially, the stack is empty.  It is extended to cover the text,
from left to right, by repeatedly applying two operations:",,apply operations
"“shift” moves a token from the beginning of the text to the
end of the stack.",,move  from beginning
"Often, more than one operation can be performed on a given stack.
In this case, ShiftReduceParser uses the following heuristics
to decide which operation to perform:",,perform operation on given stack
"Often, more than one operation can be performed on a given stack.
In this case, ShiftReduceParser uses the following heuristics
to decide which operation to perform:",,use  in case
"If multiple reductions are available, then apply the reduction
whose CFG production is listed earliest in the grammar.",,apply reduction
"If multiple reductions are available, then apply the reduction
whose CFG production is listed earliest in the grammar.",,list cfg production
"Note that these heuristics are not guaranteed to choose an
operation that leads to a parse of the text.  Also, if multiple
parses exists, ShiftReduceParser will return at most one of
them.",,choose operation
The grammar used by this parser.,,use  by parser
"Set the level of tracing output that should be generated when
parsing a text.",,set level of tracing
"Set the level of tracing output that should be generated when
parsing a text.",,generate output
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",,generate tracing output
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",,produce more verbose
"A ShiftReduceParser that allows you to setp through the parsing
process, performing a single operation at a time.  It also allows
you to change the parser’s grammar midway through parsing a text.",,perform single operation at time
"A ShiftReduceParser that allows you to setp through the parsing
process, performing a single operation at a time.  It also allows
you to change the parser’s grammar midway through parsing a text.",,change grammar
"The initialize method is used to start parsing a text.
shift performs a single shift operation, and reduce performs
a single reduce operation.  step will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  parses returns the set of parses that have been
found by the parser.",,use initialize method
"The initialize method is used to start parsing a text.
shift performs a single shift operation, and reduce performs
a single reduce operation.  step will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  parses returns the set of parses that have been
found by the parser.",,perform single shift operation
"The initialize method is used to start parsing a text.
shift performs a single shift operation, and reduce performs
a single reduce operation.  step will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  parses returns the set of parses that have been
found by the parser.",,perform single shift operation
"The initialize method is used to start parsing a text.
shift performs a single shift operation, and reduce performs
a single reduce operation.  step will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  parses returns the set of parses that have been
found by the parser.",,perform single shift operation
"The initialize method is used to start parsing a text.
shift performs a single shift operation, and reduce performs
a single reduce operation.  step will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  parses returns the set of parses that have been
found by the parser.",,return set of parses
"The initialize method is used to start parsing a text.
shift performs a single shift operation, and reduce performs
a single reduce operation.  step will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  parses returns the set of parses that have been
found by the parser.",,find parses
"_history – A list of (stack, remaining_text) pairs,
containing all of the previous states of the parser.  This
history is used to implement the undo operation.",,implement undo operation
"_history – A list of (stack, remaining_text) pairs,
containing all of the previous states of the parser.  This
history is used to implement the undo operation.",,use history
"Start parsing a given text.  This sets the parser’s stack to
[] and sets its remaining text to tokens.",,set stack
"Start parsing a given text.  This sets the parser’s stack to
[] and sets its remaining text to tokens.",,set remaining text to tokens
"An iterator of the parses that have been found by this
parser so far.",,find parses
"Use production to combine the rightmost stack elements into
a single Tree.  If production does not match the
rightmost stack elements, then do nothing.",,use production
"The production used to reduce the stack, if a
reduction was performed.  If no reduction was performed,
return None.",,perform reduction
"The production used to reduce the stack, if a
reduction was performed.  If no reduction was performed,
return None.",,return none
"The production used to reduce the stack, if a
reduction was performed.  If no reduction was performed,
return None.",,perform reduction
"Move a token from the beginning of the remaining text to the
end of the stack.  If there are no more tokens in the
remaining text, then do nothing.",,move  from beginning
"Perform a single parsing operation.  If a reduction is
possible, then perform that reduction, and return the
production that it is based on.  Otherwise, if a shift is
possible, then perform it, and return True.  Otherwise,
return False.",,perform single parsing operation
"Perform a single parsing operation.  If a reduction is
possible, then perform that reduction, and return the
production that it is based on.  Otherwise, if a shift is
possible, then perform it, and return True.  Otherwise,
return False.",,perform reduction
"Perform a single parsing operation.  If a reduction is
possible, then perform that reduction, and return the
production that it is based on.  Otherwise, if a shift is
possible, then perform it, and return True.  Otherwise,
return False.",,return production
"Perform a single parsing operation.  If a reduction is
possible, then perform that reduction, and return the
production that it is based on.  Otherwise, if a shift is
possible, then perform it, and return True.  Otherwise,
return False.",,return false
"False if no operation was performed; True if a shift was
performed; and the CFG production used to reduce if a
reduction was performed.",,perform operation
"False if no operation was performed; True if a shift was
performed; and the CFG production used to reduce if a
reduction was performed.",,perform shift
"False if no operation was performed; True if a shift was
performed; and the CFG production used to reduce if a
reduction was performed.",,perform reduction
"Return the parser to its state before the most recent
shift or reduce operation.  Calling undo repeatedly return
the parser to successively earlier states.  If no shift or
reduce operations have been performed, undo will make no
changes.",,return parser before most recent shift
"Return the parser to its state before the most recent
shift or reduce operation.  Calling undo repeatedly return
the parser to successively earlier states.  If no shift or
reduce operations have been performed, undo will make no
changes.",,return parser to state
"Use StanfordParser to parse multiple sentences. Takes multiple sentences as a
list where each sentence is a list of words.
Each sentence will be automatically tagged with this StanfordParser instance’s
tagger.
If whitespaces exists inside a token, then the token will be treated as
separate tokens.",,use stanfordparser
"Use StanfordParser to parse a sentence. Takes a sentence as a string;
before parsing, it will be automatically tokenized and tagged by
the Stanford Parser.",,use stanfordparser
"Use StanfordParser to parse multiple sentences. Takes multiple sentences as a
list of strings.
Each sentence will be automatically tokenized and tagged by the Stanford Parser.",,use stanfordparser
"Use StanfordParser to parse a sentence. Takes a sentence as a list of
(word, tag) tuples; the sentence must have already been tokenized and
tagged.",,use stanfordparser
"Use StanfordParser to parse multiple sentences. Takes multiple sentences
where each sentence is a list of (word, tag) tuples.
The sentences must have already been tokenized and tagged.",,use stanfordparser
"Currently unimplemented because the neural dependency parser (and
the StanfordCoreNLP pipeline class) doesn’t support passing in pre-
tagged tokens.",,pass  in pre
"Class for holding configuration which is the partial analysis of the input sentence.
The transition based parser aims at finding set of operators that transfer the initial
configuration to the terminal configuration.",,find set of operators
Buffer: for storing remaining input words,,store remaining input words
This class also provides a method to represent a configuration as list of features.,,provide method
"Extract the set of features for the current configuration. Implement standard features as describe in
Table 3.2 (page 31) in Dependency Parsing book by Sandra Kubler, Ryan McDonal, Joakim Nivre.
Please note that these features are very basic.
:return: list(str)",,describe  in table
"Extract the set of features for the current configuration. Implement standard features as describe in
Table 3.2 (page 31) in Dependency Parsing book by Sandra Kubler, Ryan McDonal, Joakim Nivre.
Please note that these features are very basic.
:return: list(str)",,describe  in dependency parsing book
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",,define set of transition
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",,get configuration note
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",,apply set of transition
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",,apply set to configuration
Class for transition based parser. Implement 2 algorithms which are “arc-standard” and “arc-eager”,,implement algorithms
":param depgraphs : list of DependencyGraph as the training data
:type depgraphs : DependencyGraph
:param modelfile : file name to save the trained model
:type modelfile : str",,save trained model
"###################### Check The Transition #######################
Check the Initialized Configuration
>>> print(conf)
Stack : [0]  Buffer : [1, 2, 3, 4, 5, 6, 7, 8, 9]   Arcs : []",,check transition #######################
"###################### Check The Transition #######################
Check the Initialized Configuration
>>> print(conf)
Stack : [0]  Buffer : [1, 2, 3, 4, 5, 6, 7, 8, 9]   Arcs : []",,check initialized
"A. Check the ARC-STANDARD training
>>> import tempfile
>>> import os
>>> input_file = tempfile.NamedTemporaryFile(prefix=’transition_parse.train’, dir=tempfile.gettempdir(), delete=False)",,check arc-standard training
Check the ARC-EAGER training,,check arc-eager training
Check the ARC-STANDARD parser,,check arc-standard parser
Unit tests for  CFG.,,test  for cfg
"The result information is followed by a colon, and then the sentence.
Empty lines and lines beginning with a comment char are ignored.",,ignore empty lines
"The result information is followed by a colon, and then the sentence.
Empty lines and lines beginning with a comment char are ignored.",,ignore lines
"Load a grammar from a file, and build a parser based on that grammar.
The parser depends on the grammar format, and might also depend
on properties of the grammar itself.",,load grammar from file
"grammar_url (str) – A URL specifying where the grammar is located.
The default protocol is ""nltk:"", which searches for the file
in the the NLTK data package.",,locate grammar
"grammar_url (str) – A URL specifying where the grammar is located.
The default protocol is ""nltk:"", which searches for the file
in the the NLTK data package.",,"search "" for file"
"trace (int) – The level of tracing that should be used when
parsing a text.  0 will generate no tracing output;
and higher numbers will produce more verbose tracing output.",,generate tracing output
"trace (int) – The level of tracing that should be used when
parsing a text.  0 will generate no tracing output;
and higher numbers will produce more verbose tracing output.",,produce more verbose
"parser – The class used for parsing; should be ChartParser
or a subclass.
If None, the class depends on the grammar format.",,use  for parsing
"chart_class – The class used for storing the chart;
should be Chart or a subclass.
Only used for CFGs and feature CFGs.
If None, the chart class depends on the grammar format.",,store chart
"chart_class – The class used for storing the chart;
should be Chart or a subclass.
Only used for CFGs and feature CFGs.
If None, the chart class depends on the grammar format.",,use  for storing
"chart_class – The class used for storing the chart;
should be Chart or a subclass.
Only used for CFGs and feature CFGs.
If None, the chart class depends on the grammar format.",,use  for cfgs
"chart_class – The class used for storing the chart;
should be Chart or a subclass.
Only used for CFGs and feature CFGs.
If None, the chart class depends on the grammar format.",,use  for feature
"beam_size (int) – The maximum length for the parser’s edge queue.
Only used for probabilistic CFGs.",,use  for probabilistic cfgs
"load_args – Keyword parameters used when loading the grammar.
See data.load for more information.",,load grammar
"A module to convert the a POS tagged document stream
(i.e. list of list of tuples, a list of sentences) and yield lines
in CONLL format. This module yields one line per word and two newlines
for end of sentence.",,convert pos
"A bottom-up PCFG parser that uses dynamic programming to find
the single most likely parse for a text.  The ViterbiParser parser
parses texts by filling in a “most likely constituent table”.
This table records the most probable tree representation for any
given span and node value.  In particular, it has an entry for
every start index, end index, and node value, recording the most
likely subtree that spans from the start index to the end index,
and has the given node value.",,use dynamic programming
"A bottom-up PCFG parser that uses dynamic programming to find
the single most likely parse for a text.  The ViterbiParser parser
parses texts by filling in a “most likely constituent table”.
This table records the most probable tree representation for any
given span and node value.  In particular, it has an entry for
every start index, end index, and node value, recording the most
likely subtree that spans from the start index to the end index,
and has the given node value.",,find single likely parse for text
"A bottom-up PCFG parser that uses dynamic programming to find
the single most likely parse for a text.  The ViterbiParser parser
parses texts by filling in a “most likely constituent table”.
This table records the most probable tree representation for any
given span and node value.  In particular, it has an entry for
every start index, end index, and node value, recording the most
likely subtree that spans from the start index to the end index,
and has the given node value.",,fill  in likely constituent table
"The ViterbiParser parser fills in this table incrementally.  It starts
by filling in all entries for constituents that span one element
of text (i.e., entries where the end index is one greater than the
start index).  After it has filled in all table entries for
constituents that span one element of text, it fills in the
entries for constitutants that span two elements of text.  It
continues filling in the entries for constituents spanning larger
and larger portions of the text, until the entire table has been
filled.  Finally, it returns the table entry for a constituent
spanning the entire text, whose node value is the grammar’s start
symbol.",,fill  in table incrementally
"The ViterbiParser parser fills in this table incrementally.  It starts
by filling in all entries for constituents that span one element
of text (i.e., entries where the end index is one greater than the
start index).  After it has filled in all table entries for
constituents that span one element of text, it fills in the
entries for constitutants that span two elements of text.  It
continues filling in the entries for constituents spanning larger
and larger portions of the text, until the entire table has been
filled.  Finally, it returns the table entry for a constituent
spanning the entire text, whose node value is the grammar’s start
symbol.",,fill  in entries
"The ViterbiParser parser fills in this table incrementally.  It starts
by filling in all entries for constituents that span one element
of text (i.e., entries where the end index is one greater than the
start index).  After it has filled in all table entries for
constituents that span one element of text, it fills in the
entries for constitutants that span two elements of text.  It
continues filling in the entries for constituents spanning larger
and larger portions of the text, until the entire table has been
filled.  Finally, it returns the table entry for a constituent
spanning the entire text, whose node value is the grammar’s start
symbol.",,fill  in table entries
"The ViterbiParser parser fills in this table incrementally.  It starts
by filling in all entries for constituents that span one element
of text (i.e., entries where the end index is one greater than the
start index).  After it has filled in all table entries for
constituents that span one element of text, it fills in the
entries for constitutants that span two elements of text.  It
continues filling in the entries for constituents spanning larger
and larger portions of the text, until the entire table has been
filled.  Finally, it returns the table entry for a constituent
spanning the entire text, whose node value is the grammar’s start
symbol.",,fill  for constituents
"The ViterbiParser parser fills in this table incrementally.  It starts
by filling in all entries for constituents that span one element
of text (i.e., entries where the end index is one greater than the
start index).  After it has filled in all table entries for
constituents that span one element of text, it fills in the
entries for constitutants that span two elements of text.  It
continues filling in the entries for constituents spanning larger
and larger portions of the text, until the entire table has been
filled.  Finally, it returns the table entry for a constituent
spanning the entire text, whose node value is the grammar’s start
symbol.",,fill  in entries
"The ViterbiParser parser fills in this table incrementally.  It starts
by filling in all entries for constituents that span one element
of text (i.e., entries where the end index is one greater than the
start index).  After it has filled in all table entries for
constituents that span one element of text, it fills in the
entries for constitutants that span two elements of text.  It
continues filling in the entries for constituents spanning larger
and larger portions of the text, until the entire table has been
filled.  Finally, it returns the table entry for a constituent
spanning the entire text, whose node value is the grammar’s start
symbol.",,fill  in entries
"The ViterbiParser parser fills in this table incrementally.  It starts
by filling in all entries for constituents that span one element
of text (i.e., entries where the end index is one greater than the
start index).  After it has filled in all table entries for
constituents that span one element of text, it fills in the
entries for constitutants that span two elements of text.  It
continues filling in the entries for constituents spanning larger
and larger portions of the text, until the entire table has been
filled.  Finally, it returns the table entry for a constituent
spanning the entire text, whose node value is the grammar’s start
symbol.",,fill entire table
"The ViterbiParser parser fills in this table incrementally.  It starts
by filling in all entries for constituents that span one element
of text (i.e., entries where the end index is one greater than the
start index).  After it has filled in all table entries for
constituents that span one element of text, it fills in the
entries for constitutants that span two elements of text.  It
continues filling in the entries for constituents spanning larger
and larger portions of the text, until the entire table has been
filled.  Finally, it returns the table entry for a constituent
spanning the entire text, whose node value is the grammar’s start
symbol.",,return table entry for constituent
"In order to find the most likely constituent with a given span and
node value, the ViterbiParser parser considers all productions that
could produce that node value.  For each production, it finds all
children that collectively cover the span and have the node values
specified by the production’s right hand side.  If the probability
of the tree formed by applying the production to the children is
greater than the probability of the current entry in the table,
then the table is updated with this new tree.",,find likely constituent with given span
"In order to find the most likely constituent with a given span and
node value, the ViterbiParser parser considers all productions that
could produce that node value.  For each production, it finds all
children that collectively cover the span and have the node values
specified by the production’s right hand side.  If the probability
of the tree formed by applying the production to the children is
greater than the probability of the current entry in the table,
then the table is updated with this new tree.",,find likely constituent with node value
"In order to find the most likely constituent with a given span and
node value, the ViterbiParser parser considers all productions that
could produce that node value.  For each production, it finds all
children that collectively cover the span and have the node values
specified by the production’s right hand side.  If the probability
of the tree formed by applying the production to the children is
greater than the probability of the current entry in the table,
then the table is updated with this new tree.",,produce node value
"In order to find the most likely constituent with a given span and
node value, the ViterbiParser parser considers all productions that
could produce that node value.  For each production, it finds all
children that collectively cover the span and have the node values
specified by the production’s right hand side.  If the probability
of the tree formed by applying the production to the children is
greater than the probability of the current entry in the table,
then the table is updated with this new tree.",,produce productions
"In order to find the most likely constituent with a given span and
node value, the ViterbiParser parser considers all productions that
could produce that node value.  For each production, it finds all
children that collectively cover the span and have the node values
specified by the production’s right hand side.  If the probability
of the tree formed by applying the production to the children is
greater than the probability of the current entry in the table,
then the table is updated with this new tree.",,find children for production
"In order to find the most likely constituent with a given span and
node value, the ViterbiParser parser considers all productions that
could produce that node value.  For each production, it finds all
children that collectively cover the span and have the node values
specified by the production’s right hand side.  If the probability
of the tree formed by applying the production to the children is
greater than the probability of the current entry in the table,
then the table is updated with this new tree.",,apply production to children
"In order to find the most likely constituent with a given span and
node value, the ViterbiParser parser considers all productions that
could produce that node value.  For each production, it finds all
children that collectively cover the span and have the node values
specified by the production’s right hand side.  If the probability
of the tree formed by applying the production to the children is
greater than the probability of the current entry in the table,
then the table is updated with this new tree.",,update table with new tree
"_trace – The level of tracing output that should be generated
when parsing a text.",,generate output
The grammar used by this parser.,,use  by parser
"Set the level of tracing output that should be generated when
parsing a text.",,set level of tracing
"Set the level of tracing output that should be generated when
parsing a text.",,generate output
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",,generate tracing output
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",,produce more verbose
"A demonstration of the probabilistic parsers.  The user is
prompted to select which demo to run, and how many parses should
be found; and then each parser is run on the same demo, and a
summary of the results are displayed.",,run parser on same demo
"A demonstration of the probabilistic parsers.  The user is
prompted to select which demo to run, and how many parses should
be found; and then each parser is run on the same demo, and a
summary of the results are displayed.",,find parses
"A demonstration of the probabilistic parsers.  The user is
prompted to select which demo to run, and how many parses should
be found; and then each parser is run on the same demo, and a
summary of the results are displayed.",,display summary of results
"Classes and interfaces for producing tree structures that represent
the internal organization of a text.  This task is known as “parsing”
the text, and the resulting tree structures are called the text’s
“parses”.  Typically, the text is a single sentence, and the tree
structure represents the syntactic structure of the sentence.
However, parsers can also be used in other domains.  For example,
parsers can be used to derive the morphological structure of the
morphemes that make up a word, or to derive the discourse structure
for a set of utterances.",,produce tree structures
"Classes and interfaces for producing tree structures that represent
the internal organization of a text.  This task is known as “parsing”
the text, and the resulting tree structures are called the text’s
“parses”.  Typically, the text is a single sentence, and the tree
structure represents the syntactic structure of the sentence.
However, parsers can also be used in other domains.  For example,
parsers can be used to derive the morphological structure of the
morphemes that make up a word, or to derive the discourse structure
for a set of utterances.",,call parses
"Classes and interfaces for producing tree structures that represent
the internal organization of a text.  This task is known as “parsing”
the text, and the resulting tree structures are called the text’s
“parses”.  Typically, the text is a single sentence, and the tree
structure represents the syntactic structure of the sentence.
However, parsers can also be used in other domains.  For example,
parsers can be used to derive the morphological structure of the
morphemes that make up a word, or to derive the discourse structure
for a set of utterances.",,call resulting tree structures
"Classes and interfaces for producing tree structures that represent
the internal organization of a text.  This task is known as “parsing”
the text, and the resulting tree structures are called the text’s
“parses”.  Typically, the text is a single sentence, and the tree
structure represents the syntactic structure of the sentence.
However, parsers can also be used in other domains.  For example,
parsers can be used to derive the morphological structure of the
morphemes that make up a word, or to derive the discourse structure
for a set of utterances.",,use parsers in other domains
"Classes and interfaces for producing tree structures that represent
the internal organization of a text.  This task is known as “parsing”
the text, and the resulting tree structures are called the text’s
“parses”.  Typically, the text is a single sentence, and the tree
structure represents the syntactic structure of the sentence.
However, parsers can also be used in other domains.  For example,
parsers can be used to derive the morphological structure of the
morphemes that make up a word, or to derive the discourse structure
for a set of utterances.",,use parsers
"Sometimes, a single piece of text can be represented by more than one
tree structure.  Texts represented by more than one tree structure are
called “ambiguous” texts.  Note that there are actually two ways in
which a text can be ambiguous:",,call ambiguous texts
"Sometimes, a single piece of text can be represented by more than one
tree structure.  Texts represented by more than one tree structure are
called “ambiguous” texts.  Note that there are actually two ways in
which a text can be ambiguous:",,call texts
"The parser module defines ParserI, a standard interface for parsing
texts; and two simple implementations of that interface,
ShiftReduceParser and RecursiveDescentParser.  It also contains
three sub-modules for specialized kinds of parsing:",,define parseri
"nltk.parser.chart defines chart parsing, which uses dynamic
programming to efficiently parse texts.",,define chart parsing
"nltk.parser.chart defines chart parsing, which uses dynamic
programming to efficiently parse texts.",,use dynamic programming to efficiently parse texts
"nltk.parser.chart defines chart parsing, which uses dynamic
programming to efficiently parse texts.",,use chart parsing to efficiently parse texts
"nltk.parser.probabilistic defines probabilistic parsing, which
associates a probability with each parse.",,define probabilistic parsing
