When possible this list is sorted from most likely to least likely.,nltk.parse.api.
When possible this list is sorted from most likely to least likely.,ParserI
The grammar used by this parser.,grammar
When possible this list is sorted from most likely to least likely.,parse
When possible this list is sorted from most likely to least likely.,parse_all
When possible this list is sorted from most likely to least likely.,parse_one
When possible this list is sorted from most likely to least likely.,parse_sents
An iterator that generates parse trees for the sentence.,nltk.parse.bllip.
An iterator that generates parse trees for the sentence.,BllipParser
A BllipParser object using the parser and reranker,from_unified_model_dir
An iterator that generates parse trees for the sentence.,tagged_parse
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",nltk.parse.chart.
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",AbstractChartRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",apply
"Return a generator that will add all edges licensed by
this rule, given the edges that are currently in the
chart, one at a time.  Each time the generator is resumed,
it will either add a new edge and yield that edge; or return.",apply_everywhere
"A ChartParser using a bottom-up parsing strategy.
See ChartParser for more information.",BottomUpChartParser
"A ChartParser using a bottom-up left-corner parsing strategy.
This strategy is often more efficient than standard bottom-up.
See ChartParser for more information.",BottomUpLeftCornerChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",BottomUpPredictCombineRule
"This is like BottomUpPredictRule, but it also applies
the FundamentalRule to the resulting edge.",NUM_EDGES
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",BottomUpPredictRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",CachedTopDownPredictRule
"child_pointer_lists (sequence of tuple(EdgeI)) – A sequence of lists of the edges that
were used to form this edge.  This list is used to reconstruct
the trees (or partial trees) that are associated with edge.",Chart
"Return the set of child pointer lists for the given edge.
Each child pointer list is a list of edges that have
been used to form this edge.",child_pointer_lists
"Return the set of child pointer lists for the given edge.
Each child pointer list is a list of edges that have
been used to form this edge.",dot_digraph
"Return a list of all edges in this chart.  New edges
that are added to the chart after the call to edges()
will not be contained in this list.",edges
"Return a list of all edges in this chart.  New edges
that are added to the chart after the call to edges()
will not be contained in this list.",initialize
"child_pointer_lists (sequence of tuple(EdgeI)) – A sequence of lists of the edges that
were used to form this edge.  This list is used to reconstruct
the trees (or partial trees) that are associated with edge.",insert
"Add a new edge to the chart, using a pointer to the previous edge.",insert_with_backpointer
"Return an iterator over the edges in this chart.  It is
not guaranteed that new edges which are added to the
chart before the iterator is exhausted will also be generated.",iteredges
Return the leaf value of the word at the given index.,leaf
Return the leaf value of the word at the given index.,leaves
Return the number of edges contained in this chart.,num_edges
Return the number of edges contained in this chart.,num_leaves
Return the number of edges contained in this chart.,parses
Return the number of edges contained in this chart.,pretty_format
"Return a pretty-printed string representation of a given edge
in this chart.",pretty_format_edge
"Return a pretty-printed string representation of this
chart’s leaves.  This string can be used as a header
for calls to pretty_format_edge.",pretty_format_leaves
"Return an iterator over the edges in this chart.  Any
new edges that are added to the chart before the iterator
is exahusted will also be generated.  restrictions
can be used to restrict the set of edges that will be
generated.",select
"If two trees share a common subtree, then the same
Tree may be used to encode that subtree in
both trees.  If you need to eliminate this subtree
sharing, then create a deep copy of each tree.",trees
When possible this list is sorted from most likely to least likely.,ChartParser
"Return the final parse Chart from which all possible
parse trees can be extracted.",chart_parse
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",ChartRuleI
"Return a tuple (s, e), where tokens[s:e] is the
portion of the sentence that is consistent with this
edge’s structure.",EdgeI
"Return this edge’s dot position, which indicates how much of
the hypothesized structure is consistent with the
sentence.  In particular, self.rhs[:dot] is consistent
with tokens[self.start():self.end()].",dot
"Return this edge’s dot position, which indicates how much of
the hypothesized structure is consistent with the
sentence.  In particular, self.rhs[:dot] is consistent
with tokens[self.start():self.end()].",end
"Return this edge’s dot position, which indicates how much of
the hypothesized structure is consistent with the
sentence.  In particular, self.rhs[:dot] is consistent
with tokens[self.start():self.end()].",is_complete
"Return this edge’s dot position, which indicates how much of
the hypothesized structure is consistent with the
sentence.  In particular, self.rhs[:dot] is consistent
with tokens[self.start():self.end()].",is_incomplete
"Return this edge’s dot position, which indicates how much of
the hypothesized structure is consistent with the
sentence.  In particular, self.rhs[:dot] is consistent
with tokens[self.start():self.end()].",length
"Return this edge’s left-hand side, which specifies what kind
of structure is hypothesized by this edge.",lhs
"Return the element of this edge’s right-hand side that
immediately follows its dot.",nextsym
"Return this edge’s right-hand side, which specifies
the content of the structure hypothesized by this edge.",rhs
"Return a tuple (s, e), where tokens[s:e] is the
portion of the sentence that is consistent with this
edge’s structure.",span
"Return a tuple (s, e), where tokens[s:e] is the
portion of the sentence that is consistent with this
edge’s structure.",start
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",EmptyPredictRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FilteredBottomUpPredictCombineRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FilteredSingleEdgeFundamentalRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FundamentalRule
"Return a tuple (s, e), where tokens[s:e] is the
portion of the sentence that is consistent with this
edge’s structure.",LeafEdge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",LeafInitRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",LeftCornerChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",SingleEdgeFundamentalRule
When possible this list is sorted from most likely to least likely.,SteppingChartParser
"_restart – Records whether the parser’s strategy, grammar,
or chart has been changed.  If so, then step must restart
the parsing algorithm.",chart
Return the chart rule used to generate the most recent edge.,current_chartrule
Load a given chart into the chart parser.,set_chart
Change the grammar used by the parser.,set_grammar
"strategy (list(ChartRuleI)) – A list of rules that should be used to decide
what edges to add to the chart.",set_strategy
"Note that this generator never terminates, since the grammar
or strategy might be changed to values that would add new
edges.  Instead, it yields None when no more edges can be
added with the current strategy and grammar.",step
"Note that this generator never terminates, since the grammar
or strategy might be changed to values that would add new
edges.  Instead, it yields None when no more edges can be
added with the current strategy and grammar.",strategy
"A ChartParser using a top-down parsing strategy.
See ChartParser for more information.",TopDownChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",TopDownInitRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",TopDownPredictRule
"Return a tuple (s, e), where tokens[s:e] is the
portion of the sentence that is consistent with this
edge’s structure.",TreeEdge
"Return this edge’s dot position, which indicates how much of
the hypothesized structure is consistent with the
sentence.  In particular, self.rhs[:dot] is consistent
with tokens[self.start():self.end()].",from_production
"Return a new TreeEdge formed from this edge.
The new edge’s dot position is increased by 1,
and its end index will be replaced by new_end.",move_dot_forward
"Return a tuple (s, e), where tokens[s:e] is the
portion of the sentence that is consistent with this
edge’s structure.",demo
"Return a tuple (s, e), where tokens[s:e] is the
portion of the sentence that is consistent with this
edge’s structure.",demo_grammar
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",nltk.parse.corenlp.
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",CoreNLPDependencyParser
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",CoreNLPParser
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",CoreNLPServer
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",stop
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",CoreNLPServerError
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",GenericCoreNLPParser
The text might contain several sentences which will be split by CoreNLP.,parse_text
The text might contain several sentences which will be split by CoreNLP.,raw_parse
The text might contain several sentences which will be split by CoreNLP.,raw_parse_sents
The text might contain several sentences which will be split by CoreNLP.,raw_tag_sents
The text might contain several sentences which will be split by CoreNLP.,tag
The text might contain several sentences which will be split by CoreNLP.,tag_sents
The text might contain several sentences which will be split by CoreNLP.,tokenize
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",setup_module
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",teardown_module
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",transform
"stderr (stdout,) – Specifies where CoreNLP output is redirected. Valid values are ‘devnull’, ‘stdout’, ‘pipe’",try_port
"Starting with the root node, build a dependency tree using the NLTK
Tree constructor. Dependency labels are omitted.",nltk.parse.dependencygraph.
"Starting with the root node, build a dependency tree using the NLTK
Tree constructor. Dependency labels are omitted.",DependencyGraph
"Adds an arc from the node specified by head_address to the
node specified by the mod address.",add_arc
"Adds an arc from the node specified by head_address to the
node specified by the mod address.",add_node
"Fully connects all non-root nodes.  All nodes are set to be dependents
of the root node.",connect_graph
"Returns true if the graph contains a node with the given node
address, false otherwise.",contains_address
"Returns true if the graph contains a node with the given node
address, false otherwise.",contains_cycle
Return the node with the given address.,get_by_address
Return the node with the given address.,get_cycle_path
"Returns the number of right children under the node specified
by the given address.",left_children
"rather than 1 (as produced by, e.g., zpar)
:param str cell_separator: the cell separator. If not provided, cells
are split by whitespace.
:param str top_relation_label: the label by which the top relation is
identified, for examlple, ROOT, null or TOP.",load
Convert the data in a nodelist into a networkx labeled directed graph.,nx_graph
Convert the data in a nodelist into a networkx labeled directed graph.,redirect_arcs
"Removes the node with the given address.  References
to this node in others will still exist.",remove_by_address
"Returns the number of right children under the node specified
by the given address.",right_children
"style (int) – the style to use for the format (3, 4, 10 columns)",to_conll
Return a dot representation suitable for using with Graphviz.,to_dot
"Starting with the root node, build a dependency tree using the NLTK
Tree constructor. Dependency labels are omitted.",tree
"Starting with the root node, build a dependency tree using the NLTK
Tree constructor. Dependency labels are omitted.",triples
"Starting with the root node, build a dependency tree using the NLTK
Tree constructor. Dependency labels are omitted.",DependencyGraphError
"A demonstration of how to read a string representation of
a CoNLL format dependency tree.",conll_demo
"A demonstration of how to read a string representation of
a CoNLL format dependency tree.",conll_file_demo
"A demonstration of how to read a string representation of
a CoNLL format dependency tree.",cycle_finding_demo
"A demonstration of the result of reading a dependency
version of the first sentence of the Penn Treebank.",malt_demo
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",nltk.parse.earleychart.
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",CompleteFundamentalRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",CompleterRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",EarleyChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FeatureCompleteFundamentalRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FeatureCompleterRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FeatureEarleyChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FeatureIncrementalBottomUpChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FeatureIncrementalBottomUpLeftCornerChartParser
"Returns an iterator over the edges in this chart.
See Chart.select for more information about the
restrictions on the edges.",FeatureIncrementalChart
"Returns an iterator over the edges in this chart.
See Chart.select for more information about the
restrictions on the edges.",FeatureIncrementalChartParser
"Returns an iterator over the edges in this chart.
See Chart.select for more information about the
restrictions on the edges.",FeatureIncrementalTopDownChartParser
"Returns an iterator over the edges in this chart.
See Chart.select for more information about the
restrictions on the edges.",FeaturePredictorRule
"Returns an iterator over the edges in this chart.
See Chart.select for more information about the
restrictions on the edges.",FeatureScannerRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FilteredCompleteFundamentalRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",IncrementalBottomUpChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",IncrementalBottomUpLeftCornerChartParser
"Return an iterator over the edges in this chart.  Any
new edges that are added to the chart before the iterator
is exahusted will also be generated.  restrictions
can be used to restrict the set of edges that will be
generated.",IncrementalChart
"Return the final parse Chart from which all possible
parse trees can be extracted.",IncrementalChartParser
"Return the final parse Chart from which all possible
parse trees can be extracted.",IncrementalLeftCornerChartParser
"Return the final parse Chart from which all possible
parse trees can be extracted.",IncrementalTopDownChartParser
"Return the final parse Chart from which all possible
parse trees can be extracted.",PredictorRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",ScannerRule
"Class for measuring labelled and unlabelled attachment score for
dependency parsing. Note that the evaluation ignores punctuation.",nltk.parse.evaluate.
"Class for measuring labelled and unlabelled attachment score for
dependency parsing. Note that the evaluation ignores punctuation.",DependencyEvaluator
"Class for measuring labelled and unlabelled attachment score for
dependency parsing. Note that the evaluation ignores punctuation.",eval
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",nltk.parse.featurechart.
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureBottomUpChartParser
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureBottomUpLeftCornerChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FeatureBottomUpPredictCombineRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FeatureBottomUpPredictRule
"Returns an iterator over the edges in this chart.
See Chart.select for more information about the
restrictions on the edges.",FeatureChart
"Returns an iterator over the edges in this chart.
See Chart.select for more information about the
restrictions on the edges.",FeatureChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FeatureEmptyPredictRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FeatureFundamentalRule
"A specialized version of the completer / single edge fundamental rule
that operates on nonterminals whose symbols are ``FeatStructNonterminal``s.
Rather than simply comparing the nonterminals for equality, they are
unified.",FeatureSingleEdgeFundamentalRule
"A specialized version of the completer / single edge fundamental rule
that operates on nonterminals whose symbols are ``FeatStructNonterminal``s.
Rather than simply comparing the nonterminals for equality, they are
unified.",FeatureTopDownChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FeatureTopDownInitRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",FeatureTopDownPredictRule
"A new FeatureTreeEdge formed from this edge.
The new edge’s dot position is increased by 1,
and its end index will be replaced by new_end.",FeatureTreeEdge
"Each FeatureTreeEdge contains a set of bindings, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface SubstituteBindingsI.",bindings
"A new FeatureTreeEdge formed from this edge.
The new edge’s dot position is increased by 1,
and its end index will be replaced by new_end.",next_with_bindings
The set of variables used by this edge.,variables
"If the edge is a FeatureTreeEdge, and it is complete,
then instantiate all variables whose names start with ‘@’,
by replacing them with unique new variables.",InstantiateVarsChart
"child_pointer_lists (sequence of tuple(EdgeI)) – A sequence of lists of the edges that
were used to form this edge.  This list is used to reconstruct
the trees (or partial trees) that are associated with edge.",inst_vars
"If the edge is a FeatureTreeEdge, and it is complete,
then instantiate all variables whose names start with ‘@’,
by replacing them with unique new variables.",instantiate_edge
"If the edge is a FeatureTreeEdge, and it is complete,
then instantiate all variables whose names start with ‘@’,
by replacing them with unique new variables.",run_profile
start – The Nonterminal from which to start generate sentences.,nltk.parse.generate.
start – The Nonterminal from which to start generate sentences.,generate
A module to find MaltParser .jar file and its dependencies.,nltk.parse.malt.
A module to find MaltParser .jar file and its dependencies.,MaltParser
This function generates the maltparser command use at the terminal.,generate_malt_command
"Use MaltParser to parse multiple POS tagged sentences. Takes multiple
sentences where each sentence is a list of (word, tag) tuples.
The sentences must have already been tokenized and tagged.",parse_tagged_sents
"Use MaltParser to parse multiple POS tagged sentences. Takes multiple
sentences where each sentence is a list of (word, tag) tuples.
The sentences must have already been tokenized and tagged.",train
"Use MaltParser to parse multiple POS tagged sentences. Takes multiple
sentences where each sentence is a list of (word, tag) tuples.
The sentences must have already been tokenized and tagged.",train_from_file
A module to find MaltParser .jar file and its dependencies.,find_malt_model
A module to find MaltParser .jar file and its dependencies.,find_maltparser
A module to find MaltParser .jar file and its dependencies.,malt_regex_tagger
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",nltk.parse.nonprojectivedependencyparser.
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",DemoScorer
"When used in conjunction with a MaxEntClassifier, each score would
correspond to the confidence of a particular edge being classified
with the positive training examples.",score
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",DependencyScorerI
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",NaiveBayesDependencyScorer
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",NonprojectiveDependencyParser
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",ProbabilisticNonprojectiveParser
"Returns the source of the best incoming arc to the
node with address: node_index",best_incoming_arc
"Takes a list of nodes that have been identified to belong to a cycle,
and collapses them into on larger node.  The arcs of all nodes in
the graph must be updated to account for this.",collapse_nodes
"When updating scores the score of the highest-weighted incoming
arc is subtracted upon collapse.  This returns the correct
amount to subtract from that edge.",compute_max_subtract_score
"As nodes are collapsed into others, they are replaced
by the new node in the graph, but it’s still necessary
to keep track of what these original nodes were.  This
takes a list of node addresses and replaces any collapsed
node addresses with their original addresses.",compute_original_indexes
graph (DependencyGraph) – A dependency graph to assign scores to.,initialize_edge_scores
graph (DependencyGraph) – A dependency graph to assign scores to.,original_best_arc
"dependency_scorer (DependencyScorerI) – A scorer which implements the
DependencyScorerI interface.",update_edge_scores
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",hall_demo
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",nonprojective_conll_parse_demo
"Parses a list of tokens in accordance to the MST parsing algorithm
for non-projective dependency parses.  Assumes that the tokens to
be parsed have already been tagged and those tags are provided.  Various
scoring methods can be used by implementing the DependencyScorerI
interface and passing it to the training algorithm.",rule_based_demo
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",nltk.parse.pchart.
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",BottomUpProbabilisticChartParser
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",sort_queue
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",trace
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",InsideChartParser
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",LongestChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",ProbabilisticBottomUpInitRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",ProbabilisticBottomUpPredictRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",ProbabilisticFundamentalRule
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",ProbabilisticLeafEdge
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",ProbabilisticTreeEdge
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",RandomChartParser
"edges (list(EdgeI)) – A set of existing edges.  The number of edges
that should be passed to apply() is specified by the
NUM_EDGES class variable.",SingleEdgeProbabilisticFundamentalRule
"chart (Chart) – The chart being used to parse the text.  This
chart can be used to provide extra information for sorting
the queue.",UnsortedChartParser
"A demonstration showing the creation and use of a
DependencyGrammar to perform a projective dependency
parse.",nltk.parse.projectivedependencyparser.
"A demonstration showing the creation and use of a
DependencyGrammar to perform a projective dependency
parse.",ChartCell
"Appends the given span to the list of spans
representing the chart cell’s entries.",add
"A demonstration showing the creation and use of a
DependencyGrammar to perform a projective dependency
parse.",DependencySpan
"A demonstration showing the creation and use of a
DependencyGrammar to perform a projective dependency
parse.",ProbabilisticProjectiveDependencyParser
"Computes the probability of a dependency graph based
on the parser’s probability model (defined by the parser’s
statistical dependency grammar).",compute_prob
"Concatenates the two spans in whichever way possible.  This
includes rightward concatenation (from the leftmost word of the
leftmost span to the rightmost word of the rightmost span) and
leftward concatenation (vice-versa) between adjacent spans.  Unlike
Eisner’s presentation of span concatenation, these spans do not
share or pivot on a particular word/word-index.",concatenate
"A demonstration showing the creation and use of a
DependencyGrammar to perform a projective dependency
parse.",ProjectiveDependencyParser
"A demonstration showing the creation and use of a
DependencyGrammar to perform a projective dependency
parse.",arity_parse_demo
"A demonstration showing the creation and use of a
DependencyGrammar to perform a projective dependency
parse.",projective_prob_parse_demo
"A demonstration showing the creation and use of a
DependencyGrammar to perform a projective dependency
parse.",projective_rule_parse_demo
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",nltk.parse.recursivedescent.
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",RecursiveDescentParser
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",SteppingRecursiveDescentParser
"Return the parser to its state before the most recent
match or expand operation.  Calling undo repeatedly return
the parser to successively earlier states.  If no match or
expand operations have been performed, undo will make no
changes.",backtrack
"Return the parser to its state before the most recent
match or expand operation.  Calling undo repeatedly return
the parser to successively earlier states.  If no match or
expand operations have been performed, undo will make no
changes.",currently_complete
"The production used to expand the frontier, if an
expansion was performed.  If no expansion was performed,
return None.",expand
"The production used to expand the frontier, if an
expansion was performed.  If no expansion was performed,
return None.",expandable_productions
"The production used to expand the frontier, if an
expansion was performed.  If no expansion was performed,
return None.",frontier
"The token matched, if a match operation was
performed.  If no match was performed, return None",match
"An iterator of the parses that have been found by this
parser so far.",remaining_text
"A partial structure for the text that is
currently being parsed.  The elements specified by the
frontier have not yet been expanded or matched.",untried_expandable_productions
"A partial structure for the text that is
currently being parsed.  The elements specified by the
frontier have not yet been expanded or matched.",untried_match
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",nltk.parse.shiftreduce.
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",ShiftReduceParser
"trace (int) – The trace level.  A trace level of 0 will
generate no tracing output; and higher trace levels will
produce more verbose tracing output.",SteppingShiftReduceParser
"The production used to reduce the stack, if a
reduction was performed.  If no reduction was performed,
return None.",reduce
"The production used to reduce the stack, if a
reduction was performed.  If no reduction was performed,
return None.",reducible_productions
"Move a token from the beginning of the remaining text to the
end of the stack.  If there are no more tokens in the
remaining text, then do nothing.",shift
"Move a token from the beginning of the remaining text to the
end of the stack.  If there are no more tokens in the
remaining text, then do nothing.",stack
"Return the parser to its state before the most recent
shift or reduce operation.  Calling undo repeatedly return
the parser to successively earlier states.  If no shift or
reduce operations have been performed, undo will make no
changes.",undo
"Currently unimplemented because the neural dependency parser (and
the StanfordCoreNLP pipeline class) doesn’t support passing in pre-
tagged tokens.",nltk.parse.stanford.
"Currently unimplemented because the neural dependency parser (and
the StanfordCoreNLP pipeline class) doesn’t support passing in pre-
tagged tokens.",GenericStanfordParser
"Use StanfordParser to parse multiple sentences. Takes multiple sentences
where each sentence is a list of (word, tag) tuples.
The sentences must have already been tokenized and tagged.",tagged_parse_sents
"Currently unimplemented because the neural dependency parser (and
the StanfordCoreNLP pipeline class) doesn’t support passing in pre-
tagged tokens.",StanfordDependencyParser
"Currently unimplemented because the neural dependency parser (and
the StanfordCoreNLP pipeline class) doesn’t support passing in pre-
tagged tokens.",StanfordNeuralDependencyParser
"Currently unimplemented because the neural dependency parser (and
the StanfordCoreNLP pipeline class) doesn’t support passing in pre-
tagged tokens.",StanfordParser
"A. Check the ARC-STANDARD training
>>> import tempfile
>>> import os
>>> input_file = tempfile.NamedTemporaryFile(prefix=’transition_parse.train’, dir=tempfile.gettempdir(), delete=False)",nltk.parse.transitionparser.
"A. Check the ARC-STANDARD training
>>> import tempfile
>>> import os
>>> input_file = tempfile.NamedTemporaryFile(prefix=’transition_parse.train’, dir=tempfile.gettempdir(), delete=False)",Configuration
"Extract the set of features for the current configuration. Implement standard features as describe in
Table 3.2 (page 31) in Dependency Parsing book by Sandra Kubler, Ryan McDonal, Joakim Nivre.
Please note that these features are very basic.
:return: list(str)",extract_features
"A. Check the ARC-STANDARD training
>>> import tempfile
>>> import os
>>> input_file = tempfile.NamedTemporaryFile(prefix=’transition_parse.train’, dir=tempfile.gettempdir(), delete=False)",Transition
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",LEFT_ARC
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",REDUCE
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",RIGHT_ARC
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",SHIFT
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",left_arc
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",right_arc
"A. Check the ARC-STANDARD training
>>> import tempfile
>>> import os
>>> input_file = tempfile.NamedTemporaryFile(prefix=’transition_parse.train’, dir=tempfile.gettempdir(), delete=False)",TransitionParser
Class for transition based parser. Implement 2 algorithms which are “arc-standard” and “arc-eager”,ARC_EAGER
Class for transition based parser. Implement 2 algorithms which are “arc-standard” and “arc-eager”,ARC_STANDARD
Unit tests for  CFG.,nltk.parse.util.
Unit tests for  CFG.,TestGrammar
Unit tests for  CFG.,run
"The result information is followed by a colon, and then the sentence.
Empty lines and lines beginning with a comment char are ignored.",extract_test_sentences
"load_args – Keyword parameters used when loading the grammar.
See data.load for more information.",load_parser
A module to convert a single POS tagged sentence into CONLL format.,taggedsent_to_conll
"A module to convert the a POS tagged document stream
(i.e. list of list of tuples, a list of sentences) and yield lines
in CONLL format. This module yields one line per word and two newlines
for end of sentence.",taggedsents_to_conll
"A demonstration of the probabilistic parsers.  The user is
prompted to select which demo to run, and how many parses should
be found; and then each parser is run on the same demo, and a
summary of the results are displayed.",nltk.parse.viterbi.
"A demonstration of the probabilistic parsers.  The user is
prompted to select which demo to run, and how many parses should
be found; and then each parser is run on the same demo, and a
summary of the results are displayed.",ViterbiParser
