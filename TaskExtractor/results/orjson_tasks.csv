"orjson supports CPython 3.7, 3.8, 3.9, and 3.10. It distributes x86_64/amd64 and aarch64/armv8 wheels for Linux and macOS. It distributes x86_64/amd64 wheels for Windows. orjson does not support PyPy. Releases follow semantic versioning and serializing a new object type without an opt-in flag is considered a breaking change.","support cpython,"
"orjson is licensed under both the Apache 2.0 and MIT licenses. The repository and issue tracker is github.com/ijl/orjson, and patches may be submitted there. There is a CHANGELOG available in the repository.","submit patches,"
To install a wheel from PyPI:,"install wheel from pypi,"
"orjson version 3 serializes more types than version 2. Subclasses of str, int, dict, and list are now serialized. This is faster and more similar to the standard library. It can be disabled with orjson.OPT_PASSTHROUGH_SUBCLASS.dataclasses.dataclass instances are now serialized by default and cannot be customized in a default function unless option=orjson.OPT_PASSTHROUGH_DATACLASS is specified. uuid.UUID instances are serialized by default. For any type that is now serialized, implementations in a default function and options enabling them can be removed but do not need to be. There was no change in deserialization.","specify option = orjson.OPT_PASSTHROUGH_DATACLASS,remove implementations in default function,remove implementations in options,remove implementations for type,"
"To migrate from the standard library, the largest difference is that orjson.dumps returns bytes and json.dumps returns a str. Users with dict objects using non-str keys should specify option=orjson.OPT_NON_STR_KEYS. sort_keys is replaced by option=orjson.OPT_SORT_KEYS. indent is replaced by option=orjson.OPT_INDENT_2 and other levels of indentation are not supported.","replace dict objects,replace users with dict objects,"
"It natively serializes str, dict, list, tuple, int, float, bool, dataclasses.dataclass, typing.TypedDict, datetime.datetime, datetime.date, datetime.time, uuid.UUID, numpy.ndarray, and None instances. It supports arbitrary types through default. It serializes subclasses of str, int, dict, list, dataclasses.dataclass, and enum.Enum. It does not serialize subclasses of tuple to avoid serializing namedtuple objects as arrays. To avoid serializing subclasses, specify the option orjson.OPT_PASSTHROUGH_SUBCLASS.","support arbitrary types through default,specify option orjson.OPT_PASSTHROUGH_SUBCLASS.,"
"It raises JSONEncodeError on an unsupported type. This exception message describes the invalid object with the error message Type is not JSON serializable: .... To fix this, specify default.","raise JSONEncodeError on unsupported type,specify default,"
It raises JSONEncodeError on a str that contains invalid UTF-8.,"raise JSONEncodeError on str UTF-8,"
"It raises JSONEncodeError on an integer that exceeds 64 bits by default or, with OPT_STRICT_INTEGER, 53 bits.","raise JSONEncodeError on integer,"
"It raises JSONEncodeError if a dict has a key of a type other than str, unless OPT_NON_STR_KEYS is specified.","raise JSONEncodeError,specify OPT_NON_STR_KEYS,"
It raises JSONEncodeError if the output of default recurses to handling by default more than 254 levels deep.,"raise JSONEncodeError,handle  by default,"
It raises JSONEncodeError on circular references.,"raise JSONEncodeError on circular references,"
It raises JSONEncodeError if a tzinfo on a datetime object is unsupported.,"raise JSONEncodeError,"
"To serialize a subclass or arbitrary types, specify default as a callable that returns a supported type. default may be a function, lambda, or callable class instance. To specify that a type was not handled by default, raise an exception such as TypeError.","return supported type,return callable,raise exception such_as TypeError,"
The default callable may return an object that itself must be handled by default up to 254 times before an exception is raised.,"return object,raise exception,"
"It is important that default raise an exception if a type cannot be handled. Python otherwise implicitly returns None, which appears to the caller like a legitimate value and is serialized:","raise exception,return none,"
"To modify how data is serialized, specify option. Each option is an integer constant in orjson. To specify multiple options, mask them together, e.g., option=orjson.OPT_STRICT_INTEGER | orjson.OPT_NAIVE_UTC.","specify option,specify multiple options,"
Pretty-print output with an indent of two spaces. This is equivalent to indent=2 in the standard library. Pretty printing is slower and the output larger. orjson is the fastest compared library at pretty printing and has much less of a slowdown to pretty print than the standard library does. This option is compatible with all other options.,"indent  in standard library,"
rapidjson is blank because it does not support pretty printing. This can be reproduced using the pyindent script.,"use pyindent script,"
"This option has the risk of creating duplicate keys. This is because non-str objects may serialize to the same str as an existing key, e.g., {""1"": true, 1: false}. The last key to be inserted to the dict will be serialized last and a JSON deserializer will presumably take the last occurrence of a key (in the above, false). The first value will be lost.","create duplicate keys,insert  to dict,"
"This measures serializing 589KiB of JSON comprising a list of 100 dict in which each dict has both 365 randomly-sorted int keys representing epoch timestamps as well as one str key and the value for each key is a single integer. In ""str keys"", the keys were converted to str before serialization, and orjson still specifes option=orjson.OPT_NON_STR_KEYS (which is always somewhat slower).","convert keys in str keys,"
ujson is blank for sorting because it segfaults. json is blank because it raises TypeError on attempting to sort before converting all keys to str. rapidjson is blank because it does not support non-str keys. This can be reproduced using the pynonstr script.,"raise TypeError on attempting,convert keys to str,sort  before converting,use pynonstr script,"
Passthrough dataclasses.dataclass instances to default. This allows customizing their output but is much slower.,"customize output,"
This does not affect datetimes in dict keys if using OPT_NON_STR_KEYS.,"use OPT_NON_STR_KEYS,"
This does not affect serializing subclasses as dict keys if using OPT_NON_STR_KEYS.,"use OPT_NON_STR_KEYS,"
The benchmark can be reproduced using the pysort script.,"use pysort script,"
"bytes, bytearray, memoryview, and str input are accepted. If the input exists as a memoryview, bytearray, or bytes object, it is recommended to pass these directly rather than creating an unnecessary str object. This has lower memory usage and lower latency.","pass  than creating,create unnecessary str object,"
orjson maintains a cache of map keys for the duration of the process. This causes a net reduction in memory usage by avoiding duplicate strings. The keys must be at most 64 bytes to be cached and 512 entries are stored.,"store entries,"
"It raises JSONDecodeError if given an invalid type or invalid JSON. This includes if the input contains NaN, Infinity, or -Infinity, which the standard library allows, but is not valid JSON.","raise JSONDecodeError,"
"It is supported to pass all variants of dataclasses, including dataclasses using __slots__, frozen dataclasses, those with optional or default attributes, and subclasses. There is a performance benefit to not using __slots__.","pass variants of dataclasses,use subclasses,use __slots__,support  including dataclasses,"
"This measures serializing 555KiB of JSON, orjson natively and other libraries using default to serialize the output of dataclasses.asdict(). This can be reproduced using the pydataclass script.","use default,use pydataclass script,"
"Users may wish to control how dataclass instances are serialized, e.g., to not serialize an attribute or to change the name of an attribute when serialized. orjson may implement support using the metadata mapping on field attributes, e.g., field(metadata={""json_serialize"": False}), if use cases are clear.","change name of attribute,implement support,use metadata mapping on field attributes,"
"datetime.datetime supports instances with a tzinfo that is None, datetime.timezone.utc, a timezone instance from the python3.9+ zoneinfo module, or a timezone instance from the third-party pendulum, pytz, or dateutil/arrow libraries.","support instances with tzinfo,"
"It is faster to have orjson serialize datetime objects than to do so before calling dumps(). If using an unsupported type such as pendulum.datetime, use default.","call dumps(),use unsupported type such_as pendulum.datetime,use default,"
To disable serialization of datetime objects specify the option orjson.OPT_PASSTHROUGH_DATETIME.,"specify option orjson.OPT_PASSTHROUGH_DATETIME.,"
"To use ""Z"" suffix instead of ""+00:00"" to indicate UTC (""Zulu"") time, use the option orjson.OPT_UTC_Z.","use z suffix,use option orjson.OPT_UTC_Z.,"
orjson serializes enums natively. Options apply to their values.,"apply  to values,"
Enums with members that are not supported types can be serialized using default:,"use default,"
"orjson serializes and deserializes double precision floats with no loss of precision and consistent rounding. The same behavior is observed in rapidjson, simplejson, and json. ujson 1.35 was inaccurate in both serialization and deserialization, i.e., it modifies the data, and the recent 2.0 release is accurate.","modify data,"
"orjson serializes and deserializes 64-bit integers by default. The range supported is a signed 64-bit integer's minimum (-9223372036854775807) to an unsigned 64-bit integer's maximum (18446744073709551615). This is widely compatible, but there are implementations that only support 53-bits for integers, e.g., web browsers. For those implementations, dumps() can be configured to raise a JSONEncodeError on values exceeding the 53-bit range.","support 53-bits web browsers,support implementations,raise JSONEncodeError on values,configure dumps() for implementations,"
orjson is faster than all compared libraries at serializing numpy instances. Serializing numpy data requires specifying option=orjson.OPT_SERIALIZE_NUMPY.,"compare libraries at serializing,compare orjson at serializing,"
"If an array is not a contiguous C array, contains an supported datatype, or contains a numpy.datetime64 using an unsupported representation (e.g., picoseconds), orjson falls through to default. In default, obj.tolist() can be specified. If an array is malformed, which is not expected, orjson.JSONEncodeError is raised.","use unsupported representation,specify obj.tolist() in default,raise orjson.JSONEncodeError,"
"In these benchmarks, orjson serializes natively, ujson is blank because it does not support a default parameter, and the other libraries serialize ndarray.tolist() via default. The RSS column measures peak memory usage during serialization. This can be reproduced using the pynumpy script.","use pynumpy script,"
"orjson does not have an installation or compilation dependency on numpy. The implementation is independent, reading numpy.ndarray using PyArrayInterface.","use PyArrayInterface,"
"If orjson.dumps() is given a str that does not contain valid UTF-8, orjson.JSONEncodeError is raised. If loads() receives invalid UTF-8, orjson.JSONDecodeError is raised.","raise orjson.JSONEncodeError,raise orjson.JSONDecodeError,"
"To make a best effort at deserializing bad input, first decode bytes using the replace or lossy argument for errors:","use replace lossy argument for errors,"
The library has comprehensive tests. There are tests against fixtures in the JSONTestSuite and nativejson-benchmark repositories. It is tested to not crash against the Big List of Naughty Strings. It is tested to not leak memory. It is tested to not crash against and not accept invalid UTF-8. There are integration tests exercising the library's use in web servers (gunicorn using multiprocess/forked workers) and when multithreaded. It also uses some tests from the ultrajson library.,"test  to crash,use tests from ultrajson library,"
orjson is the most correct of the compared libraries. This graph shows how each library handles a combined 342 JSON fixtures from the JSONTestSuite and nativejson-benchmark tests:,"compare libraries,handle combined 342 JSON fixtures from nativejson-benchmark tests,handle combined 342 JSON fixtures from JSONTestSuite,"
The graph above can be reproduced using the pycorrectness script.,"use pycorrectness script,"
"This measures, in the first column, RSS after importing a library and reading the fixture, and in the second column, increases in RSS after repeatedly calling loads() on the fixture.","import library,read fixture,call loads() on fixture,"
"The above was measured using Python 3.8.3 on Linux (x86_64) with orjson 3.3.0, ujson 3.0.0, python-rapidson 0.9.1, and simplejson 3.17.2.","use Python 3.8.3 with python-rapidson 0.9.1,use Python 3.8.3 with simplejson 3.17.2,use Python 3.8.3 with orjson 3.3.0,use Python 3.8.3 with ujson 3.0.0,use Python 3.8.3 on Linux,"
The latency results can be reproduced using the pybench and graph scripts. The memory results can be reproduced using the pymem script.,"use pybench graph scripts,use pymem script,"
Probably pip needs to be upgraded to version 20.3 or later to support the latest manylinux_x_y or universal2 wheel formats.,"support latest manylinux_x_y,support universal2 wheel formats,"
The project's own CI tests against nightly-2021-08-17 and stable 1.54. It is prudent to pin the nightly version because that channel can introduce breaking changes.,"test  against nightly-2021-08-17 stable 1.54,introduce breaking changes,"
orjson is tested for amd64 and aarch64 on Linux and amd64 on macOS and Windows. It may not work on 32-bit targets.,"test orjson on Linux,test orjson on amd64,test orjson on macOS,test orjson on windows,"
orjson's tests are included in the source distribution on PyPI. The requirements to run the tests are specified in test/requirements.txt. The tests should be run as part of the build. It can be run with pytest -q test.,"include tests in source distribution,run tests,specify requirements in test/requirements.txt.,run tests,run test/requirements.txt.,run  with pytest,"
"orjson was written by ijl <ijl@mailbox.org>, copyright 2018 - 2021, licensed under both the Apache 2 and MIT licenses.","write orjson,"
