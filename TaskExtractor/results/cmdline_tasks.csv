"Note: Stanford CoreNLP v.3.5+ requires Java 8, but works with Java 9/10/11 as well. If using Java 9/10/11, you need to add this Java flag to avoid errors (a CoreNLP library dependency uses the JAXB module that was deleted from the default libraries for Java 9+):","use Java 9
add Java flag"
The minimal command to run Stanford CoreNLP from the command line is:,run Stanford CoreNLP from command line
"If this command is run from the distribution directory, it processes the included sample file input.txt. We use a wildcard ""*"" after -cp to load all jar files in the current directory – it needs to be in quotes. This command writes the output to an XML file named input.txt.xml in the same directory.","process included sample file input.txt
run command from distribution directory
use wildcard \""*\"" after -cp
load jar files in current directory
write output to XML file"
"Your command line has to load the code, libraries, and model jars that CoreNLP uses. These are all contained in JAR files (compressed archives with extension “.jar”) which come in the CoreNLP download or which can be downloaded on demand from Maven Central. The easiest way to make them available is with a command line like this, where /Users/me/corenlp/ should be changed to the path where you put CoreNLP:","load code
load libraries
load model jars
download  from Maven central
download  on demand
change /Users/me/corenlp/ to path"
"Alternatively, you can [add this path to your CLASSPATH environment variable](https://en.wikipedia.org/wiki/Classpath_(Java%29), so these libraries are always available.",add path to CLASSPATH environment variable ]
"The “*” (which must be enclosed in quotes) says to add all JAR files in the given directory to the classpath. You can also individually specify the needed jar files. Use the following sort of command line, adjusting the JAR file date extensions VV to your downloaded release.","add JAR files in given directory
specify needed jar files
use following sort of command line
adjust JAR file date extensions VV to downloaded release"
"The command above works for Mac OS X or Linux. For Windows, the colons (:) separating the jar files need to be semi-colons (;). If you are not sitting in the distribution directory, you’ll also need to include a path to the files before each.","separate jar files
include path to files"
"Before using Stanford CoreNLP, it is usual to create a configuration file (a Java Properties file). Minimally, this file should contain the “annotators” property, which contains a comma-separated list of Annotators to use. For example, the setting below enables: tokenization, sentence splitting (required by most Annotators), POS tagging, lemmatization, NER, (constituency) parsing, and (rule-based) coreference resolution.","use Stanford CoreNLP
create configuration file
enable lemmatization
enable NER
enable parsing
enable tokenization
enable coreference resolution
enable sentence splitting
enable POS tagging"
"To use the properties in the properties file sampleProps.properties, you give a command as follows:",use properties in properties file sampleProps.properties
"However, if you just want to specify a few properties, you can instead place them on the command line. For example, we can specify annotators and the output format with:","specify few properties
place  on command line
specify annotators
specify output format"
"The -props parameter is optional. By default, Stanford CoreNLP will search for StanfordCoreNLP.properties in your classpath and use the defaults included in the distribution.","use defaults
search  by default
search  for StanfordCoreNLP.properties
include  in distribution"
"The -annotators argument is also optional. If you leave it out, the code uses a built in properties file, which enables the following annotators: tokenization and sentence splitting, POS tagging, lemmatization, NER, dependency parsing, and statistical coreference resolution: annotators = tokenize, ssplit, pos, lemma, ner, depparse, coref.","use built annotators = tokenize, ssplit, pos, lemma, ner, depparse, coref
enable following annotators
enable properties file"
"If you have a lot of text but all you want to do is to, say, get part-of-speech (POS) tags, then you should definitely specify an annotators list, as above, since you can then omit later annotators which invoke much more expensive processing that you don’t need. For example, you might give the command:","get part-of-speech tags
specify annotators list
omit later annotators"
"We provide a small shell script corenlp.sh. On Linux or OS X, this may be useful in allowing you to type shorter command lines to invoke CoreNLP. For example, you can instead say:",provide small shell script corenlp.sh
"You first have to have available a models jar file for the language you wish to use. You can download it from this site or you can use the models file on Maven Central. If using Maven, you add it to your pom file like this:","download  from site
use models file on Maven central
use maven
add  to pom file"
"Our examples assume that you are in the root directory of CoreNLP and that these extra jar files are also available there. Each language jar contains a default properties file for the appropriate language. Working with text in another language is then as easy as specifying this properties file. For example, for Chinese:",specify properties file
You can as usual specify details on the annotators and properties:,"specify details on annotators
specify details on properties"
"To process one file, use the -file option followed by a filename. To process a list of files, use the -fileList parameter:","process file
use -file option
process list of files
use -fileList parameter
use files"
where the -fileList parameter points to a file which lists all files to be processed (one per line).,list file
"If you do not specify any properties that load input files (and do not specify any input or output redirections), then you will be placed in the interactive shell. Type q to exit.",place  in interactive shell
"If you do not specify an option that loads input files and you redirect either input or output, then Stanford CoreNLP runs as a filter that reads from stdin and writes to stdout. The default mode is line-oriented: Each line of input counts as a document. If you give the flag/property -isOneDocument (isOneDocument = true) then the input till end-of-file will be treated as one document.","redirect input
redirect output
run  as filter
read filter from stdin
write filter
count  as document"
"If your input files have XML tags in them, you may wish to add the cleanxml annotator to preprocess it. Place it immediately after tokenize.","add cleanxml annotator
place  after tokenize"
"If your input is already tokenzed and one sentence per line, then you should use the flags: -tokenize.whitespace -ssplit.eolonly.",use flags
"Fine point: Stanford CoreNLP treats Unicode end of line markers (LS U+2028 and PS U+2029) as line ends, whereas conventional Unix utilities do not. If these characters are present and you are using CoreNLP in a Unix line-oriented processing pipeline, you may need to remap these characters to ‘\n’ or ‘ ‘ at the start of your processing pipeline.",use CoreNLP in Unix line-oriented processing pipeline
"You can find other input processing options in the documentation of the tokenize, cleanxml, and ssplit annotators.",find other input processing options in documentation
"If (and only if) the input filename ends with “.ser.gz” then CoreNLP will interpret the file as the output of a previous annotation run, to which you presumably want to add on further annotations. CoreNLP will read these Annotations using the class specified in the inputSerializer property. The options for this are the same as for outputSerializer below. Note: To successfully load a pipeline for layering on additional annotations, you need to include the property enforceRequirements = false to avoid complaints about required earlier annotators not being present in the pipeline.","add  on further annotations
read Annotations
use class
specify  in inputSerializer property
load pipeline for layering
include property enforceRequirements = false"
"For each input file, Stanford CoreNLP generates one output file, with a name that adds an extra extension to the input filename. (If reading input from stdin, then it will send output to stdout.) The output may contain the output of all annotations that were done, or just a subset of them. For the first example under Quick Start above, with input.txt containing the text below:","generate output file with name
generate output file for input file
add extra extension to input filename
add name to input filename"
Stanford University is located in California. It is a great university.,locate stanford University in california
Stanford CoreNLP generates this output.,generate output
"Note that this XML output can use the CoreNLP-to-HTML.xsl stylesheet file, which comes with the CoreNLP download or can be downloaded from here. This stylesheet enables human-readable display of the above XML content. For example, this example should display like this.","use CoreNLP-to-HTML.xsl stylesheet file
download CoreNLP-to-HTML.xsl stylesheet file
enable human-readable display of above XML content"
"The value of the outputSerializer property is the name of a class which extends edu.stanford.nlp.pipeline.AnnotationSerializer. Valid choices include: edu.stanford.nlp.pipeline.GenericAnnotationSerializer, edu.stanford.nlp.pipeline.CustomAnnotationSerializer, edu.stanford.nlp.pipeline.ProtobufAnnotationSerializer; edu.stanford.nlp.kbp.common.KBPProtobufAnnotationSerializer, edu.stanford.nlp.kbp.slotfilling.ir.index.KryoAnnotationSerializer. If unspecified the value of the serializer property will be tried instead. If it is also not defined, the default is to use edu.stanford.nlp.pipeline.GenericAnnotationSerializer.","extend edu.stanford.nlp.pipeline.AnnotationSerializer
extend class
include valid choices
use edu.stanford.nlp.pipeline.GenericAnnotationSerializer"
"The ProtobufAnnotationSerializer is a non-lossy annotation serialization. It uses the Java methods writeDelimitedTo() and parseDelimitedFrom(), which allow sending several length-prefixed messages in one stream. Unfortunately, Google has declined to implement these methods for Python or C++. You can get information from Stack Overflow and other places on how to roll your own version for C++ or Python. Probably the best place is here but there are many other sources of information including: here, here, here, and here. This Stack Overflow question explicitly addresses the issue for CoreNLP.","use Java methods
send several length-prefixed messages in stream
implement methods for Python
implement methods for c + +
get information from Stack overflow
get information from other places"
"In all output formats (and in our code), we number sentences and character offsets from 0 and we number tokens from 1. We realize that this is inconsistent! However, it seemed to be the best thing to do. Numbering character offsets from 0 is the only good choice, given how the Java String class and most modern programming languages work, following Dijkstra’s arguments for indexing from 0 (which were influential at the time if not necessarily so water-tight). Numbering tokens from 1 not only corresponds to the human-natural convention (“the first word of the sentence”) but most importantly is consistent with common NLP standards, such as the CoNLL formats used from CoNLL-X through CoNLL 2009, etc., and in CoNLL-U, which number tokens starting from 1. For sentences, we could then choose to be consistent with either but not both of the above. We went with 0-indexing.","use  through CoNLL
use  from conll-x
choose  for sentences"
CoreNLP’s default character encoding is Unicode’s UTF-8. You can change the encoding used by supplying the program with the command line flag -encoding FOO (or including the corresponding property in a properties file that you are using). We’ve done a lot of careful work to make sure CoreNLP works with any character encoding supported by Java. Want to use ISO-8859-15 or GB18030? Be our guest!,change encoding
