Paragraph,Example
"A processing class for deriving trees that represent possible
structures for a sequence of tokens.  These tree structures are
known as “parses”.  Typically, parsers are used to derive syntax
trees for sentences.  But parsers can also be used to derive other
kinds of tree structure, such as morphological trees and discourse
structures.",grammar
"A processing class for deriving trees that represent possible
structures for a sequence of tokens.  These tree structures are
known as “parses”.  Typically, parsers are used to derive syntax
trees for sentences.  But parsers can also be used to derive other
kinds of tree structure, such as morphological trees and discourse
structures.",parse
"A processing class for deriving trees that represent possible
structures for a sequence of tokens.  These tree structures are
known as “parses”.  Typically, parsers are used to derive syntax
trees for sentences.  But parsers can also be used to derive other
kinds of tree structure, such as morphological trees and discourse
structures.",parse_all
"A processing class for deriving trees that represent possible
structures for a sequence of tokens.  These tree structures are
known as “parses”.  Typically, parsers are used to derive syntax
trees for sentences.  But parsers can also be used to derive other
kinds of tree structure, such as morphological trees and discourse
structures.",parse_one
"A processing class for deriving trees that represent possible
structures for a sequence of tokens.  These tree structures are
known as “parses”.  Typically, parsers are used to derive syntax
trees for sentences.  But parsers can also be used to derive other
kinds of tree structure, such as morphological trees and discourse
structures.",parse_sents
"Interface for parsing with BLLIP Parser. BllipParser objects can be
constructed with the BllipParser.from_unified_model_dir class
method or manually using the BllipParser constructor.",from_unified_model_dir
"Interface for parsing with BLLIP Parser. BllipParser objects can be
constructed with the BllipParser.from_unified_model_dir class
method or manually using the BllipParser constructor.",tagged_parse
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",nltk.parse.chart.
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",AbstractChartRule
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",BottomUpChartParser
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",BottomUpLeftCornerChartParser
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",BottomUpPredictCombineRule
"A rule licensing any edge corresponding to a production whose
right-hand side begins with a complete edge’s left-hand side.  In
particular, this rule specifies that [A -> alpha \*]
licenses the edge [B -> A \* beta] for each grammar
production B -> A beta.",NUM_EDGES
"A rule licensing any edge corresponding to a production whose
right-hand side begins with a complete edge’s left-hand side.  In
particular, this rule specifies that [A -> alpha \*]
licenses the edge [B -> A \* beta] for each grammar
production B -> A beta.",apply
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",BottomUpPredictRule
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",CachedTopDownPredictRule
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",Chart
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",child_pointer_lists
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",dot_digraph
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",edges
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",initialize
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",insert
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",insert_with_backpointer
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",iteredges
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",leaf
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",leaves
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",num_edges
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",num_leaves
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",parses
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",pretty_format
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",pretty_format_edge
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",pretty_format_leaves
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",select
"The select method can be used to select a specific collection
of edges.  For example chart.select(is_complete=True, start=0)
yields all complete edges whose start indices are 0.  To ensure
the efficiency of these selection operations, Chart dynamically
creates and maintains an index for each set of attributes that
have been selected on.",trees
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",ChartParser
"A generic chart parser.  A “strategy”, or list of
ChartRuleI instances, is used to decide what edges to add to
the chart.  In particular, ChartParser uses the following
algorithm to parse texts:",chart_parse
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",ChartRuleI
"A rule that specifies what new edges are licensed by any given set
of existing edges.  Each chart rule expects a fixed number of
edges, as indicated by the class variable NUM_EDGES.  In
particular:",apply_everywhere
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",EdgeI
"The EdgeI interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.",dot
"The EdgeI interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.",end
"The EdgeI interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.",is_complete
"The EdgeI interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.",is_incomplete
"The EdgeI interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.",length
"The EdgeI interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.",lhs
"The EdgeI interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.",nextsym
"The EdgeI interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.",rhs
"The EdgeI interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.",span
"The EdgeI interface provides a common interface to both types
of edge, allowing chart parsers to treat them in a uniform manner.",start
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",EmptyPredictRule
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",FilteredBottomUpPredictCombineRule
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",FilteredSingleEdgeFundamentalRule
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",FundamentalRule
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",LeafEdge
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",LeafInitRule
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",LeftCornerChartParser
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",SingleEdgeFundamentalRule
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",SteppingChartParser
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",chart
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",current_chartrule
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",set_chart
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",set_grammar
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",set_strategy
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",step
"The initialize method is used to start parsing a text.  step
adds a single edge to the chart.  set_strategy changes the
strategy used by the chart parser.  parses returns the set of
parses that has been found by the chart parser.",strategy
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",TopDownChartParser
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",TopDownInitRule
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",TopDownPredictRule
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",TreeEdge
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",demo
"Charts are encoded with the Chart class, and edges are encoded with
the TreeEdge and LeafEdge classes.  The chart parser module
defines three chart parsers:",demo_grammar
"Tools for reading and writing dependency trees.
The input is assumed to be in Malt-TAB format
(http://stp.lingfil.uu.se/~nivre/research/MaltXML.html).",nltk.parse.dependencygraph.
"Tools for reading and writing dependency trees.
The input is assumed to be in Malt-TAB format
(http://stp.lingfil.uu.se/~nivre/research/MaltXML.html).",DependencyGraph
"Tools for reading and writing dependency trees.
The input is assumed to be in Malt-TAB format
(http://stp.lingfil.uu.se/~nivre/research/MaltXML.html).",DependencyGraphError
"Tools for reading and writing dependency trees.
The input is assumed to be in Malt-TAB format
(http://stp.lingfil.uu.se/~nivre/research/MaltXML.html).",conll_demo
"Tools for reading and writing dependency trees.
The input is assumed to be in Malt-TAB format
(http://stp.lingfil.uu.se/~nivre/research/MaltXML.html).",conll_file_demo
"Tools for reading and writing dependency trees.
The input is assumed to be in Malt-TAB format
(http://stp.lingfil.uu.se/~nivre/research/MaltXML.html).",cycle_finding_demo
"Tools for reading and writing dependency trees.
The input is assumed to be in Malt-TAB format
(http://stp.lingfil.uu.se/~nivre/research/MaltXML.html).",malt_demo
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",nltk.parse.earleychart.
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",CompleteFundamentalRule
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",CompleterRule
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",EarleyChartParser
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",FeatureCompleteFundamentalRule
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",FeatureCompleterRule
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",FeatureEarleyChartParser
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",FeatureIncrementalBottomUpChartParser
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",FeatureIncrementalBottomUpLeftCornerChartParser
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",FeatureIncrementalChart
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",FeatureIncrementalChartParser
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",FeatureIncrementalTopDownChartParser
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",FeaturePredictorRule
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",FeatureScannerRule
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",FilteredCompleteFundamentalRule
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",IncrementalBottomUpChartParser
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",IncrementalBottomUpLeftCornerChartParser
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",IncrementalChart
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",IncrementalChartParser
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",IncrementalLeftCornerChartParser
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",IncrementalTopDownChartParser
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",PredictorRule
"Data classes and parser implementations for incremental chart
parsers, which use dynamic programming to efficiently parse a text.
A “chart parser” derives parse trees for a text by iteratively adding
“edges” to a “chart”.  Each “edge” represents a hypothesis about the tree
structure for a subsequence of the text.  The “chart” is a
“blackboard” for composing and combining these hypotheses.",ScannerRule
"Class for measuring labelled and unlabelled attachment score for
dependency parsing. Note that the evaluation ignores punctuation.",eval
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",nltk.parse.featurechart.
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureBottomUpChartParser
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureBottomUpLeftCornerChartParser
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureBottomUpPredictCombineRule
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureBottomUpPredictRule
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureChart
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureChartParser
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureEmptyPredictRule
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureFundamentalRule
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureSingleEdgeFundamentalRule
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureTopDownChartParser
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureTopDownInitRule
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureTopDownPredictRule
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",FeatureTreeEdge
"Each FeatureTreeEdge contains a set of bindings, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface SubstituteBindingsI.",bindings
"Each FeatureTreeEdge contains a set of bindings, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface SubstituteBindingsI.",from_production
"Each FeatureTreeEdge contains a set of bindings, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface SubstituteBindingsI.",move_dot_forward
"Each FeatureTreeEdge contains a set of bindings, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface SubstituteBindingsI.",next_with_bindings
"Each FeatureTreeEdge contains a set of bindings, i.e., a
dictionary mapping from variables to values.  If the edge is not
complete, then these bindings are simply stored.  However, if the
edge is complete, then the constructor applies these bindings to
every nonterminal in the edge whose symbol implements the
interface SubstituteBindingsI.",variables
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",InstantiateVarsChart
"A specialized chart that ‘instantiates’ variables whose names
start with ‘@’, by replacing them with unique new variables.
In particular, whenever a complete edge is added to the chart, any
variables in the edge’s lhs whose names start with ‘@’ will be
replaced by unique new ``Variable``s.",inst_vars
"A specialized chart that ‘instantiates’ variables whose names
start with ‘@’, by replacing them with unique new variables.
In particular, whenever a complete edge is added to the chart, any
variables in the edge’s lhs whose names start with ‘@’ will be
replaced by unique new ``Variable``s.",instantiate_edge
"Extension of chart parsing implementation to handle grammars with
feature structures as nodes.",run_profile
"A class for dependency parsing with MaltParser. The input is the paths to:
- a maltparser directory
- (optionally) the path to a pre-trained MaltParser .mco model file
- (optionally) the tagger to use for POS tagging before parsing
- (optionally) additional Java arguments",generate_malt_command
"A class for dependency parsing with MaltParser. The input is the paths to:
- a maltparser directory
- (optionally) the path to a pre-trained MaltParser .mco model file
- (optionally) the tagger to use for POS tagging before parsing
- (optionally) additional Java arguments",parse_tagged_sents
"A class for dependency parsing with MaltParser. The input is the paths to:
- a maltparser directory
- (optionally) the path to a pre-trained MaltParser .mco model file
- (optionally) the tagger to use for POS tagging before parsing
- (optionally) additional Java arguments",train
"A class for dependency parsing with MaltParser. The input is the paths to:
- a maltparser directory
- (optionally) the path to a pre-trained MaltParser .mco model file
- (optionally) the tagger to use for POS tagging before parsing
- (optionally) additional Java arguments",train_from_file
"A scorer for calculated the weights on the edges of a weighted
dependency graph.  This is used by a
ProbabilisticNonprojectiveParser to initialize the edge
weights of a DependencyGraph.  While typically this would be done
by training a binary classifier, any class that can return a
multidimensional list representation of the edge weights can
implement this interface.  As such, it has no necessary
fields.",score
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",best_incoming_arc
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",collapse_nodes
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",compute_max_subtract_score
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",compute_original_indexes
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",initialize_edge_scores
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",original_best_arc
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",update_edge_scores
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",nltk.parse.pchart.
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",BottomUpProbabilisticChartParser
"The sorting order for the queue is not specified by
BottomUpProbabilisticChartParser.  Different sorting orders will
result in different search strategies.  The sorting order for the
queue is defined by the method sort_queue; subclasses are required
to provide a definition for this method.",sort_queue
"The sorting order for the queue is not specified by
BottomUpProbabilisticChartParser.  Different sorting orders will
result in different search strategies.  The sorting order for the
queue is defined by the method sort_queue; subclasses are required
to provide a definition for this method.",trace
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",InsideChartParser
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",LongestChartParser
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",ProbabilisticBottomUpInitRule
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",ProbabilisticBottomUpPredictRule
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",ProbabilisticFundamentalRule
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",ProbabilisticLeafEdge
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",ProbabilisticTreeEdge
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",RandomChartParser
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",SingleEdgeProbabilisticFundamentalRule
"BottomUpProbabilisticChartParser is an abstract class that implements
a bottom-up chart parser for PCFG grammars.  It maintains a queue of edges,
and adds them to the chart one at a time.  The ordering of this queue
is based on the probabilities associated with the edges, allowing the
parser to expand more likely edges before less likely ones.  Each
subclass implements a different queue ordering, producing different
search strategies.  Currently the following subclasses are defined:",UnsortedChartParser
"A cell from the parse chart formed when performing the CYK algorithm.
Each cell keeps track of its x and y coordinates (though this will probably
be discarded), and a list of spans serving as the cell’s entries.",add
"This parser returns the most probable projective parse derived from the
probabilistic dependency grammar derived from the train() method.  The
probabilistic model is an implementation of Eisner’s (1996) Model C, which
conditions on head-word, head-tag, child-word, and child-tag.  The decoding
uses a bottom-up chart-based span concatenation algorithm that’s identical
to the one utilized by the rule-based projective parser.",compute_prob
"This parser returns the most probable projective parse derived from the
probabilistic dependency grammar derived from the train() method.  The
probabilistic model is an implementation of Eisner’s (1996) Model C, which
conditions on head-word, head-tag, child-word, and child-tag.  The decoding
uses a bottom-up chart-based span concatenation algorithm that’s identical
to the one utilized by the rule-based projective parser.",concatenate
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",backtrack
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",currently_complete
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",expand
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",expandable_productions
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",frontier
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",match
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",remaining_text
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",tree
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",untried_expandable_productions
"The initialize method is used to start parsing a text.
expand expands the first element on the frontier using a single
CFG production, and match matches the first element on the
frontier against the next text token. backtrack undoes the most
recent expand or match operation.  step performs a single
expand, match, or backtrack operation.  parses returns the set
of parses that have been found by the parser.",untried_match
"The initialize method is used to start parsing a text.
shift performs a single shift operation, and reduce performs
a single reduce operation.  step will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  parses returns the set of parses that have been
found by the parser.",reduce
"The initialize method is used to start parsing a text.
shift performs a single shift operation, and reduce performs
a single reduce operation.  step will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  parses returns the set of parses that have been
found by the parser.",reducible_productions
"The initialize method is used to start parsing a text.
shift performs a single shift operation, and reduce performs
a single reduce operation.  step will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  parses returns the set of parses that have been
found by the parser.",shift
"The initialize method is used to start parsing a text.
shift performs a single shift operation, and reduce performs
a single reduce operation.  step will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  parses returns the set of parses that have been
found by the parser.",stack
"The initialize method is used to start parsing a text.
shift performs a single shift operation, and reduce performs
a single reduce operation.  step will perform a single reduce
operation if possible; otherwise, it will perform a single shift
operation.  parses returns the set of parses that have been
found by the parser.",undo
This class also provides a method to represent a configuration as list of features.,extract_features
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",LEFT_ARC
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",REDUCE
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",RIGHT_ARC
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",SHIFT
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",left_arc
"This class defines a set of transition which is applied to a configuration to get another configuration
Note that for different parsing algorithm, the transition is different.",right_arc
Class for transition based parser. Implement 2 algorithms which are “arc-standard” and “arc-eager”,ARC_EAGER
Class for transition based parser. Implement 2 algorithms which are “arc-standard” and “arc-eager”,ARC_STANDARD
Unit tests for  CFG.,run
Return a dot representation suitable for using with Graphviz.,">>> dg = DependencyGraph(
...     'John N 2\n'
...     'loves V 0\n'
...     'Mary N 2'
... )
>>> print(dg.to_dot())
digraph G{
edge [dir=forward]
node [shape=plaintext]

0 [label=""0 (None)""]
0 -> 2 [label=""ROOT""]
1 [label=""1 (John)""]
2 [label=""2 (loves)""]
2 -> 1 [label=""""]
2 -> 3 [label=""""]
3 [label=""3 (Mary)""]
}"
"Class for measuring labelled and unlabelled attachment score for
dependency parsing. Note that the evaluation ignores punctuation.",">>> from nltk.parse import DependencyGraph, DependencyEvaluator"
"Class for measuring labelled and unlabelled attachment score for
dependency parsing. Note that the evaluation ignores punctuation.",">>> gold_sent = DependencyGraph(""""""
... Pierre  NNP     2       NMOD
... Vinken  NNP     8       SUB
... ,       ,       2       P
... 61      CD      5       NMOD
... years   NNS     6       AMOD
... old     JJ      2       NMOD
... ,       ,       2       P
... will    MD      0       ROOT
... join    VB      8       VC
... the     DT      11      NMOD
... board   NN      9       OBJ
... as      IN      9       VMOD
... a       DT      15      NMOD
... nonexecutive    JJ      15      NMOD
... director        NN      12      PMOD
... Nov.    NNP     9       VMOD
... 29      CD      16      NMOD
... .       .       9       VMOD
... """""")"
"Class for measuring labelled and unlabelled attachment score for
dependency parsing. Note that the evaluation ignores punctuation.",">>> parsed_sent = DependencyGraph(""""""
... Pierre  NNP     8       NMOD
... Vinken  NNP     1       SUB
... ,       ,       3       P
... 61      CD      6       NMOD
... years   NNS     6       AMOD
... old     JJ      2       NMOD
... ,       ,       3       AMOD
... will    MD      0       ROOT
... join    VB      8       VC
... the     DT      11      AMOD
... board   NN      9       OBJECT
... as      IN      9       NMOD
... a       DT      15      NMOD
... nonexecutive    JJ      15      NMOD
... director        NN      12      PMOD
... Nov.    NNP     9       VMOD
... 29      CD      16      NMOD
... .       .       9       VMOD
... """""")"
"Class for measuring labelled and unlabelled attachment score for
dependency parsing. Note that the evaluation ignores punctuation.",">>> de = DependencyEvaluator([parsed_sent],[gold_sent])
>>> las, uas = de.eval()
>>> las
0.6...
>>> uas
0.8...
>>> abs(uas - 0.8) < 0.00001
True"
"A class for dependency parsing with MaltParser. The input is the paths to:
- a maltparser directory
- (optionally) the path to a pre-trained MaltParser .mco model file
- (optionally) the tagger to use for POS tagging before parsing
- (optionally) additional Java arguments",">>> from nltk.parse import malt
>>> # With MALT_PARSER and MALT_MODEL environment set.
>>> mp = malt.MaltParser('maltparser-1.7.2', 'engmalt.linear-1.7.mco') 
>>> mp.parse_one('I shot an elephant in my pajamas .'.split()).tree() 
(shot I (elephant an) (in (pajamas my)) .)
>>> # Without MALT_PARSER and MALT_MODEL environment.
>>> mp = malt.MaltParser('/home/user/maltparser-1.7.2/', '/home/user/engmalt.linear-1.7.mco') 
>>> mp.parse_one('I shot an elephant in my pajamas .'.split()).tree() 
(shot I (elephant an) (in (pajamas my)) .)"
"A dependency scorer built around a MaxEnt classifier.  In this
particular class that classifier is a NaiveBayesClassifier.
It uses head-word, head-tag, child-word, and child-tag features
for classification.",">>> from nltk.parse.dependencygraph import DependencyGraph, conll_data2"
"A dependency scorer built around a MaxEnt classifier.  In this
particular class that classifier is a NaiveBayesClassifier.
It uses head-word, head-tag, child-word, and child-tag features
for classification.",">>> graphs = [DependencyGraph(entry) for entry in conll_data2.split('\n\n') if entry]
>>> npp = ProbabilisticNonprojectiveParser()
>>> npp.train(graphs, NaiveBayesDependencyScorer())
>>> parses = npp.parse(['Cathy', 'zag', 'hen', 'zwaaien', '.'], ['N', 'V', 'Pron', 'Adj', 'N', 'Punc'])
>>> len(list(parses))
1"
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",">>> class Scorer(DependencyScorerI):
...     def train(self, graphs):
...         pass
...
...     def score(self, graph):
...         return [
...             [[], [5],  [1],  [1]],
...             [[], [],   [11], [4]],
...             [[], [10], [],   [5]],
...             [[], [8],  [8],  []],
...         ]"
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",">>> npp = ProbabilisticNonprojectiveParser()
>>> npp.train([], Scorer())"
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",">>> parses = npp.parse(['v1', 'v2', 'v3'], [None, None, None])
>>> len(list(parses))
1"
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",>>> from nltk.grammar import DependencyGrammar
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",">>> grammar = DependencyGrammar.fromstring('''
... 'taught' -> 'play' | 'man'
... 'man' -> 'the' | 'in'
... 'in' -> 'corner'
... 'corner' -> 'the'
... 'play' -> 'golf' | 'dachshund' | 'to'
... 'dachshund' -> 'his'
... ''')"
"Nonprojective dependencies allows for “crossing branches” in the parse tree
which is necessary for representing particular linguistic phenomena, or even
typical parses in some languages.  This parser follows the MST parsing
algorithm, outlined in McDonald(2005), which likens the search for the best
non-projective parse to finding the maximum spanning tree in a weighted
directed graph.",">>> ndp = NonprojectiveDependencyParser(grammar)
>>> parses = ndp.parse(['the', 'man', 'in', 'the', 'corner', 'taught', 'his', 'dachshund', 'to', 'play', 'golf'])
>>> len(list(parses))
4"
"This parser returns the most probable projective parse derived from the
probabilistic dependency grammar derived from the train() method.  The
probabilistic model is an implementation of Eisner’s (1996) Model C, which
conditions on head-word, head-tag, child-word, and child-tag.  The decoding
uses a bottom-up chart-based span concatenation algorithm that’s identical
to the one utilized by the rule-based projective parser.",>>> from nltk.parse.dependencygraph import conll_data2
"This parser returns the most probable projective parse derived from the
probabilistic dependency grammar derived from the train() method.  The
probabilistic model is an implementation of Eisner’s (1996) Model C, which
conditions on head-word, head-tag, child-word, and child-tag.  The decoding
uses a bottom-up chart-based span concatenation algorithm that’s identical
to the one utilized by the rule-based projective parser.",">>> graphs = [
... DependencyGraph(entry) for entry in conll_data2.split('\n\n') if entry
... ]"
"This parser returns the most probable projective parse derived from the
probabilistic dependency grammar derived from the train() method.  The
probabilistic model is an implementation of Eisner’s (1996) Model C, which
conditions on head-word, head-tag, child-word, and child-tag.  The decoding
uses a bottom-up chart-based span concatenation algorithm that’s identical
to the one utilized by the rule-based projective parser.",">>> ppdp = ProbabilisticProjectiveDependencyParser()
>>> ppdp.train(graphs)"
"This parser returns the most probable projective parse derived from the
probabilistic dependency grammar derived from the train() method.  The
probabilistic model is an implementation of Eisner’s (1996) Model C, which
conditions on head-word, head-tag, child-word, and child-tag.  The decoding
uses a bottom-up chart-based span concatenation algorithm that’s identical
to the one utilized by the rule-based projective parser.",">>> sent = ['Cathy', 'zag', 'hen', 'wild', 'zwaaien', '.']
>>> list(ppdp.parse(sent))
[Tree('zag', ['Cathy', 'hen', Tree('zwaaien', ['wild', '.'])])]"
"ShiftReduceParser maintains a stack, which records the
structure of a portion of the text.  This stack is a list of
strings and Trees that collectively cover a portion of
the text.  For example, while parsing the sentence “the dog saw
the man” with a typical grammar, ShiftReduceParser will produce
the following stack, which covers “the dog saw”:","[(NP: (Det: 'the') (N: 'dog')), (V: 'saw')]"
"###################### Check The Transition #######################
Check the Initialized Configuration
>>> print(conf)
Stack : [0]  Buffer : [1, 2, 3, 4, 5, 6, 7, 8, 9]   Arcs : []",">>> operation = Transition('arc-standard')
>>> operation.shift(conf)
>>> operation.left_arc(conf, ""ATT"")
>>> operation.shift(conf)
>>> operation.left_arc(conf,""SBJ"")
>>> operation.shift(conf)
>>> operation.shift(conf)
>>> operation.left_arc(conf, ""ATT"")
>>> operation.shift(conf)
>>> operation.shift(conf)
>>> operation.shift(conf)
>>> operation.left_arc(conf, ""ATT"")"
"###################### Check The Transition #######################
Check the Initialized Configuration
>>> print(conf)
Stack : [0]  Buffer : [1, 2, 3, 4, 5, 6, 7, 8, 9]   Arcs : []",">>> print(', '.join(conf.extract_features()))
STK_0_FORM_on, STK_0_LEMMA_on, STK_0_POS_IN, STK_1_POS_NN, BUF_0_FORM_markets, BUF_0_LEMMA_markets, BUF_0_POS_NNS, BUF_1_FORM_., BUF_1_POS_., BUF_0_LDEP_ATT"
"###################### Check The Transition #######################
Check the Initialized Configuration
>>> print(conf)
Stack : [0]  Buffer : [1, 2, 3, 4, 5, 6, 7, 8, 9]   Arcs : []",">>> operation.right_arc(conf, ""PC"")
>>> operation.right_arc(conf, ""ATT"")
>>> operation.right_arc(conf, ""OBJ"")
>>> operation.shift(conf)
>>> operation.right_arc(conf, ""PU"")
>>> operation.right_arc(conf, ""ROOT"")
>>> operation.shift(conf)"
"###################### Check The Transition #######################
Check the Initialized Configuration
>>> print(conf)
Stack : [0]  Buffer : [1, 2, 3, 4, 5, 6, 7, 8, 9]   Arcs : []",">>> conf = Configuration(gold_sent)
>>> operation = Transition('arc-eager')
>>> operation.shift(conf)
>>> operation.left_arc(conf,'ATT')
>>> operation.shift(conf)
>>> operation.left_arc(conf,'SBJ')
>>> operation.right_arc(conf,'ROOT')
>>> operation.shift(conf)
>>> operation.left_arc(conf,'ATT')
>>> operation.right_arc(conf,'OBJ')
>>> operation.right_arc(conf,'ATT')
>>> operation.shift(conf)
>>> operation.left_arc(conf,'ATT')
>>> operation.right_arc(conf,'PC')
>>> operation.reduce(conf)
>>> operation.reduce(conf)
>>> operation.reduce(conf)
>>> operation.right_arc(conf,'PU')
>>> print(conf)
Stack : [0, 3, 9]  Buffer : []   Arcs : [(2, 'ATT', 1), (3, 'SBJ', 2), (0, 'ROOT', 3), (5, 'ATT', 4), (3, 'OBJ', 5), (5, 'ATT', 6), (8, 'ATT', 7), (6, 'PC', 8), (3, 'PU', 9)]"
"A. Check the ARC-STANDARD training
>>> import tempfile
>>> import os
>>> input_file = tempfile.NamedTemporaryFile(prefix=’transition_parse.train’, dir=tempfile.gettempdir(), delete=False)",">>> parser_std = TransitionParser('arc-standard')
>>> print(', '.join(parser_std._create_training_examples_arc_std([gold_sent], input_file)))
 Number of training examples : 1
 Number of valid (projective) examples : 1
SHIFT, LEFTARC:ATT, SHIFT, LEFTARC:SBJ, SHIFT, SHIFT, LEFTARC:ATT, SHIFT, SHIFT, SHIFT, LEFTARC:ATT, RIGHTARC:PC, RIGHTARC:ATT, RIGHTARC:OBJ, SHIFT, RIGHTARC:PU, RIGHTARC:ROOT, SHIFT"
"A. Check the ARC-STANDARD training
>>> import tempfile
>>> import os
>>> input_file = tempfile.NamedTemporaryFile(prefix=’transition_parse.train’, dir=tempfile.gettempdir(), delete=False)",">>> parser_std.train([gold_sent],'temp.arcstd.model', verbose=False)
 Number of training examples : 1
 Number of valid (projective) examples : 1
>>> remove(input_file.name)"
"A. Check the ARC-STANDARD training
>>> import tempfile
>>> import os
>>> input_file = tempfile.NamedTemporaryFile(prefix=’transition_parse.train’, dir=tempfile.gettempdir(), delete=False)",">>> input_file = tempfile.NamedTemporaryFile(prefix='transition_parse.train', dir=tempfile.gettempdir(),delete=False)
>>> parser_eager = TransitionParser('arc-eager')
>>> print(', '.join(parser_eager._create_training_examples_arc_eager([gold_sent], input_file)))
 Number of training examples : 1
 Number of valid (projective) examples : 1
SHIFT, LEFTARC:ATT, SHIFT, LEFTARC:SBJ, RIGHTARC:ROOT, SHIFT, LEFTARC:ATT, RIGHTARC:OBJ, RIGHTARC:ATT, SHIFT, LEFTARC:ATT, RIGHTARC:PC, REDUCE, REDUCE, REDUCE, RIGHTARC:PU"
"A. Check the ARC-STANDARD training
>>> import tempfile
>>> import os
>>> input_file = tempfile.NamedTemporaryFile(prefix=’transition_parse.train’, dir=tempfile.gettempdir(), delete=False)",">>> parser_eager.train([gold_sent],'temp.arceager.model', verbose=False)
 Number of training examples : 1
 Number of valid (projective) examples : 1"
"A. Check the ARC-STANDARD training
>>> import tempfile
>>> import os
>>> input_file = tempfile.NamedTemporaryFile(prefix=’transition_parse.train’, dir=tempfile.gettempdir(), delete=False)",>>> remove(input_file.name)
"A. Check the ARC-STANDARD training
>>> import tempfile
>>> import os
>>> input_file = tempfile.NamedTemporaryFile(prefix=’transition_parse.train’, dir=tempfile.gettempdir(), delete=False)",">>> result = parser_std.parse([gold_sent], 'temp.arcstd.model')
>>> de = DependencyEvaluator(result, [gold_sent])
>>> de.eval() >= (0, 0)
True"
A module to convert a single POS tagged sentence into CONLL format.,">>> from nltk import word_tokenize, pos_tag
>>> text = ""This is a foobar sentence.""
>>> for line in taggedsent_to_conll(pos_tag(word_tokenize(text))):
...         print(line, end="""")
    1       This    _       DT      DT      _       0       a       _       _
    2       is      _       VBZ     VBZ     _       0       a       _       _
    3       a       _       DT      DT      _       0       a       _       _
    4       foobar  _       JJ      JJ      _       0       a       _       _
    5       sentence        _       NN      NN      _       0       a       _       _
    6       .               _       .       .       _       0       a       _       _"
"A module to convert the a POS tagged document stream
(i.e. list of list of tuples, a list of sentences) and yield lines
in CONLL format. This module yields one line per word and two newlines
for end of sentence.",">>> from nltk import word_tokenize, sent_tokenize, pos_tag
>>> text = ""This is a foobar sentence. Is that right?""
>>> sentences = [pos_tag(word_tokenize(sent)) for sent in sent_tokenize(text)]
>>> for line in taggedsents_to_conll(sentences):
...     if line:
...         print(line, end="""")
1   This    _       DT      DT      _       0       a       _       _
2   is      _       VBZ     VBZ     _       0       a       _       _
3   a       _       DT      DT      _       0       a       _       _
4   foobar  _       JJ      JJ      _       0       a       _       _
5   sentence        _       NN      NN      _       0       a       _       _
6   .               _       .       .       _       0       a       _       _


1   Is      _       VBZ     VBZ     _       0       a       _       _
2   that    _       IN      IN      _       0       a       _       _
3   right   _       NN      NN      _       0       a       _       _
4   ?       _       .       .       _       0       a       _       _"
