To install a wheel from PyPI:,"pip install --upgrade ""pip>=20.3"" # manylinux_x_y, universal2 wheel support pip install --upgrade orjson"
"To serialize a subclass or arbitrary types, specify default as a callable that returns a supported type. default may be a function, lambda, or callable class instance. To specify that a type was not handled by default, raise an exception such as TypeError.",">>> import orjson, decimal >>> def default(obj): if isinstance(obj, decimal.Decimal): return str(obj) raise TypeError >>> orjson.dumps(decimal.Decimal(""0.0842389659712649442845"")) JSONEncodeError: Type is not JSON serializable: decimal.Decimal >>> orjson.dumps(decimal.Decimal(""0.0842389659712649442845""), default=default) b'""0.0842389659712649442845""' >>> orjson.dumps({1, 2}, default=default) orjson.JSONEncodeError: Type is not JSON serializable: set"
"It is important that default raise an exception if a type cannot be handled. Python otherwise implicitly returns None, which appears to the caller like a legitimate value and is serialized:",">>> import orjson, json, rapidjson >>> def default(obj): if isinstance(obj, decimal.Decimal): return str(obj) >>> orjson.dumps({""set"":{1, 2}}, default=default) b'{""set"":null}' >>> json.dumps({""set"":{1, 2}}, default=default) '{""set"":null}' >>> rapidjson.dumps({""set"":{1, 2}}, default=default) '{""set"":null}'"
Pretty-print output with an indent of two spaces. This is equivalent to indent=2 in the standard library. Pretty printing is slower and the output larger. orjson is the fastest compared library at pretty printing and has much less of a slowdown to pretty print than the standard library does. This option is compatible with all other options.,">>> import orjson >>> orjson.dumps({""a"": ""b"", ""c"": {""d"": True}, ""e"": [1, 2]}) b'{""a"":""b"",""c"":{""d"":true},""e"":[1,2]}' >>> orjson.dumps( {""a"": ""b"", ""c"": {""d"": True}, ""e"": [1, 2]}, option=orjson.OPT_INDENT_2 ) b'{\n ""a"": ""b"",\n ""c"": {\n ""d"": true\n },\n ""e"": [\n 1,\n 2\n ]\n}'"
Pretty-print output with an indent of two spaces. This is equivalent to indent=2 in the standard library. Pretty printing is slower and the output larger. orjson is the fastest compared library at pretty printing and has much less of a slowdown to pretty print than the standard library does. This option is compatible with all other options.,"{ ""a"": ""b"", ""c"": { ""d"": true }, ""e"": [ 1, 2 ] }"
Pretty-print output with an indent of two spaces. This is equivalent to indent=2 in the standard library. Pretty printing is slower and the output larger. orjson is the fastest compared library at pretty printing and has much less of a slowdown to pretty print than the standard library does. This option is compatible with all other options.,">>> import orjson, datetime >>> orjson.dumps( {""other"": 1, datetime.date(1970, 1, 5): 2, datetime.date(1970, 1, 3): 3}, option=orjson.OPT_NON_STR_KEYS | orjson.OPT_SORT_KEYS ) b'{""1970-01-03"":3,""1970-01-05"":2,""other"":1}'"
The benchmark can be reproduced using the pysort script.,">>> import orjson >>> orjson.dumps({""a"": 1, ""ä"": 2, ""A"": 3}, option=orjson.OPT_SORT_KEYS) b'{""A"":3,""a"":1,""\xc3\xa4"":2}'"
orjson serializes enums natively. Options apply to their values.,">>> import enum, datetime, orjson >>> class DatetimeEnum(enum.Enum): EPOCH = datetime.datetime(1970, 1, 1, 0, 0, 0) >>> orjson.dumps(DatetimeEnum.EPOCH) b'""1970-01-01T00:00:00""' >>> orjson.dumps(DatetimeEnum.EPOCH, option=orjson.OPT_NAIVE_UTC) b'""1970-01-01T00:00:00+00:00""'"
Enums with members that are not supported types can be serialized using default:,">>> import enum, orjson >>> class Custom: def __init__(self, val): self.val = val def default(obj): if isinstance(obj, Custom): return obj.val raise TypeError class CustomEnum(enum.Enum): ONE = Custom(1) >>> orjson.dumps(CustomEnum.ONE, default=default) b'1'"
"To make a best effort at deserializing bad input, first decode bytes using the replace or lossy argument for errors:",">>> import orjson >>> orjson.loads(b'""\xed\xa0\x80""') JSONDecodeError: str is not valid UTF-8: surrogates not allowed >>> orjson.loads(b'""\xed\xa0\x80""'.decode(""utf-8"", ""replace"")) '���'"
